<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="referrer" content="no-referrer"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Hexo Theme Redefine"><meta name="author" content="Lu"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://registry.npmmirror.com" crossorigin><link rel="canonical" href="https://lusy37.github.io/2024/03/15/java基础学习/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:type" content="article"><meta property="og:title" content="Java基础"><meta property="og:url" content="https://lusy37.github.io/2024/03/15/java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/index.html"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://lusy37.github.io/images/redefine-og.webp"><meta property="article:published_time" content="2024-03-15T01:25:09.000Z"><meta property="article:modified_time" content="2025-03-11T04:44:58.060Z"><meta property="article:author" content="Lu"><meta property="article:tag" content="学习总结"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://lusy37.github.io/images/redefine-og.webp"><link rel="icon" type="image/png" href="/images/redefine-favicon.jpg" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.jpg"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="/images/redefine-favicon.jpg"><title>Java基础 | Lusy</title><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Chillax/chillax.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/css/build/tailwind.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Geist/geist.css"><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/anime.min.js"></script><script id="hexo-configurations">window.config={hostname:"lusy37.github.io",root:"/",language:"en",path:"search.xml"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,delete_mask:!1,title_alignment:"left",headings_top_spacing:{h1:"3.2rem",h2:"2.4rem",h3:"1.9rem",h4:"1.6rem",h5:"1.4rem",h6:"1.3rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",highlight_theme:{light:"github",dark:"vs2015"},font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:6,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,pangu_js:!1,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#A31F34",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null},title:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!0},scroll_progress:{bar:!1,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:{enable:!0,custom_message:null},open_graph:{enable:!0,image:"/images/redefine-og.webp",description:"Hexo Theme Redefine, Redefine Your Hexo Journey."},google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/wallhaven-wqery6-light.webp",dark:"/images/wallhaven-wqery6-dark.webp"},title:"等一场花开",subtitle:{text:["迷失的人迷失了，相遇的人再相遇","迷い人はまた迷い、巡り逢うべき人とは再び巡り逢う"],hitokoto:{enable:!1,show_author:!1,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!1,style:"default",links:{github:null,instagram:null,zhihu:null,twitter:null,email:null},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{enable:!1,type:"fixed",audios:[{name:null,artist:null,url:null,cover:null,lrc:null}]},mermaid:{enable:!1,version:"11.4.1"}},version:"2.8.2",navbar:{auto_hide:!1,color:{left:"#f78736",right:"#367df7",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-regular fa-house"},Essays:{path:"/essays",icon:"fa-regular fa-pen-to-square"},Think:{path:"/think",icon:"fa-regular fa-paper-plane"}},search:{enable:!0,preload:!0}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:"If its rainy, you won't see me.If its sunny ,you'll think of me.",show_on_mobile:!0,links:{Archives:{path:"/archives",icon:"fa-regular fa-archive"},Tags:{path:"/tags",icon:"fa-regular fa-tags"},Categories:{path:"/categories",icon:"fa-regular fa-folder"}}},article_date_format:"YYYY-MM-DD",excerpt_length:200,categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2024/2/12 15:45:14"},window.lang_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},window.data={masonry:!1}</script><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/brands.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/solid.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/regular.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span></div><style>:root{--preloader-background-color:#fff;--preloader-text-color:#000}@media (prefers-color-scheme:dark){:root{--preloader-background-color:#202124;--preloader-text-color:#fff}}@media (prefers-color-scheme:light){:root{--preloader-background-color:#fff;--preloader-text-color:#000}}@media (max-width:600px){.ml13{font-size:2.6rem!important}}.preloader{display:flex;flex-direction:column;gap:1rem;align-items:center;justify-content:center;position:fixed;padding:12px;top:0;right:0;bottom:0;left:0;width:100vw;height:100vh;background-color:var(--preloader-background-color);z-index:1100;transition:opacity .2s ease-in-out}.ml13{font-size:3.2rem;color:var(--preloader-text-color);letter-spacing:-1px;font-weight:500;font-family:Chillax-Variable,sans-serif;text-align:center}.ml13 .word{display:inline-flex;flex-wrap:wrap;white-space:nowrap}.ml13 .letter{display:inline-block;line-height:1em}</style><div class="preloader"><h2 class="ml13">Lusy</h2><script>var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });

        var animation = anime.timeline({ loop: true })
            .add({
                targets: '.ml13 .letter',
                translateY: [20, 0],
                translateZ: 0,
                opacity: [0, 1],
                filter: ['blur(5px)', 'blur(0px)'],
                easing: "easeOutExpo",
                duration: 1200,
                delay: (el, i) => 300 + 20 * i,
            })
            .add({
                targets: '.ml13 .letter',
                translateY: [0, -20],
                opacity: [1, 0],
                filter: ['blur(0px)', 'blur(5px)'],
                easing: "easeInExpo",
                duration: 1000,
                delay: (el, i) => 15 * i,
                complete: function() {
                    hidePreloader();
                }
            }, '-=700');


        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            setTimeout(hidePreloader, 5000); // Call hidePreloader after 5000 milliseconds if not already called by animation
        });

        function hidePreloader() {
            var preloader = document.querySelector('.preloader');
            preloader.style.opacity = '0';
            setTimeout(function () {
                preloader.style.display = 'none';
            }, 200);
        }</script></div><main class="page-container" id="swup"><div class="main-content-container flex flex-col justify-between min-h-dvh"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content transition-navbar"><div class="left"><a class="logo-title" href="/">Lusy</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house fa-fw"></i> HOME</a></li><li class="navbar-item"><a href="/essays"><i class="fa-regular fa-pen-to-square fa-fw"></i> ESSAYS</a></li><li class="navbar-item"><a href="/think"><i class="fa-regular fa-paper-plane fa-fw"></i> THINK</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>HOME </span><i class="fa-regular fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/essays"><span>ESSAYS </span><i class="fa-regular fa-pen-to-square fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/think"><span>THINK </span><i class="fa-regular fa-paper-plane fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/archives"><span>Archives</span> <i class="fa-regular fa-archive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/tags"><span>Tags</span> <i class="fa-regular fa-tags fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/categories"><span>Categories</span> <i class="fa-regular fa-folder fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">9</div><div class="label text-third-text-color text-sm">Tags</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">5</div><div class="label text-third-text-color text-sm">Categories</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">24</div><div class="label text-third-text-color text-sm">Posts</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body transition-fade-up"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Java基础</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="/images/redefine-avatar.jpg"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">Lu</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv3</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2024-03-15 09:25:09</span> <span class="mobile">2024-03-15 09:25:09</span> <span class="hover-info">Created</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2025-03-11 12:44:58</span> <span class="mobile">2025-03-11 12:44:58</span> <span class="hover-info">Updated</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/Java/">Java</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">学习总结</a>&nbsp;</li><li>| <a href="/tags/Java/">Java</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fa-regular fa-typewriter"></i>&nbsp;<span>11.9k Words</span> </span><span class="article-min2read article-meta-item"><i class="fa-regular fa-clock"></i>&nbsp;<span>44 Mins</span> </span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="不同类型数组的初始化值"><a href="#不同类型数组的初始化值" class="headerlink" title="不同类型数组的初始化值"></a>不同类型数组的初始化值</h3><p>整数型：默认初始化值<strong>0</strong><br>小数型：默认初始化值<strong>0.0</strong><br>字符型：默认初始化值<code>/u0000</code>,即<strong>空格</strong><br>布尔型：默认初始化值 <strong>false</strong><br>引用型(除上面类型之外)：默认初始化值<strong>null</strong></p><h3 id="基本数据类型和引用数据类型的区别"><a href="#基本数据类型和引用数据类型的区别" class="headerlink" title="基本数据类型和引用数据类型的区别"></a>基本数据类型和引用数据类型的区别</h3><ol><li><p><strong>基本数据类型（Primitive Types）：</strong></p><ul><li>Java的基本数据类型是预定义的，并且它们是直接存储数据值的。</li><li>基本数据类型包括整型（int、short、long、byte）、浮点型（float、double）、字符型（char）和布尔型（boolean）。</li><li>基本数据类型的变量存储的是实际的数据值，它们在内存中的存储是在栈（Stack）中。</li><li><strong>基本数据类型是值传递，传递的是实际的数据值。</strong></li></ul></li><li><p><strong>引用类型（Reference Types）：</strong></p><ul><li>引用类型是由类（Class）、接口（Interface）、数组（Array）和枚举（Enum）等引用数据类型所构成的。</li><li>引用类型的变量存储的是对象的引用（内存地址），而不是对象本身的实际数据。</li><li>引用类型的对象在内存中的存储是在堆（Heap）中。</li><li>引用类型的变量本质上是指向对象的引用，它们可以指向同一个对象，也可以指向不同的对象。</li><li><strong>引用类型是对象的引用传递，传递的是对象的引用。</strong></li></ul></li></ol><blockquote><p>区别总结如下：</p><ul><li><strong>基本数据类型</strong>（Primitive Types）：<ul><li>存储的是实际的数据值。</li><li>在内存中存储在栈中。</li><li>是值传递，传递的是实际的数据值。</li></ul></li><li><strong>引用类型</strong>（Reference Types）：<ul><li>存储的是对象的引用（内存地址）。</li><li>对象存储在堆中。</li><li>是引用传递，传递的是对象的引用。</li></ul></li></ul></blockquote><h3 id="idea的常用快捷键"><a href="#idea的常用快捷键" class="headerlink" title="idea的常用快捷键"></a>idea的常用快捷键</h3><ul><li><code>Ctrl + P</code>:查看形参</li><li><code>Ctrl + D</code>:复制当前行到下一行</li><li><code>Ctrl + Y</code>:删除代码</li><li><code>Ctrl + Shift + ,</code>:一键生成标准的JavaBean代码[需要下载ptg插件]</li><li><code>Alt + Insert</code>:生成标准的JavaBean代码</li><li><code>Ctrl + Alt + V</code>:自动将该表达式或代码块提取为一个新的变量</li><li><code>Ctrl + Alt + L</code>:格式化代码</li><li><code>Ctrl + Alt + M</code>:提取方法</li><li><code>Alt + Enter</code>:快速修复</li><li><code>Ctrl + Insert</code>:自动生成代码</li><li><code>Tab</code>:自动补全代码</li><li><code>Ctrl + B</code>:跳转到声明处</li><li><code>Ctrl + Alt + T</code>:选定结构(<code>if</code>语句,<code>while</code>语句)</li><li><code>Alt + 鼠标拖动</code>:多重选择[对多个对象同时进行删除或修改]</li><li><code>Ctrl + Shift + ↑/↓</code>:代码上下移动</li><li><code>选中 + Shift + F6</code>:向下整体修改</li><li><code>Ctrl + N</code>:查找并导航到指定的类</li><li><code>Ctrl + F12</code>:调出当前编辑文件的结构视图或者是类的成员列表</li><li><code>Ctrl + 鼠标点击</code>：点击方法的话可以查看在当前项目中哪里被引用，如果再次之上在按下快捷键 <code>Ctrl + Alt +F7</code>，可以查看在项目和仓库中哪里被引用</li><li><code>Ctrl + Alt + 向左</code>：返回上一张页面</li></ul><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区：<strong>用于描述存储已被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据的内存区域</strong><br>永久代(JDK8以前)&#x2F;元空间(JDK8及以后)：<strong>是方法区的具体实现</strong><br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240413115206.png"></p><blockquote><p><strong><mark>在JDK 8之前，方法区的实现通常是永久代。而在JDK 8及之后，方法区的实现主要是元空间。</mark></strong></p><p>将永久代替换为元空间的主要原因是解决了永久代存在的一些问题，使Java虚拟机更适应现代应用程序的需求。</p><ol><li><p><strong>内存管理方式</strong>：</p><ul><li><strong>永久代</strong>：<mark>永久代的内存空间是在Java堆内的一部分</mark>，它受到了Java堆内存的大小限制。</li><li><strong>元空间</strong>：<mark>元空间通常位于本地内存中</mark>，不再与Java堆绑定，因此不受Java堆内存的限制。这使得元空间可以根据需要动态扩展，避免了永久代固定大小带来的限制。</li></ul></li><li><p><strong>垃圾回收机制</strong>：</p><ul><li><strong>永久代</strong>：<mark>永久代中的垃圾回收通常由Full GC（全局垃圾回收）来执行</mark>，效率较低，并且可能会导致长时间的停顿。</li><li><strong>元空间</strong>：元空间的内存管理不再依赖于Java虚拟机的垃圾回收机制，而是<mark>由本地内存的管理机制来负责</mark>。这降低了垃圾回收的成本，并提高了应用程序的性能和稳定性。</li></ul></li><li><p><strong>动态调整大小</strong>：</p><ul><li><strong>永久代</strong>：<mark>永久代的大小是固定的，无法动态调整</mark>。这可能会导致在某些情况下出现永久代溢出的问题。</li><li><strong>元空间</strong>：<mark>元空间可以根据应用程序的需要动态调整大小，不再受到固定大小的限制</mark>。这提高了虚拟机的灵活性，并减少了出现内存溢出的风险。</li></ul></li><li><p><strong>存储内容</strong>：</p><ul><li><strong>永久代</strong>：永久代主要用于存储类的元数据信息和静态变量。</li><li><strong>元空间</strong>：元空间用于存储类的元数据信息，例如类的结构、方法信息、注解等。<mark>与永久代相比，元空间更加灵活，并且可以存储更多类型的元数据信息</mark>。</li></ul></li></ol><p>总的来说，替换永久代为元空间是为了提高Java虚拟机在处理大量类加载和卸载操作时的性能和可用性。元空间的动态调整大小、本地内存管理以及不依赖于Java虚拟机的垃圾回收机制等特性，使得它更适合应对现代应用程序的需求。</p></blockquote><h3 id="串池"><a href="#串池" class="headerlink" title="串池"></a>串池</h3><p><strong>基本概念</strong>：</p><ul><li>串池（String Pool）是Java中的一种特殊的内存区域，用于存储字符串常量。它是字符串常量池的另一种称呼，因为在Java中，字符串常量池主要用于存储字符串常量。[串池中的字符串是不可变的]</li><li>当我们创建一个字符串常量时，如果该字符串常量在字符串常量池中不存在，则会在字符串常量池中创建一个新的字符串对象，并将该字符串常量放入其中。如果字符串常量池中已经存在相同内容的字符串对象，则不会创建新的对象，而是直接返回已存在的对象的引用。[<strong>只有一份，全局共享</strong>]</li><li>只有<code>String</code>类型的字符串才会被添加到字符串常量池中。<code>StringBuffer</code>和<code>StringBuilder</code>类型的字符串不会自动添加到字符串常量池中。这是因为 StringBuffer 和 StringBuilder 是可变的字符串，它们的内容在运行时可以被修改，而字符串常量池中的字符串是不可变的。</li></ul><p><strong>内存管理</strong>：</p><ul><li>在JDK7版本开始从方法区中挪到了堆内存</li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h4><p>Java字符串就是Unicode字符序列。Java里没有内置的字符串类型，而是在标准的类库中提供了一个预定义类，String。每个用<strong>双引号””括起来</strong>的都是<strong>String类的一个实例</strong>。<br>字符串在日常开发中最常用， Java字符串的一个重要特点就是<strong>字符串不可变</strong></p><h4 id="2-字符串的创建"><a href="#2-字符串的创建" class="headerlink" title="2 字符串的创建"></a>2 字符串的创建</h4><ul><li>通过字符串字面量创建字符串常量。</li><li>通过调用String类的构造函数。</li><li>使用字符串连接运算符<code>+</code>创建字符串。[底层通常是使用StringBuilder(或 StringBuffer)进行字符串的拼接]</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;<span class="comment">//通过字符串字面量创建字符串常量。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);<span class="comment">//通过调用String类的构造函数。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot; &quot;</span> + <span class="string">&quot;world&quot;</span>;<span class="comment">//使用字符串连接运算符`+`创建字符串。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h4 id="3-字符串存储的内存原理"><a href="#3-字符串存储的内存原理" class="headerlink" title="3 字符串存储的内存原理"></a>3 字符串存储的内存原理</h4><ul><li>直接赋值或字符串连接操作中使用的是字符字面量（即单引号括起来的字符）的方式创建的字符串会复用串池中已存在的字符串常量</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">// 字符串 &quot;abc&quot; 存储在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;b&#x27;</span> + <span class="string">&#x27;c&#x27;</span>;<span class="comment">// 在编译时自动转换为字符串常量 &quot;abc&quot;，在串池中已经存在&quot;abc&quot;，直接复用</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//&quot;==&quot;号在比较引用类型时比较的时地址，这里的true表示s1和s2指向的对象相同</span></span><br></pre></td></tr></table></figure></div><ul><li>new出来的不会复用，而是在堆中开辟一个新的空间</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">// 使用 new 关键字创建一个新的字符串对象，不会存储在字符串常量池中</span></span><br><span class="line">System.out.println(s1 == s3); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure></div><h4 id="4-字符串操作"><a href="#4-字符串操作" class="headerlink" title="4 字符串操作"></a>4 字符串操作</h4><ul><li><code>length()</code>:用于获取字符串的长度，即字符串中包含的字符数。</li><li><code>substring(int beginIndex, int endIndex)</code>:方法用于截取字符串的子串，从 beginIndex 开始（包括），到 endIndex 结束（不包括）。</li><li><code>concat(String str)</code>:方法用于连接两个字符串，将参数字符串 str 连接到调用方法的字符串末尾。</li><li><code>indexOf(String str)</code>:方法用于查找指定子串 str 在字符串中第一次出现的位置，如果找到了，返回该子串的起始索引；如果没有找到，返回 -1。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();<span class="comment">//13</span></span><br><span class="line"><span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> str.substring(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">//&quot;Hello&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> str.concat(<span class="string">&quot; Welcome&quot;</span>); <span class="comment">//&quot;Hello, world! Welcome&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str.indexOf(<span class="string">&quot;world&quot;</span>); <span class="comment">//7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h4 id="5-String、StringBuffer、StringBuilder的区别"><a href="#5-String、StringBuffer、StringBuilder的区别" class="headerlink" title="5 String、StringBuffer、StringBuilder的区别"></a>5 String、StringBuffer、StringBuilder的区别</h4><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><p><code>String</code> 类是 Java 中最常用的字符串类，它表示一个不可变的字符序列。这意味着一旦创建了一个 <code>String</code> 对象，它的值就无法更改。因此，每次对字符串进行修改时都会创建一个新的字符串对象，旧的字符串对象则会被丢弃。这种不可变性使得字符串在多线程环境下是安全的，并且可以作为常量使用。<br><strong>用途</strong>：</p><ul><li>表示字符串常量。</li><li>在字符串操作不频繁的场景下使用，例如配置文件、类文件的路径等。</li></ul><h5 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h5><p><code>StringBuffer</code> 类是 Java 中可变字符串的实现，它允许我们在字符串中进行添加、修改和删除操作。与 <code>String</code> 不同，<code>StringBuffer</code> 是可变的，可以动态地改变其内容，而不会创建新的对象。因此，<code>StringBuffer</code> 适用于需要频繁进行字符串操作的场景，例如在循环中构建字符串、拼接大量字符串等。<br><strong>用途</strong>：</p><ul><li>多线程环境下需要进行频繁的字符串拼接或修改操作时使用。</li></ul><h5 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h5><p><code>StringBuilder</code> 类与 <code>StringBuffer</code> 类功能类似，也是可变字符串的实现。与 <code>StringBuffer</code> 不同的是，<code>StringBuilder</code> 是非线程安全的，但是它的性能通常更好。因此，如果在单线程环境中进行字符串操作，通常优先选择 <code>StringBuilder</code>。<br><strong>用途</strong>：</p><ul><li>单线程环境下需要频繁进行字符串操作时使用。<blockquote><p><strong>线程问题</strong></p><ul><li>StringBuffer<br><code>StringBuffer</code> 是线程安全的，因为它的方法都是同步的，即在方法内部使用了 <code>synchronized</code> 关键字来确保在多线程环境下操作字符串时的安全性。这意味着当多个线程同时访问同一个 <code>StringBuffer</code> 对象时，它们的操作会被正确地同步，不会发生数据不一致的情况。</li><li>StringBuilder<br><code>StringBuilder</code> 是非线程安全的，因为它的方法没有进行同步处理。这样的设计可以提升性能[它不会引入额外的同步开销，这使得它的性能可能会稍微优于 StringBuffer。]，但也意味着在多线程环境下同时访问同一个 <code>StringBuilder</code> 对象时，可能会出现竞态条件（race condition），导致数据不一致或其他意外行为。</li></ul></blockquote></li></ul><h4 id="字符串图解"><a href="#字符串图解" class="headerlink" title="字符串图解"></a>字符串图解</h4><p><strong>直接赋值</strong>：<br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240413194420.png"><br><strong>字符数组和new</strong>：<br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240413194445.png"><br><strong>字符串拼接的底层原理</strong>：<br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240413194459.jpeg"><br><strong>字符串原理</strong>：<br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240413194514.jpeg"><br><strong>面试题</strong>：<br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240413194534.jpeg"><br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240413194545.jpeg"></p><h3 id="static-静态变量"><a href="#static-静态变量" class="headerlink" title="static 静态变量"></a>static 静态变量</h3><h4 id="1-static关键字主要有两种作用："><a href="#1-static关键字主要有两种作用：" class="headerlink" title="1 static关键字主要有两种作用："></a>1 static关键字主要有两种作用：</h4><ul><li>为某特定数据类型或对象分配<strong>唯一</strong>的存储空间，而与创建对象的个数无关。</li><li>实现某个方法或属性与类关联在一起而不是对象关联在一起，因此不需要实例化对象，只需要用类名就可以调用静态的属性或方法。</li></ul><blockquote><p><strong>static的注意事项:</strong></p><ul><li>静态方法只能访问静态变量和静态方法</li><li>非静态方法可以访问静态变量或者静态方法,也可以访问非静态的成员变量和非静态的成员方法</li><li>静态方法中是没有this关键字<br>[总结]:<br>静态方法中,只能访问静态。<br><br>非静态方法可以访问所有。<br>静态方法中没有this关键字</li></ul></blockquote><h4 id="2-1-成员变量"><a href="#2-1-成员变量" class="headerlink" title="2.1 成员变量"></a>2.1 成员变量</h4><p>Java类提供了两种类型的变量：<code>用static</code>关键字修饰的<code>静态变量</code>和<code>不用static</code>关键字修饰的<code>实例变量</code>。</p><ul><li><strong>静态变量属于类</strong>，在内存中只有一个复制，只要静态变量所在的类被加载，这个静态变量就会被分配空间，因此就可以被使用了。对静态变量的引用有两种方式，分别是”<strong>类.静态变量</strong>“[<strong>推荐</strong>]和”<strong>对象.静态变量</strong>“。</li><li><strong>实例变量属于对象</strong>，只有对象被创建后，实例变量才会被分配内存空间，才能被使用，它在内存中存在多个复制，只有用”<strong>对象.实例变量</strong>“的方式来引用。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//非静态属性不可直接用类名直接调用,可以用利用对象调用</span></span><br><span class="line">        <span class="comment">//Student.score;  报错</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> stu1.score;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态属性可直接用类名调用,也可以用对象调用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Student.age;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age1</span> <span class="operator">=</span> stu1.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><blockquote><p><strong>静态变量特点:</strong></p><ul><li>被该类所有对象共享</li><li>不属于对象,属于类</li><li>随着类的加载而加载,优先于对象存在</li><li>jdk8之前：放在方法区<br>jdk8及以后：存放在堆中反射的class对象（即类加载后会在堆中生成一个对应的class对象）的尾部。</li></ul><p><strong>静态变量调用方式:</strong></p><ul><li>类名调用[推荐]</li><li>对象名调用</li></ul></blockquote><h4 id="2-2-成员方法"><a href="#2-2-成员方法" class="headerlink" title="2.2 成员方法"></a>2.2 成员方法</h4><p>Java中提供了<code>static（静态）</code>方法和<code>非static（非静态）</code>方法。</p><ul><li>static方法是类的方法，不需要创建对象就可以被类名调用</li><li>而非static方法是对象的方法，只有对象被创建出来后才可以被使用</li><li><strong>static方法中不能使用this和super关键字，不能调用非static方法</strong>，只能访问所属类的静态成员变量和成员方法，因为当static方法被调用时，这个类的对象可能还没被创建，即使已经被创建了，也无法确定调用哪个对象的方法。同理，<strong>static方法也不能访问非static类型的变量</strong></li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="comment">//System.out.println(age); 报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//静态方法可以直接用类名调用，也可以用对象调用</span></span><br><span class="line">        Student.say();</span><br><span class="line">        stu1.say();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//非静态方法只能用对象调用</span></span><br><span class="line">        <span class="comment">//Student.run(); 报错</span></span><br><span class="line">        stu1.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><strong>单例设计模式：</strong><br>static一个很重要的用途就是实现单例设计模式。<strong>单例模式的特点是该类只能有一个实例</strong>，为了实现这一功能，必须隐藏类的构造函数，即把构造函数声明为private，并提供一个创建对象的方法，<strong>由于构造对象被声明为private，外界无法直接创建这个类型的对象，只能通过该类提供的方法来获取类的对象</strong>，要达到这样的目的只能把创建对象的方法声明为<code>static</code>，程序实例如下：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">			instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p><strong>静态方法特点:</strong></p><ul><li>多用在测试类和工具类中</li><li>Javabean类中很少会用</li></ul><p><strong>静态方法调用方式:</strong></p><ul><li>类名调用[推荐]</li><li>对象名调用</li></ul></blockquote><h4 id="2-3-static代码块"><a href="#2-3-static代码块" class="headerlink" title="2.3 static代码块"></a>2.3 static代码块</h4><p>static代码块在类中是独立于成员变量和成员函数的代码块的。静态代码块先执行(优先级比构造方法还高),静态代码块中只能调用静态属性和方法，不能调用非静态的。<br><strong>且<code>只执行一次</code>，非静态代码块在在每次创建新对象的时候都会执行一次</strong><br>可以应用于数据的初始化</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;匿名代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//静态代码块先执行，且只执行一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果:</span></span><br><span class="line"><span class="comment">    静态代码块</span></span><br><span class="line"><span class="comment">    匿名代码块</span></span><br><span class="line"><span class="comment">    构造器</span></span><br><span class="line"><span class="comment">    &lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;</span></span><br><span class="line"><span class="comment">    匿名代码块</span></span><br><span class="line"><span class="comment">    构造器</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div><h4 id="2-4-static内部类"><a href="#2-4-static内部类" class="headerlink" title="2.4 static内部类"></a>2.4 static内部类</h4><ul><li><strong>static内部类可以不依赖于外部类实例对象而被实例化</strong>，而通常的内部类需要外部类实例化后才能实例化。</li><li>静态内部类不能访问外部类的普通成员变量，<strong>只能访问外部类中的静态成员和静态成员方法</strong>，因为静态内部类是与类一起加载的。</li><li><strong>只有内部类才能被申明为static</strong>。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object inter;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">sinter</span>&#123;</span><br><span class="line">        sinter()&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是静态内部类&quot;</span>);</span><br><span class="line">            <span class="comment">//只能访问外部类中的静态成员和静态成员方法</span></span><br><span class="line">            System.out.println(age);</span><br><span class="line">            say();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">inter</span>&#123;</span><br><span class="line">        inter()&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是非静态内部类&quot;</span>);</span><br><span class="line">            System.out.println(age+score);</span><br><span class="line">            say();</span><br><span class="line">            run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">text</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//静态内部类可直接实例化</span></span><br><span class="line">        Student.<span class="type">sinter</span> <span class="variable">sinter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>.sinter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//非静态内部类需要创建一个外部类对象再实例化</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        Student.<span class="type">inter</span> <span class="variable">inter</span> <span class="operator">=</span> student.<span class="keyword">new</span> <span class="title class_">inter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="继承问题"><a href="#继承问题" class="headerlink" title="继承问题"></a>继承问题</h3><h4 id="1-继承的概念"><a href="#1-继承的概念" class="headerlink" title="1 继承的概念"></a>1 继承的概念</h4><p>继承是<strong>面向对象三大特征之一</strong>，可以使得<strong>子类具有父类的属性和方法</strong>，还可以在<strong>子类中重新定义（重写），以及追加属性和方法（添加额外的父类没有的子类特有的方法）</strong></p><h4 id="2-实现格式"><a href="#2-实现格式" class="headerlink" title="2 实现格式"></a>2 实现格式</h4><ul><li>继承通过<code>extends</code>关键字实现</li><li>用法:<code>class 子类 extends 父类 &#123;&#125;</code><br>举例: class Dog extends Animal {}</li></ul><h4 id="3-子类的特点"><a href="#3-子类的特点" class="headerlink" title="3 子类的特点"></a>3 子类的特点</h4><ul><li>可以继承父类的<strong>成员变量</strong>[如果子类中有同名的成员变量,父类的变量会被隐藏]和<strong>虚方法表中的成员方法</strong>[非private、非static、非final]</li><li>子类可以有自己的成员变量和方法</li><li>子类可以<strong>重写从父类继承下来的成员方法</strong>[如果发生了重写,则会覆盖父类继承下来的成员方法]</li><li><strong>子类并不会继承父类的构造方法</strong>[因为父类的构造方法名与子类名存在冲突],因此我们创建子类时需手动添加子类的构造方法</li></ul><blockquote><p><strong>注意:</strong><br>子类中可以使用父类中的<strong>静态方法[static修饰]</strong>,但这是因为静态方法属于类而不是对象，子类可以直接通过父类名来调用父类的静态方法,这种调用方式不涉及继承关系，只是通过类名来访问类的静态成员。它们并不会参与继承的机制。</p></blockquote><h4 id="4-继承中成员变量访问的特点"><a href="#4-继承中成员变量访问的特点" class="headerlink" title="4 继承中成员变量访问的特点"></a>4 继承中成员变量访问的特点</h4><ul><li><code>遵循就近原则:局部变量-&gt;成员变量-&gt;父类</code><ul><li>先在子类的局部变量找，要是找到就用这个局部变量的值（就算有一个名字一模一样的成员变量，那也不会去访问哪个成员变量的）</li><li>然后要是在局部变量里面找不到的话，就去成员变量去去找</li><li>要是成员变量找不到的话，就去父类的成员变量去找</li><li>要是父类没有就找父类的父类</li><li>……</li><li>要是都没有找到就报错</li></ul></li></ul><h4 id="5-this-super"><a href="#5-this-super" class="headerlink" title="5 this &amp; super"></a>5 this &amp; super</h4><ul><li><code>this</code>:代表本类对象(且是调用this所在方法的那个对象)的引用</li><li><code>super</code>:代表对象父类的引用,可以调用上一级的那个类的方法或属性</li></ul><p><strong>用法</strong>:可以解决无法访问子类和父类中相同名称的成员的问题</p><ul><li>成员变量:<ul><li>this.成员变量 -&gt; 访问本类成员变量</li><li>super.成员变量 -&gt; 访问父类成员变量</li></ul></li><li>成员方法:<ul><li>this.成员方法 -&gt; 访问本类成员方法</li><li>super.成员方法 -&gt; 访问父类成员方法</li></ul></li><li>构造方法:<ul><li>this(…) -&gt; 访问本类构造方法</li><li>super(…) -&gt; 访问父类构造方法<blockquote><p><strong>注意：</strong><br>不能在<code>静态方法</code>中使用this和super关键字。<br>因为静态方法是属于类而不是对象实例的,而<code>this</code>和<code>super</code>关键字是关于对象实例的引用。</p></blockquote></li></ul></li></ul><p><strong>构造方法中的默认super</strong><br>继承中构造方法的访问特点:<br>​子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化，原因在于，<strong>每一个子类构造方法的第一条语句默认都是：super()。但是你只要自己写了super(……)调用父类的带参构造方法,那个默认隐藏的super()就失效了。</strong><br><mark>注意：子类中所有的构造方法默认隐藏地有一个super()，都会访问父类中无参的构造方法[如果手动添加了一个super(……)调用父类的带参构造方法,那个默认隐藏的super()就会失效]</mark></p><blockquote><p><strong>问题：如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢？</strong></p><ul><li>通过使用super关键字去显示的调用父类的带参构造方法</li><li>在父类中自己提供一个无参构造方法</li></ul><p><strong>推荐方案：</strong><br>​自己给出无参构造方法</p><hr><p><strong>补充说明</strong><br>除了已经提到的内容外，还有一些关于 <code>this</code> 和 <code>super</code> 的使用注意事项：</p><ol><li><strong>this() 和 super() 不能同时出现在同一个构造方法中</strong>：在同一个构造方法中，<code>this()</code> 和 <code>super()</code> 只能出现一个，并且必须是构造方法的第一条语句。</li><li><strong>this() 和 super() 只能用于构造方法</strong>：<code>this()</code> 和 <code>super()</code> 关键字只能用于构造方法中，不能用于普通方法。</li><li><strong>this 和 super 不能用于静态方法</strong>：<code>this</code> 和 <code>super</code> 关键字是关于对象实例的引用，而静态方法属于类而不是对象实例，因此无法在静态方法中使用这两个关键字。</li><li><strong>super 关键字可以在构造方法之外使用</strong>：<code>super</code> 关键字除了可以在构造方法中调用父类构造方法之外，还可以在子类的其他方法中使用来调用父类的方法或属性。</li></ol></blockquote><h4 id="6-方法的重写"><a href="#6-方法的重写" class="headerlink" title="6 方法的重写"></a>6 方法的重写</h4><ul><li><strong>继承关系</strong>：方法重写是建立在类之间的继承关系上。子类可以继承父类的方法并对其进行重写。</li><li><strong>方法签名</strong>：子类中重写的方法必须与父类中被重写的方法具有相同的方法签名，包括方法名、参数列表和返回类型。[<strong>方法签名是指方法的名称以及参数的类型和顺序</strong>]。</li><li><strong>访问修饰符</strong>：子类中重写的方法的访问修饰符不能比父类中被重写方法的访问修饰符更严格。例如，如果父类中的方法是public，那么子类中重写的方法也必须是public，不能是protected或者private。</li><li><strong>异常</strong>：子类中重写的方法不能抛出比父类中被重写方法更宽泛的异常，但可以抛出更窄的异常，或者不抛出异常。</li><li><strong>返回类型</strong>：在Java 5之前，返回类型必须完全匹配。但在Java 5及以后版本，可以使用协变返回类型，即子类中重写的方法的返回类型可以是父类中被重写方法返回类型的子类型。</li><li><strong>重写的Override注解</strong>:用来检测当前的方法，是否是重写的方法，起到【校验】的作用。就是检查你写的方法有没有严格符合重写的格式。<br>下面是一个简单的示例来说明方法重写：</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        animal.makeSound(); <span class="comment">// Output: Animal makes a sound</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.makeSound(); <span class="comment">// Output: Dog barks</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p><strong>注意</strong>:<br>在Java中，<mark>不能重写静态方法</mark>。虽然子类可以定义与父类中静态方法具有相同的名称、参数格式和类型和返回值的方法，但这并不是方法重写，而是方法隐藏。<br>静态方法是与类相关联的方法，它们不是对象的一部分。当子类定义了一个与父类中静态方法同名的静态方法时，子类的方法将隐藏父类中的方法，而不是重写它。在调用静态方法时，编译器会根据引用类型来确定使用哪个方法。</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent&#x27;s static method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child&#x27;s static method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Parent.staticMethod(); <span class="comment">// Output: Parent&#x27;s static method</span></span><br><span class="line">        Child.staticMethod();  <span class="comment">// Output: Child&#x27;s static method</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Parent</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">        parent.staticMethod(); <span class="comment">// Output: Parent&#x27;s static method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在上面的示例中，即使我们使用<code>Parent类型</code>的引用指向<code>Child对象</code>，调用的仍然是<code>Parent类中的静态方法</code>。<mark>这是因为静态方法的调用是通过编译时类型（在编译时确定的类型）来决定的，而不是运行时类型（实际对象的类型）</mark>。</p></blockquote><h4 id="7-继承的优劣"><a href="#7-继承的优劣" class="headerlink" title="7 继承的优劣"></a>7 继承的优劣</h4><ul><li><strong>好处:</strong><ul><li>提高了代码的复用性(多个类相同的成员可以放到同一个父类中)</li><li>提高了代码的维护性(如果方法的代码需要修改，修改父类的一处方法即可)</li></ul></li><li><strong>弊端:</strong><ul><li>继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性。</li></ul></li></ul><h4 id="8-java继承的注意事项"><a href="#8-java继承的注意事项" class="headerlink" title="8 java继承的注意事项"></a>8 java继承的注意事项</h4><ul><li>Java中类只支持单继承，不支持多继承（但是可以实现多个接口，单继承，多实现）<ul><li>错误范例：class A extends B, C { } <mark>[Java不允许存在多继承]</mark></li></ul></li><li>Java中所有类的根类都是<code>Object</code>类</li><li>Java中类支持多层继承</li><li>继承相关图解如下:</li></ul><details class="[orange]" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>[继承相关图解]</summary><div class="content"><p><strong>子类可以从父类继承:</strong><br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-05%20225901.png"><br><strong>方法的继承:</strong><br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-07%20235906.png"><br><strong>方法的重写:</strong><br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/Snipaste_2024-04-06_22-08-02.png"><br><strong>this &amp; super:</strong><br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-08%20174612.png"><br><strong>super内存图:</strong><br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-08%20172737.png"></p></div></details><h3 id="多态问题"><a href="#多态问题" class="headerlink" title="多态问题"></a>多态问题</h3><h4 id="1-多态的概念"><a href="#1-多态的概念" class="headerlink" title="1 多态的概念"></a>1 多态的概念</h4><ul><li><strong>同类型的对象,表现出的不同形态</strong></li><li>表现形式:<ul><li><code>父类类型 对象名称 = 子类对象</code></li><li>Fu f &#x3D; new Zi();</li></ul></li><li>多态的前提:<ul><li>有继承关系</li><li>由父类引用指向子类对象</li><li>有方法重写</li></ul></li><li>多态的好处:<br>使用父类型作为参数,可以接收所有子类对象,体现多态的拓展性与便利</li></ul><h4 id="2-多态调用成员的特点"><a href="#2-多态调用成员的特点" class="headerlink" title="2 多态调用成员的特点"></a>2 多态调用成员的特点</h4><ul><li>变量调用:<strong>编译看左边,运行也看左边</strong></li><li>方法调用:<strong>编译看左边,运行看右边</strong></li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Animal&quot;</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal&#x27;s static method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Dog&quot;</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog&#x27;s static method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line"></span><br><span class="line">        System.out.println(animal1.name); <span class="comment">// 编译时看左边，运行时也看左边，输出: &quot;Animal&quot;</span></span><br><span class="line">        animal1.makeSound(); <span class="comment">// 编译时看左边，运行时看右边，输出: &quot;Dog barks&quot;</span></span><br><span class="line">        animal1.staticMethod(); <span class="comment">// 编译时看左边，运行时也看左边，输出: &quot;Animal&#x27;s static method&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="3-多态的弊端"><a href="#3-多态的弊端" class="headerlink" title="3 多态的弊端:"></a>3 多态的弊端:</h4><ul><li><strong>不能调用子类的特有方法[因为在编译的时侯会先检查左边的父类中有没有这个方法,如果没有直接报错]</strong></li><li>解决方案:<br>将变量转换为子类类型<br>Dog d &#x3D; (Dog) a; [只能强转为new出来的那个类型,强转类型与真实对象类型不一致会报错]</li></ul><h4 id="4-强转类型"><a href="#4-强转类型" class="headerlink" title="4 强转类型"></a>4 强转类型</h4><ul><li><code>instanceof</code>:用于在运行时确定一个对象是否是某个类的实例或者其子类的实例。它的语法形式为：</li><li>用法:<code>object instanceof ClassName</code><br><code>instanceof</code>运算符返回一个布尔值，如果 object 是 ClassName 类型的实例或者其子类的实例，则返回 true，否则返回 false。[可搭配if语句使用]</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Animal&quot;</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Dog&quot;</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fetch</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog fetches a stick&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (animal1 <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal1;</span><br><span class="line">            dog.fetch(); <span class="comment">// 如果 animal1 是 Dog 类型的实例，则调用 fetch() 方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>在jdk14以后有以下新特性</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (animal1 <span class="keyword">instanceof</span> Dog) &#123;              <span class="keyword">if</span> (animal1 <span class="keyword">instanceof</span> Dog d) </span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal1;       &lt;=&gt;     <span class="comment">//先判断a是否为Dog类型，如果是，则强转成Dog类型，转换之后变量名为d</span></span><br><span class="line">                                           <span class="comment">//如果不是，则不强转，结果直接是false</span></span><br><span class="line">&#125;                                          </span><br></pre></td></tr></table></figure></div></blockquote><h3 id="包与导包"><a href="#包与导包" class="headerlink" title="包与导包"></a>包与导包</h3><h4 id="1-包"><a href="#1-包" class="headerlink" title="1 包"></a>1 包</h4><h5 id="1-1-包的概念"><a href="#1-1-包的概念" class="headerlink" title="1.1 包的概念"></a>1.1 包的概念</h5><p>包就是文件夹。用来管理各种不同功能的Java类,方便后期维护。</p><h5 id="1-2-包的定义格式"><a href="#1-2-包的定义格式" class="headerlink" title="1.2 包的定义格式"></a>1.2 包的定义格式</h5><ul><li>包名的规则: <code>公司域名反写+包的作用</code>,需要全部英文小写,见名知意。<ul><li>eg：ink.lusy.blog</li></ul></li></ul><h5 id="1-3-带包编译-带包运行"><a href="#1-3-带包编译-带包运行" class="headerlink" title="1.3 带包编译&amp;带包运行"></a>1.3 带包编译&amp;带包运行</h5><ul><li>带包编译：javac -d . 全类名.java<ul><li>eg：java -d . ink.lusy.blog.HelloWorld.java</li></ul></li><li>带包运行：java 全类名<ul><li>eg：java ink.lusy.blog.HelloWorld</li></ul></li><li>全类名：包名+类名</li></ul><h4 id="2-导包"><a href="#2-导包" class="headerlink" title="2 导包"></a>2 导包</h4><h5 id="2-1-导包的意义"><a href="#2-1-导包的意义" class="headerlink" title="2.1 导包的意义"></a>2.1 导包的意义</h5><ul><li>使用不同包下的类时，使用的时候要写类的全路径，写起来太麻烦了</li><li>为了简化带包的操作，Java就提供了导包的功能<blockquote><p><strong>注意</strong>：如果同时使用两个包中的同名类，需要用全类名。[导包将不再适用]</p></blockquote></li></ul><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p><code>final</code>：表示最终的、不可改变的</p><h4 id="1-修饰类"><a href="#1-修饰类" class="headerlink" title="1 修饰类"></a>1 修饰类</h4><p><strong>作用</strong>：不能再被其他类继承</p><ul><li>表明该类为最终类，不能再被其他类继承</li><li>该类中的所有方法都是最终方法(隐式地被<code>final</code>修饰)</li></ul><p><strong>应用场景</strong>：</p><ul><li><strong>工具类（Utility Classes）</strong>: 如果某个类仅提供一组静态方法或者常量，并且不需要被继承修改，可以将其定义为final，例如Java中的java.lang.Math类就是一个典型的工具类。</li><li><strong>不可变类（Immutable Classes）</strong>: 不可变类是指其实例一旦创建就不能被修改的类，一般来说，不可变类应该是final的，以确保它们的状态不会被修改。</li><li><strong>涉及安全敏感信息的类</strong>: 如果某个类涉及到处理安全敏感信息，例如密码、密钥等，为了确保安全性，应该将其定义为final，避免被子类继承修改。</li><li><strong>单例模式类（Singleton Classes）</strong>: 单例模式中的类通常需要保证只有一个实例存在，并且提供全局访问点，为了确保单例的正确性，可以将单例类定义为final，防止被继承修改。</li><li><strong>为了提高性能的类</strong>: 在一些性能敏感的场景下，为了确保类的行为不被修改并且获得更好的性能，可以将其定义为final，使得编译器可以进行更多的优化。</li><li><strong>经常需要修改的类（迭代更新会经常改动的类）</strong>：final类可以避免继承链的耦合性，减少了父类变更导致子类需要同步修改的风险，符合”低耦合，高内聚”的设计原则。</li></ul><h4 id="2-修饰方法"><a href="#2-修饰方法" class="headerlink" title="2 修饰方法"></a>2 修饰方法</h4><p><strong>作用</strong>：子类不能重写(覆盖)该方法<br><strong>应用场景</strong>：对继承没有太大意义的方法，或者父类自身特有的方法，这些方法不需要给子类使用，从而定义为最终方法，在类继承时，可以降低耦合度</p><h4 id="3-修饰变量"><a href="#3-修饰变量" class="headerlink" title="3 修饰变量"></a>3 修饰变量</h4><ul><li>被<code>final</code>修饰的变量统称常量。</li><li><strong>常量的命名规范</strong>:<ul><li><p>单个单词:全部大写</p></li><li><p>多个单词:全部大写，单词之间用下划线隔开</p><blockquote><p>实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性，</p></blockquote></li></ul></li></ul><h5 id="3-1-修饰局部变量"><a href="#3-1-修饰局部变量" class="headerlink" title="3.1 修饰局部变量"></a>3.1 修饰局部变量</h5><p><strong>作用</strong>：<code>final</code>修饰的变量只能被赋值一次，是不可改变的<br><strong>优点</strong>：不需要重复的创建对象。</p><blockquote><p><strong>注意</strong>：<br>这里说的final修饰的变量不可改变分为两种：</p><ul><li>对于基本数据类型：指的是数值不可改变</li><li>对于引用数据类型：指的是变量存储的地址不可改变，对象内部的数据可以改变<br>[变量存的值不可改变，对于基本数据类型而言，变量存的是数值，对于引用数据类型而言，变量存的是地址]</li></ul></blockquote><h5 id="3-2-修饰全局变量-属性"><a href="#3-2-修饰全局变量-属性" class="headerlink" title="3.2 修饰全局变量(属性)"></a>3.2 修饰全局变量(属性)</h5><p>作用与上述局部变量一致，但需要注意以下3点</p><ul><li>final修饰全局变量，必须手动赋初始值</li><li>对于final修饰的全局变量，要么直接赋值，要么通过构造方法赋值</li><li>对于未直接赋值的final类型的全局变量，所有的构造方法都必须对该变量进行赋值</li></ul><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-09%20105030.png"></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>在Java中，代码块是一段用花括号 <code>&#123;&#125;</code> 括起来的代码，它可以在不同的位置出现，并且有不同的类型，包括局部代码块、构造代码块和静态代码块。</p><h4 id="1-局部代码块（Local-Blocks）："><a href="#1-局部代码块（Local-Blocks）：" class="headerlink" title="1 局部代码块（Local Blocks）："></a>1 局部代码块（Local Blocks）：</h4><ul><li>局部代码块是定义在方法体内的代码块，通常用于限定变量的作用范围。</li><li>局部代码块中声明的变量的作用范围仅限于该代码块内部。</li><li>局部代码块在执行完毕后，其中声明的变量会被销毁，不再占用内存空间。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exampleMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 开始局部代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;x inside local block: &quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结束局部代码块</span></span><br><span class="line">    <span class="comment">// 这里无法访问局部代码块中的变量 x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="2-构造代码块（Initializer-Blocks）："><a href="#2-构造代码块（Initializer-Blocks）：" class="headerlink" title="2 构造代码块（Initializer Blocks）："></a>2 构造代码块（Initializer Blocks）：</h4><ul><li>构造代码块是定义在类中，没有任何修饰符（如static、public等）的代码块，它在每次创建对象时都会被执行。</li><li>构造代码块主要用于初始化对象的共同属性，在每个构造函数之前执行。</li><li>构造代码块不能被显式调用，它会在对象创建时自动执行。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleClass</span> &#123;</span><br><span class="line">    <span class="comment">// 构造代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor block executed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleClass</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor executed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExampleClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExampleClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="3-静态代码块（Static-Blocks）："><a href="#3-静态代码块（Static-Blocks）：" class="headerlink" title="3 静态代码块（Static Blocks）："></a>3 静态代码块（Static Blocks）：</h4><ul><li>静态代码块是定义在类中，使用 static 关键字修饰的代码块，它在类加载时执行，且只执行一次。</li><li>静态代码块主要用于进行类的初始化操作，如加载驱动程序、初始化静态变量等。</li><li>静态代码块在程序启动时自动执行，无需显式调用。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleClass</span> &#123;</span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static block executed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行 main 方法时会触发类的加载，从而执行静态代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Inside main method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h3><h4 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1 基本概念"></a>1 基本概念</h4><ul><li>抽象方法：将<strong>共性的</strong>行为（方法）抽取到父类之后。由于每一个子类执行的内容是不一样，所以,在父类中不能确定<strong>具体的方法体</strong>，该方法就可以定义为抽象方法。<blockquote><p>抽象方法就是以abstract修饰的方法，这种方法<mark>只声明返回的数据类型、方法名称和所需的参数</mark>，没有方法体，也就是说抽象方法只需要声明而不需要实现</p></blockquote></li><li>抽象类:如果一个类中存在抽象方法,那么该类就必须声明为抽象类</li></ul><h4 id="2-定义格式"><a href="#2-定义格式" class="headerlink" title="2 定义格式"></a>2 定义格式</h4><ul><li>抽象方法：<code>public abstract 返回值类型 方法名(参数列表);</code>[分号;不能忘记]</li><li>抽象类：<code>public abstract class 类名 &#123;&#125;</code></li></ul><h4 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3 注意事项"></a>3 注意事项</h4><ul><li><strong>抽象类不能实例化</strong></li><li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类<br>[未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。比较少用]</li><li>抽象类可以有构造方法[给子类继承]</li><li>抽象类的子类<ul><li>要么重写抽象类中的所有抽象方法</li><li>要么是抽象类</li></ul></li></ul><h4 id="4-意义"><a href="#4-意义" class="headerlink" title="4 意义"></a>4 意义</h4><ul><li>抽取共性时，无法确定方法体，就可以把方法定义为抽象的。</li><li>强制让子类按照某种格式进行重写。[提高代码可读性]</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="1-基本概念-2"><a href="#1-基本概念-2" class="headerlink" title="1 基本概念"></a>1 基本概念</h4><p>简单的说，接口就是一种被规范的标准，它定义了一组行为或功能，任何符合这个标准的类都可以被看作是这个接口的实现。<strong>接口的表现在于对行为的抽象</strong>。<br>[类是对属性的抽象，接口是对行为的抽象]</p><h4 id="2-定义和使用"><a href="#2-定义和使用" class="headerlink" title="2 定义和使用"></a>2 定义和使用</h4><ul><li>接口用关键字<code>interface</code>来定义：<ul><li><strong>pubilc interface 接口名 {}</strong></li><li><strong>interface 接口名 {}</strong></li><li>两种定义方式的区别：接口的访问权限不一样</li></ul></li><li><strong>接口不能实例化</strong></li><li>接口和类之间是<strong>实现关系</strong>,通过<code>implements</code>关键字表示<ul><li><strong>public class 类名 implements 接口名1 接口名2 …… {}</strong></li></ul></li><li>接口的子类(实现类)<ul><li>要么重写接口中的所有抽象方法</li><li>要么是抽象类</li></ul></li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="comment">// 接口中的常量</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159</span>;<span class="comment">//前面有默认修饰符：public static final [在编译环节会隐式添加]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口中的抽象方法</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span>;<span class="comment">//前面有默认修饰符：public abstract [在编译环节会隐式添加]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现接口中的抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用接口中的常量 -&gt; 静态变量可以直接用类名调用[推荐]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;PI 常量的值: &quot;</span> + Shape.PI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 Circle 对象</span></span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5.0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用实现接口的方法</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> circle.calculateArea();</span><br><span class="line">        System.out.println(<span class="string">&quot;圆的面积: &quot;</span> + area);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="3-成员特点"><a href="#3-成员特点" class="headerlink" title="3 成员特点"></a>3 成员特点</h4><ul><li>成员变量<ul><li>只能是常量</li><li>默认修饰符：<strong><code>public</code> static final</strong></li></ul></li><li>构造方法<ul><li>没有</li></ul></li><li>成员方法<ul><li>只能是抽象方法[JDK7以前]</li><li>默认修饰符：<strong>public abstract</strong></li><li><code>JDK8的新特性</code>: 接口中可以定义有方法体的方法（默认、静态）</li><li><code>JDK9的新特性</code>: 接口中可以定义私有方法</li></ul></li></ul><h4 id="4-接口和类之间的关系"><a href="#4-接口和类之间的关系" class="headerlink" title="4 接口和类之间的关系"></a>4 接口和类之间的关系</h4><ul><li>类和类的关系<br>继承关系,只能单继承,不能多继承,但是可以多层继承</li><li>类和接口的关系<br>实现关系,可以单实现,也可以多实现,还可以在继承一个类的同时实现多个接口</li><li>接口和接口的关系<br>继承关系,可以单继承,也可以多继承<br><strong>public interface a <code>extends</code> b,c,d…..{}</strong></li></ul><blockquote><p><strong>接口多继承的好处</strong>：<br>定义了许多接口，如果一个设备要同时实现那么多接口将是不小的开销，对于同能同类的可以把他用一个接口继承起来，这样这个接口就要了那些接口的全部功能，我们使用类只要实现一个就可以了。</p></blockquote><h4 id="5-JDK8以后接口中新增的方法"><a href="#5-JDK8以后接口中新增的方法" class="headerlink" title="5 JDK8以后接口中新增的方法"></a>5 JDK8以后接口中新增的方法</h4><h5 id="5-1-默认方法"><a href="#5-1-默认方法" class="headerlink" title="5.1 默认方法"></a>5.1 默认方法</h5><ul><li>允许在接口中定义<strong>默认方法</strong>，需要使用关键字<code>default</code>修饰<ul><li>作用：解决接口升级的问题[允许在接口中添加新的方法而不会破坏现有的实现类。]</li></ul></li><li>默认方法的定义格式<ul><li><strong>public <code>default</code> 返回值类型 方法名(参数列表) { }</strong></li><li>eg：public <code>default</code> void show() { }</li></ul></li><li>调用方法<ul><li>实现类直接调用接口默认方法即可。[类名.默认方法名(参数列表)]</li></ul></li><li>默认方法的注意事项<ul><li>默认方法不是抽象方法，所以<strong>不强制被重写</strong>。但是如果被重写，重写的时候要去掉<code>default</code>关键字</li><li>public可以省略，default不能省略</li><li>如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写</li></ul></li></ul><h5 id="5-2-静态方法"><a href="#5-2-静态方法" class="headerlink" title="5.2 静态方法"></a>5.2 静态方法</h5><ul><li>允许在接口中定义<strong>静态方法</strong>，需要使用关键字<code>static</code>修饰<ul><li>调用时无需实例化接口的实现类[通常用于实现工具类或提供通用功能的方法]</li></ul></li><li>静态方法的定义格式<ul><li><strong>public <code>static</code> 返回值类型 方法名(参数列表) { }</strong></li><li>eg：public <code>static</code> void show() { }</li></ul></li><li>调用方法<ul><li>只能通过接口名调用</li></ul></li><li>静态方法的注意事项<ul><li>静态方法只能通过接口名调用，不能通过实现类名或者对象名调用</li><li>public可以省略，static不能省略</li></ul></li></ul><blockquote><p><strong>默认方法和静态方法功能上的区别</strong></p><p><strong>默认方法（Default Methods）</strong>：</p><ul><li>默认方法是接口中带有默认实现的方法，它们允许在接口中添加新的方法而不会破坏现有的实现类。</li><li>默认方法可以被实现类选择性地覆盖，以满足特定需求。</li><li>默认方法主要用于接口的演进，允许向现有接口添加新的功能而不会影响已有的实现类。</li></ul><p><strong>静态方法（Static Methods）</strong>：</p><ul><li>静态方法是在接口中带有 <code>static</code> 关键字修饰的方法，它们不是接口的实例方法，而是与接口直接关联的方法。</li><li>静态方法可以直接通过接口名称调用，无需实例化接口的实现类。</li><li>静态方法通常用于实现工具类或提供通用功能的方法。</li></ul></blockquote><h4 id="6-JDK9以后接口中新增的方法"><a href="#6-JDK9以后接口中新增的方法" class="headerlink" title="6 JDK9以后接口中新增的方法"></a>6 JDK9以后接口中新增的方法</h4><p><strong>接口中可以定义私有方法</strong></p><ul><li>权限范围：<strong>私有方法的访问权限仅限于接口内部</strong></li><li>作用：避免了代码的重复编写、隐藏接口的实现细节</li><li>私有方法的注意事项：<strong>私有方法无法被实现类覆盖或继承</strong>，它们只能在接口内部使用。</li></ul><h5 id="6-1-普通的私有方法-对标JDK8中的默认方法"><a href="#6-1-普通的私有方法-对标JDK8中的默认方法" class="headerlink" title="6.1 普通的私有方法[对标JDK8中的默认方法]"></a>6.1 普通的私有方法[对标JDK8中的默认方法]</h5><ul><li>格式：<strong>private 返回值类型 方法名(参数列表) { }</strong></li><li>eg：private void show() { }</li></ul><h5 id="6-2-静态的私有方法-对标JDK8中的静态方法"><a href="#6-2-静态的私有方法-对标JDK8中的静态方法" class="headerlink" title="6.2 静态的私有方法[对标JDK8中的静态方法]"></a>6.2 静态的私有方法[对标JDK8中的静态方法]</h5><ul><li>格式：<strong>private <code>static</code> 返回值类型 方法名(参数列表) { }</strong></li><li>eg：private <code>static</code> void show() { }</li></ul><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p><strong>类的五大成员</strong>：<br>属性、方法、构造方法、代码块、内部类</p><p><strong>内部类的基本概念</strong>：<br>在一个类的里面，再定义一个类。[在A类的内部定义B类，B类就被称为内部类]</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//这里的Outer是外部类，Inner是内部类</span></span><br></pre></td></tr></table></figure></div><p><strong>内部类的作用</strong>：<br>内部类表示的事物是外部类的一部分，且内部类单独存在又没有任何意义<br>比如：汽车的发动机，ArrayList的迭代器。人的心脏</p><p><strong>内部类的访问特点</strong>：</p><ul><li>内部类可以直接访问外部类的成员，包括私有</li><li>外部类要访问内部类的成员，必须要创建对象[静态内部类中的静态成员不需要创建对象]</li></ul><h4 id="1-成员内部类"><a href="#1-成员内部类" class="headerlink" title="1 成员内部类"></a>1 成员内部类</h4><ul><li>写在成员位置的，属于外部类的成员。</li><li>成员内部类可以被一些修饰符所修饰。[private、默认、protectd、public、static]</li><li>在成员内部类里面，JDK16之前不能定义静态变量，JDK16开始才可以定义静态变量</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    <span class="type">int</span> carColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span>&#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engageAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="1-1-获取成员内部类对象"><a href="#1-1-获取成员内部类对象" class="headerlink" title="1.1 获取成员内部类对象"></a>1.1 获取成员内部类对象</h5><ul><li>直接创建格式：<code>外部类名.内部类名 对象名 = new 外部类名().new 内部类名();</code></li><li>在外部类中编写方法，对外提供内部类的对象。[适用于内部类被private等修饰时使用]</li></ul><h5 id="1-2-外部类成员变量和内部类成员变量重名时，在内部类如何访问"><a href="#1-2-外部类成员变量和内部类成员变量重名时，在内部类如何访问" class="headerlink" title="1.2 外部类成员变量和内部类成员变量重名时，在内部类如何访问"></a>1.2 外部类成员变量和内部类成员变量重名时，在内部类如何访问</h5><ul><li><code>外部类名.this.变量名</code><br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240414120751.png"></li></ul><h4 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2 静态内部类"></a>2 静态内部类</h4><ul><li>静态内部类只能访问外部类中的静态变量和静态方法，要访问外部类的非静态成员，则需要通过创建外部类的实例来进行访问。</li><li>静态内部类是一种特殊的成员内部类。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    <span class="type">int</span> carColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Engine</span>&#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engageAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="2-1-创建静态内部类对象的格式"><a href="#2-1-创建静态内部类对象的格式" class="headerlink" title="2.1 创建静态内部类对象的格式"></a>2.1 创建静态内部类对象的格式</h5><ul><li><code>外部类名.内部类名 对象名 = new 外部类名.内部类名();</code></li></ul><h5 id="2-2-成员调用"><a href="#2-2-成员调用" class="headerlink" title="2.2 成员调用"></a>2.2 成员调用</h5><ul><li>调用非静态成员的格式：先创建对象，用对象调用</li><li>调用静态成员的格式：<code>外部类名.内部类名.方法名()\变量名;</code></li></ul><h4 id="3-局部内部类"><a href="#3-局部内部类" class="headerlink" title="3 局部内部类"></a>3 局部内部类</h4><ul><li>将内部类定义在方法里面就叫做局部内部类，类似于方法里面的局部变量</li><li>外界是无法直接使用，需要在方法内部创建对象并使用，</li><li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</li></ul><h4 id="4-匿名内部类"><a href="#4-匿名内部类" class="headerlink" title="4 匿名内部类"></a>4 匿名内部类</h4><ul><li>隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置[更常见]</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名内部类的格式</span></span><br><span class="line"><span class="keyword">new</span> 类名\接口名() &#123;</span><br><span class="line">    重写方法;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//最后的分号;，切记不能漏掉</span></span><br></pre></td></tr></table></figure></div><h5 id="4-1-格式细节"><a href="#4-1-格式细节" class="headerlink" title="4.1 格式细节"></a>4.1 格式细节</h5><ul><li>包含了继承或实现，方法重写，创建对象。</li><li>整体就是一个类的子类对象或者接口的实现类对象</li></ul><h5 id="4-2-应用场景"><a href="#4-2-应用场景" class="headerlink" title="4.2 应用场景"></a>4.2 应用场景</h5><p>当方法的参数是接口或者类时，<br>以接口为例，可以传递这个接口的实现类对象<br><strong>如果实现类只要用一次，就可以用匿名内部类简化代码。</strong></p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个匿名内部类实例</span></span><br><span class="line">        <span class="type">EventListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(String event)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Event received: &quot;</span> + event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用该实例</span></span><br><span class="line">        fireEvent(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fireEvent</span><span class="params">(EventListener listener)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟事件触发</span></span><br><span class="line">        listener.onEvent(<span class="string">&quot;Button clicked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义事件监听接口</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(String event)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>Title:</strong> Java基础</li><li><strong>Author:</strong> Lu</li><li><strong>Created at :</strong> 2024-03-15 09:25:09</li><li><strong>Updated at :</strong> 2025-03-11 12:44:58</li><li><strong>Link:</strong> https://lusy.ink/2024/03/15/java基础学习/</li><li><strong>License: </strong>This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">#学习总结</a>&nbsp;</li><li class="tag-item mx-0.5"><a href="/tags/Java/">#Java</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/2024/03/16/Linux/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item">Linux学习笔记</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/2024/03/06/hello-world/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">Hello World</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div><div class="comment-container px-2 sm:px-6 md:px-8 pb-8"><div class="comments-container mt-10 w-full"><div id="comment-anchor" class="w-full h-2.5"></div><div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">Comments</div><div id="waline"></div><script type="module" data-swup-reload-script>import{init}from"/js/libs/waline.mjs";function loadWaline(){init({el:"#waline",serverURL:"https://comment.lusy.ink",lang:"zh-CN",dark:'body[class~="dark-mode"]',reaction:!1,requiredMeta:["nick","mail"],emoji:[]})}"undefined"!=typeof swup?loadWaline():window.addEventListener("DOMContentLoaded",loadWaline)</script></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">On this page</div><div class="page-title">Java基础</div><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%80%BC"><span class="nav-text">不同类型数组的初始化值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">基本数据类型和引用数据类型的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#idea%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="nav-text">idea的常用快捷键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-text">方法区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E6%B1%A0"><span class="nav-text">串池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1 基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">2 字符串的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%98%E5%82%A8%E7%9A%84%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86"><span class="nav-text">3 字符串存储的内存原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="nav-text">4 字符串操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">5 String、StringBuffer、StringBuilder的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#String"><span class="nav-text">String</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#StringBuffer"><span class="nav-text">StringBuffer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#StringBuilder"><span class="nav-text">StringBuilder</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9B%BE%E8%A7%A3"><span class="nav-text">字符串图解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-text">static 静态变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-static%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%BB%E8%A6%81%E6%9C%89%E4%B8%A4%E7%A7%8D%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="nav-text">1 static关键字主要有两种作用：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-text">2.1 成员变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-text">2.2 成员方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-static%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-text">2.3 static代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-static%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">2.4 static内部类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="nav-text">继承问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">1 继承的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0%E6%A0%BC%E5%BC%8F"><span class="nav-text">2 实现格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AD%90%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">3 子类的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">4 继承中成员变量访问的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-this-super"><span class="nav-text">5 this &amp; super</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="nav-text">6 方法的重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E5%8A%A3"><span class="nav-text">7 继承的优劣</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-java%E7%BB%A7%E6%89%BF%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">8 java继承的注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E9%97%AE%E9%A2%98"><span class="nav-text">多态问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">1 多态的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%A4%9A%E6%80%81%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">2 多态调用成员的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%A4%9A%E6%80%81%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="nav-text">3 多态的弊端:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%BC%BA%E8%BD%AC%E7%B1%BB%E5%9E%8B"><span class="nav-text">4 强转类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E4%B8%8E%E5%AF%BC%E5%8C%85"><span class="nav-text">包与导包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8C%85"><span class="nav-text">1 包</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">1.1 包的概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-%E5%8C%85%E7%9A%84%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F"><span class="nav-text">1.2 包的定义格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-%E5%B8%A6%E5%8C%85%E7%BC%96%E8%AF%91-%E5%B8%A6%E5%8C%85%E8%BF%90%E8%A1%8C"><span class="nav-text">1.3 带包编译&amp;带包运行</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AF%BC%E5%8C%85"><span class="nav-text">2 导包</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-%E5%AF%BC%E5%8C%85%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-text">2.1 导包的意义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final"><span class="nav-text">final</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="nav-text">1 修饰类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="nav-text">2 修饰方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="nav-text">3 修饰变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-text">3.1 修饰局部变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-%E4%BF%AE%E9%A5%B0%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E5%B1%9E%E6%80%A7"><span class="nav-text">3.2 修饰全局变量(属性)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-text">权限修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-text">代码块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%B1%80%E9%83%A8%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%88Local-Blocks%EF%BC%89%EF%BC%9A"><span class="nav-text">1 局部代码块（Local Blocks）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%88Initializer-Blocks%EF%BC%89%EF%BC%9A"><span class="nav-text">2 构造代码块（Initializer Blocks）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%88Static-Blocks%EF%BC%89%EF%BC%9A"><span class="nav-text">3 静态代码块（Static Blocks）：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-text">抽象类和抽象方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="nav-text">1 基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F"><span class="nav-text">2 定义格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">3 注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%84%8F%E4%B9%89"><span class="nav-text">4 意义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="nav-text">1 基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-text">2 定义和使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%88%90%E5%91%98%E7%89%B9%E7%82%B9"><span class="nav-text">3 成员特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">4 接口和类之间的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-JDK8%E4%BB%A5%E5%90%8E%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">5 JDK8以后接口中新增的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="nav-text">5.1 默认方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-text">5.2 静态方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-JDK9%E4%BB%A5%E5%90%8E%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">6 JDK9以后接口中新增的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-%E6%99%AE%E9%80%9A%E7%9A%84%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95-%E5%AF%B9%E6%A0%87JDK8%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="nav-text">6.1 普通的私有方法[对标JDK8中的默认方法]</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-%E9%9D%99%E6%80%81%E7%9A%84%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95-%E5%AF%B9%E6%A0%87JDK8%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-text">6.2 静态的私有方法[对标JDK8中的静态方法]</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">1 成员内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="nav-text">1.1 获取成员内部类对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-%E5%A4%96%E9%83%A8%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E9%87%8D%E5%90%8D%E6%97%B6%EF%BC%8C%E5%9C%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE"><span class="nav-text">1.2 外部类成员变量和内部类成员变量重名时，在内部类如何访问</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">2 静态内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-text">2.1 创建静态内部类对象的格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-%E6%88%90%E5%91%98%E8%B0%83%E7%94%A8"><span class="nav-text">2.2 成员调用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">3 局部内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">4 匿名内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-%E6%A0%BC%E5%BC%8F%E7%BB%86%E8%8A%82"><span class="nav-text">4.1 格式细节</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">4.2 应用场景</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2024</span> - 2025&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">Lu</a><p class="post-count space-x-0.5"><span>24 posts in total </span><span>172.4k words in total</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">VISITOR COUNT</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">TOTAL PAGE VIEWS</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span> <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span></div><div>Blog up for <span class="odometer" id="runtime_days"></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Swup.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupSlideTheme.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScriptsPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupProgressPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScrollPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/imageViewer.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/utils.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/main.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/navbarShrink.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/scrollTopBottom.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/lightDarkSwitch.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/categoryList.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/localSearch.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/codeBlock.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/lazyload.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/runtime.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/odometer.min.js"></script><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/assets/odometer-theme-minimal.css"><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Typed.min.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/typed.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/tabs.js" data-swup-reload-script></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/essays.js" data-swup-reload-script></script></body></html>