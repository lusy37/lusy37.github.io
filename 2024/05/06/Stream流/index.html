<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="referrer" content="no-referrer"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Hexo Theme Redefine"><meta name="author" content="Lu"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://registry.npmmirror.com" crossorigin><link rel="canonical" href="https://lusy37.github.io/2024/05/06/stream流/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:type" content="article"><meta property="og:title" content="Stream流"><meta property="og:url" content="https://lusy37.github.io/2024/05/06/Stream%E6%B5%81/index.html"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://lusy37.github.io/images/redefine-og.webp"><meta property="article:published_time" content="2024-05-06T13:22:21.000Z"><meta property="article:modified_time" content="2025-03-28T08:27:44.300Z"><meta property="article:author" content="Lu"><meta property="article:tag" content="学习总结"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://lusy37.github.io/images/redefine-og.webp"><link rel="icon" type="image/png" href="/images/redefine-favicon.jpg" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.jpg"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="/images/redefine-favicon.jpg"><title>Stream流 | Lusy</title><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Chillax/chillax.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/css/build/tailwind.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Geist/geist.css"><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/anime.min.js"></script><script id="hexo-configurations">window.config={hostname:"lusy37.github.io",root:"/",language:"en",path:"search.xml"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,delete_mask:!1,title_alignment:"left",headings_top_spacing:{h1:"3.2rem",h2:"2.4rem",h3:"1.9rem",h4:"1.6rem",h5:"1.4rem",h6:"1.3rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",highlight_theme:{light:"github",dark:"vs2015"},font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:6,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,pangu_js:!1,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#A31F34",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null},title:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!0},scroll_progress:{bar:!1,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:{enable:!0,custom_message:null},open_graph:{enable:!0,image:"/images/redefine-og.webp",description:"Hexo Theme Redefine, Redefine Your Hexo Journey."},google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/wallhaven-wqery6-light.webp",dark:"/images/wallhaven-wqery6-dark.webp"},title:"等一场花开",subtitle:{text:["迷失的人迷失了，相遇的人再相遇","迷い人はまた迷い、巡り逢うべき人とは再び巡り逢う"],hitokoto:{enable:!1,show_author:!1,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!1,style:"default",links:{github:null,instagram:null,zhihu:null,twitter:null,email:null},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{enable:!1,type:"fixed",audios:[{name:null,artist:null,url:null,cover:null,lrc:null}]},mermaid:{enable:!1,version:"11.4.1"}},version:"2.8.2",navbar:{auto_hide:!1,color:{left:"#f78736",right:"#367df7",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-regular fa-house"},Essays:{path:"/essays",icon:"fa-regular fa-pen-to-square"},Think:{path:"/think",icon:"fa-regular fa-paper-plane"}},search:{enable:!0,preload:!0}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:"If its rainy, you won't see me.If its sunny ,you'll think of me.",show_on_mobile:!0,links:{Archives:{path:"/archives",icon:"fa-regular fa-archive"},Tags:{path:"/tags",icon:"fa-regular fa-tags"},Categories:{path:"/categories",icon:"fa-regular fa-folder"}}},article_date_format:"YYYY-MM-DD",excerpt_length:200,categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2024/2/12 15:45:14"},window.lang_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},window.data={masonry:!1}</script><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/brands.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/solid.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/regular.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span></div><style>:root{--preloader-background-color:#fff;--preloader-text-color:#000}@media (prefers-color-scheme:dark){:root{--preloader-background-color:#202124;--preloader-text-color:#fff}}@media (prefers-color-scheme:light){:root{--preloader-background-color:#fff;--preloader-text-color:#000}}@media (max-width:600px){.ml13{font-size:2.6rem!important}}.preloader{display:flex;flex-direction:column;gap:1rem;align-items:center;justify-content:center;position:fixed;padding:12px;top:0;right:0;bottom:0;left:0;width:100vw;height:100vh;background-color:var(--preloader-background-color);z-index:1100;transition:opacity .2s ease-in-out}.ml13{font-size:3.2rem;color:var(--preloader-text-color);letter-spacing:-1px;font-weight:500;font-family:Chillax-Variable,sans-serif;text-align:center}.ml13 .word{display:inline-flex;flex-wrap:wrap;white-space:nowrap}.ml13 .letter{display:inline-block;line-height:1em}</style><div class="preloader"><h2 class="ml13">Lusy</h2><script>var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });

        var animation = anime.timeline({ loop: true })
            .add({
                targets: '.ml13 .letter',
                translateY: [20, 0],
                translateZ: 0,
                opacity: [0, 1],
                filter: ['blur(5px)', 'blur(0px)'],
                easing: "easeOutExpo",
                duration: 1200,
                delay: (el, i) => 300 + 20 * i,
            })
            .add({
                targets: '.ml13 .letter',
                translateY: [0, -20],
                opacity: [1, 0],
                filter: ['blur(0px)', 'blur(5px)'],
                easing: "easeInExpo",
                duration: 1000,
                delay: (el, i) => 15 * i,
                complete: function() {
                    hidePreloader();
                }
            }, '-=700');


        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            setTimeout(hidePreloader, 5000); // Call hidePreloader after 5000 milliseconds if not already called by animation
        });

        function hidePreloader() {
            var preloader = document.querySelector('.preloader');
            preloader.style.opacity = '0';
            setTimeout(function () {
                preloader.style.display = 'none';
            }, 200);
        }</script></div><main class="page-container" id="swup"><div class="main-content-container flex flex-col justify-between min-h-dvh"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content transition-navbar"><div class="left"><a class="logo-title" href="/">Lusy</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house fa-fw"></i> HOME</a></li><li class="navbar-item"><a href="/essays"><i class="fa-regular fa-pen-to-square fa-fw"></i> ESSAYS</a></li><li class="navbar-item"><a href="/think"><i class="fa-regular fa-paper-plane fa-fw"></i> THINK</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>HOME </span><i class="fa-regular fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/essays"><span>ESSAYS </span><i class="fa-regular fa-pen-to-square fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/think"><span>THINK </span><i class="fa-regular fa-paper-plane fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/archives"><span>Archives</span> <i class="fa-regular fa-archive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/tags"><span>Tags</span> <i class="fa-regular fa-tags fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/categories"><span>Categories</span> <i class="fa-regular fa-folder fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">10</div><div class="label text-third-text-color text-sm">Tags</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">5</div><div class="label text-third-text-color text-sm">Categories</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">25</div><div class="label text-third-text-color text-sm">Posts</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body transition-fade-up"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Stream流</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="/images/redefine-avatar.jpg"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">Lu</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv3</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2024-05-06 21:22:21</span> <span class="mobile">2024-05-06 21:22:21</span> <span class="hover-info">Created</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2025-03-28 16:27:44</span> <span class="mobile">2025-03-28 16:27:44</span> <span class="hover-info">Updated</span> </span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">学习总结</a>&nbsp;</li><li>| <a href="/tags/Java/">Java</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fa-regular fa-typewriter"></i>&nbsp;<span>12.2k Words</span> </span><span class="article-min2read article-meta-item"><i class="fa-regular fa-clock"></i>&nbsp;<span>52 Mins</span> </span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><h1 id="Java-Stream流"><a href="#Java-Stream流" class="headerlink" title="Java Stream流"></a>Java Stream流</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1.概念"></a>1.1.概念</h3><ul><li><strong>Stream不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的Iterator</strong>。原始版本的Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的Stream，用户只要给出需要对其包含的元素执行什么操作，比如，“过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream会隐式地在内部进行遍历，做出相应的数据转换。<strong>Stream就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了</strong>，就好比流水从面前流过，一去不复返。</li><li>而和迭代器又不同的是，<strong>Stream可以并行化操作</strong>，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个item读完后再读下一个item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream的并行操作依赖于Java7中引入的Fork&#x2F;Join框架（JSR166y）来拆分任务和加速处理过程。</li><li>Stream 的另外一大特点是，<strong>数据源本身可以是无限的</strong>。</li></ul><h3 id="1-2-Stream流的特性"><a href="#1-2-Stream流的特性" class="headerlink" title="1.2.Stream流的特性"></a>1.2.Stream流的特性</h3><ul><li>不存储数据[按照特定的规则对数据进行计算，一般会输出结果]</li><li>不会改变数据源[通常情况下会产生一个新的集合或一个值]</li><li>具有延迟执行特性[只有调用终端操作时，中间操作才会执行]</li></ul><h3 id="1-3-Stream流的作用"><a href="#1-3-Stream流的作用" class="headerlink" title="1.3.Stream流的作用"></a>1.3.Stream流的作用</h3><p>结合Lambda表达式，简化集合、数组操作，提高代码的效率。</p><h3 id="1-4-Stream流的使用步骤"><a href="#1-4-Stream流的使用步骤" class="headerlink" title="1.4.Stream流的使用步骤"></a>1.4.Stream流的使用步骤</h3><ul><li>获取数据源，将数据源中的数据读取到流中<br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240507103133.png"></li><li>对流中的数据进行各种各样的处理[筛选、过滤……] <strong>中间操作</strong>-&gt;方法调用完毕后会返回另一个流，还可以继续调用其他方法[建议使用链式编程]</li><li>对流中的数据进行整合处理[遍历、统计……] <strong>终端操作</strong>-&gt;方法调用完毕后，流就关闭了，不能再调用其他方法</li></ul><h2 id="2-Stream的生成"><a href="#2-Stream的生成" class="headerlink" title="2.Stream的生成"></a>2.Stream的生成</h2><h3 id="2-1-Collection-stream-、Collection-parallelStream"><a href="#2-1-Collection-stream-、Collection-parallelStream" class="headerlink" title="2.1.Collection.stream()、Collection.parallelStream()"></a>2.1.Collection.stream()、Collection.parallelStream()</h3><ul><li>通过Collection接口中的<strong>stream</strong>()方法获取数据源为<strong>集合</strong>的流对象【同步流】：<code>Stream&lt;T&gt; stream() = list.stream();</code></li><li>通过Collection接口中的<strong>parallelStream</strong>()方法获取数据源为<strong>集合</strong>的流对象【并发、异步流】：<code>Stream&lt;T&gt; parallelStream() = list.parallelStream();</code></li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建一个顺序流</span></span><br><span class="line">    Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">    System.out.println(<span class="string">&quot;创建一个顺序流&quot;</span>);</span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">    <span class="comment">// 创建一个并行流</span></span><br><span class="line">    Stream&lt;String&gt; parallelStream = list.parallelStream();</span><br><span class="line">    System.out.println(<span class="string">&quot;创建一个并行流&quot;</span>);</span><br><span class="line">    parallelStream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  输出：创建一个顺序流</span></span><br><span class="line"><span class="comment">        a</span></span><br><span class="line"><span class="comment">        b</span></span><br><span class="line"><span class="comment">        c</span></span><br><span class="line"><span class="comment">        创建一个并行流</span></span><br><span class="line"><span class="comment">        b</span></span><br><span class="line"><span class="comment">        c</span></span><br><span class="line"><span class="comment">        a</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure></div><blockquote><p><strong>「stream和parallelStream的简单区分」</strong>: stream是顺序流，由主线程按顺序对流执行操作，而parallelStream是并行流，内部以多线程并行执行的方式对流进行操作，但前提是流中的数据处理没有顺序要求。例如筛选集合中的奇数，两者的处理不同之处：<br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240507102247.png"></p></blockquote><h3 id="2-2-Arrays-stream"><a href="#2-2-Arrays-stream" class="headerlink" title="2.2.Arrays.stream()"></a>2.2.Arrays.stream()</h3><ul><li>通过Arrays工具类中的<strong>stream</strong>(T[] array)方法获取数据源为<strong>数组</strong>的流对象：<code>IntStream stream = Arrays.stream(array);</code>[除了IntStream，还有LongStream、DoubleStream……]</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(array);</span><br></pre></td></tr></table></figure></div><h3 id="2-3-Stream的静态方法"><a href="#2-3-Stream的静态方法" class="headerlink" title="2.3.Stream的静态方法"></a>2.3.Stream的静态方法</h3><ul><li>通过Stream工具类中的<strong>of</strong>(T… values)方法获取数据源为<strong>一堆零散数据</strong>的流对象：<code>Stream&lt;T&gt; stream = Stream.of(array);</code></li><li>通过Stream工具类中的<strong>iterate</strong>(T seed, UnaryOperator f)方法获取数据源为<strong>无限</strong>的流对象，其中第一个参数是种子值，第二个参数是一个函数，用于生成后续的元素：<code>Stream&lt;T&gt; stream = Stream.iterate(0, n -&gt; n + 2);</code></li><li>通过Stream工具类中的<strong>generate</strong>(Supplier s)方法获取数据源为<strong>无限</strong>的流对象，其中参数是一个供应商函数，用于生成元素：<code>Stream&lt;T&gt; stream = Stream.generate(Math::random);</code></li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">stream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">3</span>).limit(<span class="number">4</span>); <span class="comment">//limit(4)表示只取前4个元素</span></span><br><span class="line">stream2.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(<span class="number">3</span>); <span class="comment">//limit(3)表示只取前3个元素</span></span><br><span class="line">stream3.forEach(System.out::println);</span><br><span class="line"><span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">  使用Stream.of()：</span></span><br><span class="line"><span class="comment">  1</span></span><br><span class="line"><span class="comment">  2</span></span><br><span class="line"><span class="comment">  3</span></span><br><span class="line"><span class="comment">  4</span></span><br><span class="line"><span class="comment">  使用Stream.iterate()：</span></span><br><span class="line"><span class="comment">  0</span></span><br><span class="line"><span class="comment">  3</span></span><br><span class="line"><span class="comment">  6</span></span><br><span class="line"><span class="comment">  9</span></span><br><span class="line"><span class="comment">  使用Stream.generate()：</span></span><br><span class="line"><span class="comment">  0.34339747950763355</span></span><br><span class="line"><span class="comment">  0.8263192360076247</span></span><br><span class="line"><span class="comment">  0.6455630248922111 */</span></span><br></pre></td></tr></table></figure></div><h3 id="2-4-文件创建"><a href="#2-4-文件创建" class="headerlink" title="2.4.文件创建"></a>2.4.文件创建</h3><ul><li>BufferedReader.lines()方法获取数据源为<strong>文件</strong>的流对象：<code>Stream&lt;String&gt; stream = new BufferedReader(new FileReader(filePath)).lines();</code></li><li>通过Files工具类中的<strong>lines</strong>(Path path, Charset cs)方法获取数据源为<strong>文件</strong>的流对象：<code>Stream&lt;String&gt; stream = Files.lines(Paths.get(filePath), Charset.forName(charsetName));</code>【安全性更强，推荐使用】</li></ul><blockquote><p>BufferedReader.lines() 和 Files.lines() 都是用于<strong>从文件中逐行读取数据</strong>的方法，但它们的用法和实现细节略有不同。前者需要手动创建 BufferedReader 对象，并在使用完后<strong>手动关闭流</strong>，而后者更为简洁，因为这个方法是Files工具类的一个静态方法，所以不需要手动创建对象，<strong>不需要手动关闭流</strong></p></blockquote><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">// 使用BufferedReader.lines()创建数据源为文件的流</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>))) &#123;</span><br><span class="line">            Stream&lt;String&gt; stream = br.lines();</span><br><span class="line">            stream.forEach(System.out::println);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Files.lines()创建数据源为文件的流</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line">            <span class="comment">// 等价于：Stream&lt;String&gt; lines = Files.lines(Path.of(&quot;input.txt&quot;));</span></span><br><span class="line">            lines.forEach(System.out::println);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h3 id="2-5-其他"><a href="#2-5-其他" class="headerlink" title="2.5.其他"></a>2.5.其他</h3><ul><li><strong>Pattrn.splitAsStream(CharSequence input)</strong>：是Pattern类中的一个方法，用于将字符串根据指定的正则表达式分割为流对象，其中参数为字符串，返回值为流对象。</li><li><strong>JarFile.stream()</strong>：是JarFile类中的一个方法，用于将Jar文件中的条目(文件)转换为流对象，返回值为流对象。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">// Pattrn.splitAsStream(CharSequence input)</span></span><br><span class="line">        <span class="comment">// 定义正则表达式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;\\s+&quot;</span>; <span class="comment">// 表示一个或多个空白字符</span></span><br><span class="line">        <span class="comment">// 创建 Pattern 对象</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">        <span class="comment">// 使用 splitAsStream() 方法分割字符串并返回流,并对流进行遍历操作</span></span><br><span class="line">        pattern.splitAsStream(<span class="string">&quot;Java is a programming language&quot;</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用JarFile.stream()</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">JarFile</span> <span class="variable">jarFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JarFile</span>(<span class="string">&quot;a.jar&quot;</span>)) &#123;</span><br><span class="line">            Stream&lt;JarEntry&gt; entryStream = jarFile.stream();</span><br><span class="line">            entryStream.forEach(entry -&gt; System.out.println(entry.getName()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h2 id="3-中间操作"><a href="#3-中间操作" class="headerlink" title="3.中间操作"></a>3.中间操作</h2><p>中间操作又可以分为<strong>无状态（Stateless）操作</strong>与<strong>有状态（Stateful）操作</strong>，前者是指元素的处理不受之前元素的影响；后者是指该操作只有拿到所有元素之后才能继续下去。<br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240508161846.png"></p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></td><td>过滤流中的元素，返回符合条件的元素组成的流</td></tr><tr><td><code>Stream&lt;T&gt; distinct()</code></td><td>元素去重，返回不含重复的元素的流 【依赖元素的hashCode()和equals()方法，注意判断是否需要进行重写】</td></tr><tr><td><code>Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</code></td><td>将流中的元素映射到另一个流中，返回映射后的流 【第一个类型是流中原本的元素类型，第二个类型是映射后的元素类型】</td></tr><tr><td><code>Stream&lt;T&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends T&gt;&gt; mapper)</code></td><td>将流中的元素映射到另一个流中，返回映射后的流，其中映射后的流可以是多个元素组成的流，而不是单个元素。【第一个类型是流中原本的元素类型，第二个类型是映射后的流中元素的类型】</td></tr><tr><td><code>Stream&lt;T&gt; sorted()</code></td><td>对流中的元素进行排序，返回排序后的流</td></tr><tr><td><code>Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)</code></td><td>对流中的元素进行排序，返回排序后的流，其中参数为比较器，用于比较元素大小。【依赖元素的compareTo()方法，注意判断是否需要进行重写】</td></tr><tr><td><code>Stream&lt;T&gt; skip(long n)</code></td><td>跳过前n个元素，返回剩余的元素组成的流</td></tr><tr><td><code>Stream&lt;T&gt; limit(long maxSize)</code></td><td>截取前maxSize个元素，返回截取后的流</td></tr><tr><td><code>Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code></td><td>将两个流合并为一个流，返回合并后的流 【如果a和b的类型不同，合并出来的会是他们共同的父类</td></tr><tr><td><code>Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action)</code></td><td>对流中的元素进行操作，返回操作后的流，但不改变原流。【参数为消费者，用于对元素进行操作】</td></tr></tbody></table><h3 id="3-1-筛选、去重"><a href="#3-1-筛选、去重" class="headerlink" title="3.1.筛选、去重"></a>3.1.筛选、去重</h3><p>filter()和distinct()方法用于筛选和去重流中的元素。</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        ArrayList&lt;Person&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(array,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;隔壁老王&quot;</span>,<span class="number">25</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;隔壁老王&quot;</span>,<span class="number">25</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">24</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小思思&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;用filter()筛选名字长度大于2的人物:&quot;</span>);</span><br><span class="line">        array.stream().filter(p -&gt; p.getName().length() &gt; <span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;用distinct()去重:&quot;</span>);</span><br><span class="line">        array.stream().distinct().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  用filter()筛选名字长度大于2的人物:</span></span><br><span class="line"><span class="comment">  Person&#123;name = 隔壁老王, age = 25&#125;</span></span><br><span class="line"><span class="comment">  Person&#123;name = 隔壁老王, age = 25&#125;</span></span><br><span class="line"><span class="comment">  Person&#123;name = 小思思, age = 23&#125; </span></span><br><span class="line"><span class="comment">  用distinct()去重:</span></span><br><span class="line"><span class="comment">  Person&#123;name = 张三, age = 23&#125;</span></span><br><span class="line"><span class="comment">  Person&#123;name = 隔壁老王, age = 25&#125;</span></span><br><span class="line"><span class="comment">  Person&#123;name = 李四, age = 24&#125;</span></span><br><span class="line"><span class="comment">  Person&#123;name = 小思思, age = 23&#125;</span></span><br><span class="line"><span class="comment">  */</span>  </span><br></pre></td></tr></table></figure></div><h3 id="3-2-映射"><a href="#3-2-映射" class="headerlink" title="3.2.映射"></a>3.2.映射</h3><h4 id="3-2-1-map-方法："><a href="#3-2-1-map-方法：" class="headerlink" title="3.2.1.map() 方法："></a>3.2.1.<strong>map() 方法</strong>：</h4><ul><li><code>map()</code> 方法接受一个函数作为参数，该函数用于将流中的每个元素映射到另一个值。这个映射后的值可以是<strong>任何类型</strong>，最后返回的流包含这些映射后的元素。</li><li>对于每个输入元素，<code>map()</code> 方法都会生成一个对应的输出元素。</li><li><code>map()</code> 方法返回的流与原始流的元素数量相同，但是每个元素都经过了映射函数的转换。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       Collections.addAll(array,</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>),</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;隔壁老王&quot;</span>,<span class="number">25</span>),</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小思思&quot;</span>,<span class="number">23</span>));</span><br><span class="line">       <span class="comment">// 调用map的方法一:</span></span><br><span class="line">       array.stream().map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Person, String&gt;() &#123;</span><br><span class="line">           <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> person.getName();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).forEach(System.out::println);</span><br><span class="line">       <span class="comment">// 调用map的方法二(lambda表达式):</span></span><br><span class="line">       array.stream().map(p -&gt; p.getName()).forEach(System.out::println);</span><br><span class="line">       <span class="comment">// 调用map的方法三(方法引用)</span></span><br><span class="line">       array.stream().map(Person::getName).forEach(System.out::println);</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 输出：</span></span><br><span class="line"><span class="comment">    * 张三</span></span><br><span class="line"><span class="comment">    * 隔壁老王</span></span><br><span class="line"><span class="comment">    * 小思思</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure></div><h4 id="3-2-2-flatMap-方法："><a href="#3-2-2-flatMap-方法：" class="headerlink" title="3.2.2.flatMap() 方法："></a>3.2.2.<strong>flatMap() 方法</strong>：</h4><ul><li><code>flatMap()</code> 方法也接受一个函数作为参数，但是这个函数的返回类型是一个流。这个函数会将流中的每个元素映射到<strong>另一个流</strong>。</li><li>与 <code>map()</code> 方法不同，<code>flatMap()</code> 方法会将这些内部流合并成一个单一的流。内部流中的所有元素都会被合并到结果流中，形成一个扁平化的流。</li><li><code>flatMap()</code> 方法可以处理嵌套的流结构，即使每个元素映射后的流可能包含多个元素，最终返回的流也只是一个单一的流。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先初始化输入列表</span></span><br><span class="line">List&lt;String&gt; list1 = List.of(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">List&lt;String&gt; list2 = List.of(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">List&lt;String&gt; list3 = List.of(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">List&lt;String &gt; list4 =List.of(<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>);</span><br><span class="line">List&lt;List&lt;String&gt;&gt; list = List.of(list1,list2,list3,list4);</span><br><span class="line"><span class="comment">//开始执行操作</span></span><br><span class="line">List&lt;String&gt; listT = list.stream().flatMap(Collection::stream).collect(Collectors.toList());</span><br><span class="line">System.out.println(listT);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给定输入：[[1],[2],[3],[4,5]]</span></span><br><span class="line"><span class="comment">要求输出：[1,2,3,4,5]*/</span></span><br></pre></td></tr></table></figure></div><p>看一下具体的执行流程。橙色的是stream的通用执行流程，不管你中间态用哪个方法，这里是不变的，蓝色的是<code>ArrayListSpliterator</code>分割器。红色的执行流程是flatMap的执行流程。<br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240508125402.png"></p><p>可以看到<code>ArrayListSpliterator</code>先取出第一个元素<code>[1]</code>这个一维数组传递给<code>flatMap</code>，然后flatMap执行了我们传入的<code>Collection::stream</code>方法，该方法是初始化一个stream头节点。也就是再生成了一个stream</p><p>重点就是这里了。再次把[1]这个一维数组放入了新的stream里面。然后把结果态节点<code>ReduceOps</code>传递给了新的stream作为新的stream的结果态节点。</p><p>这个时候新的stream开始执行<code>ArrayListSpliterator</code>。从而把[1]一维数组进行for循环，取出了其中的<code>1</code>这个元素，然后把1传入了同一个<code>ReduceOps</code>进行处理从而组成了一个结果list-&gt;[1]。</p><p>把步骤总结如下：</p><p>1.取出二维数组的第一个一维数组<br>2.把一维数组和结果态节点重新创建一个stream<br>3.执行stream把一维数组的元素循环放入结果态的list<br>循环二维数组，不断重复上述步骤，就可以把二维数组展开成一维数组了。</p><h4 id="3-2-3-map-和flatMap-的区别"><a href="#3-2-3-map-和flatMap-的区别" class="headerlink" title="3.2.3.map()和flatMap()的区别"></a>3.2.3.<strong>map()和flatMap()的区别</strong></h4><blockquote><p><strong>总的来说:</strong></p><ul><li><code>map()</code> 方法是一对一的映射，而 <code>flatMap()</code> 方法可以处理一对多的映射，可以将多个流合并成一个流。</li><li><code>map()</code>和<code>faltMap()</code>的参数差别在于，前者传入一个实体返回一个实体，后者则是传入一个实体返回一个Stream流，那既然是流，最好返回值本身就是一个Stream，或者能被转换成Stream的对象!</li></ul></blockquote><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;Holle world and you world&quot;</span>);</span><br><span class="line"><span class="comment">// 调用flatMap的方法一:</span></span><br><span class="line">list.stream().flatMap(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Stream&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> Stream&lt;String&gt; <span class="title function_">apply</span><span class="params">(String list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(list.split(<span class="string">&quot;\\s+&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 调用flatMap的方法二:</span></span><br><span class="line">list.stream().flatMap(t -&gt; Stream.of(t.split(<span class="string">&quot;\\s+&quot;</span>)))</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出: Holle</span></span><br><span class="line"><span class="comment">  *       world</span></span><br><span class="line"><span class="comment">  *       and</span></span><br><span class="line"><span class="comment">  *       you</span></span><br><span class="line"><span class="comment">  *       world</span></span><br><span class="line"><span class="comment">  * flatMap会把按空格拆分后所有的单词流合并成一个流返回.</span></span><br><span class="line"><span class="comment">  * 这就意味着，当你调用 forEach(System.out::println) 方法时，它会直接作用于这个合并后的流上，</span></span><br><span class="line"><span class="comment">  * 并打印出每个单词。</span></span><br><span class="line"><span class="comment">  * */</span></span><br><span class="line">  <span class="comment">//Map方法</span></span><br><span class="line">  list.stream().map(t -&gt; Stream.of(t.split(<span class="string">&quot;\\s+&quot;</span>)))</span><br><span class="line">      .forEach(System.out::println);</span><br><span class="line">  <span class="comment">/*输出:java.util.stream.ReferencePipeline$Head@b1bc7ed</span></span><br><span class="line"><span class="comment">  而Map方法最后的结果为一个地址，并没有对数组里面的结果进行细分,最后的结果依旧为一个整体</span></span><br><span class="line"><span class="comment">  这是因为map里面的参数Stream.of(t.split(&quot;\\s+&quot;))会将每个元素映射成一个流,</span></span><br><span class="line"><span class="comment">  而map() 方法返回的是一个包含映射后元素的流对象,这个流没有重写`toString`方法</span></span><br><span class="line"><span class="comment">  导致返回的是一个包含多个流的流,在使用.forEach方法时,默认打印对象的 toString() 方法的结果。</span></span><br><span class="line"><span class="comment">  在这种情况下，由于没有重写 toString() 方法，所以它打印的是默认的对象地址信息。</span></span><br><span class="line"><span class="comment">  因为list中只有一个元素,所以外部流对象只包含一个内部流对象,输出一个地址*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*list.stream().map(new Function&lt;String, String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public String apply(String s) &#123;</span></span><br><span class="line"><span class="comment">                return s.split(&quot;\\s+&quot;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;).forEach(System.out::println);*/</span></span><br><span class="line">  <span class="comment">// 在return s.split(&quot;\\s+&quot;);会报错，是因为split()方法返回的是一个数组，而map()方法要求返回的是一个对象。map并不能处理一对多的映射      </span></span><br></pre></td></tr></table></figure></div><h3 id="3-3-排序"><a href="#3-3-排序" class="headerlink" title="3.3.排序"></a>3.3.排序</h3><ul><li><code>sorted()</code> 方法用于对流中的元素进行排序。默认情况下，排序是按照自然顺序进行的，即升序。【其中的元素必须实现 Comparable 接口，否则会抛出 ClassCastException 异常】</li><li><code>sorted(Comparator&lt;T&gt; comparator)</code> 方法用于对流中的元素进行排序，并指定排序规则。我们可以使用lambda表达式来创建一个Comparator实例。可以自定义排序规则。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#自然序排序一个list</span><br><span class="line">list.stream().sorted() </span><br><span class="line"> </span><br><span class="line">#自然序逆序元素，使用Comparator 提供的reverseOrder() 方法</span><br><span class="line">list.stream().sorted(Comparator.reverseOrder()) </span><br><span class="line"> </span><br><span class="line"># 使用Comparator 来排序一个list</span><br><span class="line">list.stream().sorted(Comparator.comparing(Student::getAge)) </span><br><span class="line"> </span><br><span class="line"># 颠倒使用Comparator 来排序一个list的顺序，使用Comparator 提供的reversed() 方法</span><br><span class="line">list.stream().sorted(Comparator.comparing(Student::getAge).reversed()) </span><br></pre></td></tr></table></figure></div><ul><li><code>Comparator.thenComparing(Comparator&lt;? super T&gt; other)</code>: 实现多字段排序，如果第一个比较器比较结果相等，则使用第二个比较器进行比较。可以搭配使用Comparator.reverseOrder() 实现降序和升序</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按年龄升序，如果年龄相等，再按零花钱升序</span></span><br><span class="line">List&lt;userInfo&gt; userList3 = userList.stream()</span><br><span class="line">	.sorted(Comparator.comparing(userInfo::getAge).thenComparing(userInfo::getMoney))</span><br><span class="line">	.collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按年龄降序，如果年龄相等，再按零花钱降序</span></span><br><span class="line">List&lt;userInfo&gt; userList3 = userList.stream()</span><br><span class="line">  .sorted(Comparator.comparing(userInfo::getAge).thenComparing(userInfo::getMoney,Comparator.reverseOrder()))</span><br><span class="line">  <span class="comment">// 也可以等价于 .sorted(Comparator.comparing(userInfo::getAge).thenComparing(Comparator.comparing(userInfo::getMoney).reversed()))</span></span><br><span class="line">  .collect(Collectors.toList());  </span><br></pre></td></tr></table></figure></div><ul><li>自定义排序规则</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照名字的长度排序，长的在前面。【如果使用compareTo，是按照字典序排序】</span></span><br><span class="line"> List&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">        Collections.addAll(list,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">23</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">24</span>));</span><br><span class="line">        list.stream().sorted((s1, s2) -&gt; s2.getName().length() - s1.getName().length() )</span><br><span class="line">                .forEach(System.out::println);</span><br></pre></td></tr></table></figure></div><h3 id="3-4-跳过、截取"><a href="#3-4-跳过、截取" class="headerlink" title="3.4.跳过、截取"></a>3.4.跳过、截取</h3><ul><li><code>skip(long n)</code>：如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。</li><li><code>limit(long n)</code>：参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10StreamSkip</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; result = original.skip(<span class="number">2</span>);</span><br><span class="line">        System.out.println(result.count()); <span class="comment">// 1 ：流中剩下 &quot;周芷若&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11StreamLimit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; result = original.limit(<span class="number">2</span>);</span><br><span class="line">        System.out.println(result.count()); <span class="comment">// 2：截取了 &quot;张无忌&quot; 和 &quot;张三丰&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-5-结合"><a href="#3-5-结合" class="headerlink" title="3.5.结合"></a>3.5.结合</h3><ul><li><code>concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code> : 合并a和b两个流为一个流 【如果a和b的类型不同，合并出来的会是他们共同的父类】<blockquote><p>备注：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。</p></blockquote></li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo12StreamConcat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; streamA = Stream.of(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; streamB = Stream.of(<span class="string">&quot;张翠山&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; result = Stream.concat(streamA, streamB);</span><br><span class="line">        result.forEach(System.out::println);</span><br><span class="line">        <span class="comment">/*输出:</span></span><br><span class="line"><span class="comment">        张无忌</span></span><br><span class="line"><span class="comment">        张翠山  */</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-6-调试"><a href="#3-6-调试" class="headerlink" title="3.6.调试"></a>3.6.调试</h3><ul><li><code>peek(Comsumer&lt;? super T&gt; action)</code>：它接受一个 Consumer 函数作为参数，该函数会被应用到流中的每个元素上。【不会销毁流对象】<blockquote><p>这个方法通常用于调试或记录流中元素的中间状态，或者在调试代码时查看流中元素的值，而不会对流进行实际操作。</p></blockquote></li></ul><h4 id="3-6-1-对流中的元素进行遍历"><a href="#3-6-1-对流中的元素进行遍历" class="headerlink" title="3.6.1.对流中的元素进行遍历"></a>3.6.1.对流中的元素进行遍历</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;userInfo&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(userList,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">userInfo</span>(<span class="number">18</span>,<span class="number">30</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">userInfo</span>(<span class="number">18</span>,<span class="number">34</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">userInfo</span>(<span class="number">17</span>,<span class="number">28</span>));</span><br><span class="line"><span class="comment">// 调用peek()方法遍历流中的元素</span></span><br><span class="line">List&lt;userInfo&gt; list = userList.stream().peek(System.out::println)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">/*输出:</span></span><br><span class="line"><span class="comment">userInof&#123;Age = 18, Money = 30&#125;</span></span><br><span class="line"><span class="comment">userInof&#123;Age = 18, Money = 34&#125;</span></span><br><span class="line"><span class="comment">userInof&#123;Age = 17, Money = 28&#125;</span></span><br><span class="line"><span class="comment">[userInof&#123;Age = 18, Money = 30&#125;, userInof&#123;Age = 18, Money = 34&#125;, userInof&#123;Age = 17, Money = 28&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div><h4 id="3-6-2-对流中的对象进行修改"><a href="#3-6-2-对流中的对象进行修改" class="headerlink" title="3.6.2.对流中的对象进行修改"></a>3.6.2.对流中的对象进行修改</h4><p>在Java的Stream中，它实际上是对原始数据的引用。</p><ul><li>对于基本数据类型：修改只会作用在<code>peek()</code>方法的内部，因为基本数据类型是按值传递的，<code>peek()</code>方法中的参数是局部变量，对它们的修改不会影响到原始数据。所以，对基本数据类型进行的修改只会作用在peek()方法的内部。</li><li>对于引用数据类型：<ul><li>对于不可变对象（如<code>String</code>）：对它们的操作会返回一个新对象，而不会修改原始数据。所以对不可变对象的操作也只会作用在<code>peek()</code>方法的内部，不会影响流中的数据或原始数据。</li><li>对于可变对象（如<code>StringBuilder</code>、自己创建的类<code>userInfo</code>等）：对它们的操作会直接修改原始数据。因此，对可变对象的操作会影响流中的数据以及原始数据。</li></ul></li></ul><blockquote><p><strong>对于流中的对象进行修改：</strong><br>实际上，流中的操作不会直接修改原始数据，而是操作原始数据中的对象。这意味着对流中的对象进行的任何修改都会影响原始数据。然而，需要注意的是，如果流中的对象是不可变对象，对它们进行的修改只会影响到流中的对象，而不会修改原始数据。这种修改只会作用在peek()方法的内部，不会影响到原始数据。</p></blockquote><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 流中对象是不可变对象String，对其修改只会作用在peek()方法内部，不会影响流中的数据或原始数据</span></span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">list1.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">list1.add(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line">list1.stream()</span><br><span class="line">        .peek(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                s += <span class="string">&quot;_suffix&quot;</span>;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) <span class="comment">// 修改字符串内容</span></span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">System.out.println(list1);</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">apple_suffix</span></span><br><span class="line"><span class="comment">apple</span></span><br><span class="line"><span class="comment">banana_suffix       </span></span><br><span class="line"><span class="comment">banana                -&gt; 这里的输出顺序是先运行一次peek()方法，再运行一次forEach()方法，这样子迭代下去的</span></span><br><span class="line"><span class="comment">cherry_suffix            因为中间操作peek()属于无状态，所以元素的处理不受之前元素的影响，会直接执行完整条流中的所有操作         </span></span><br><span class="line"><span class="comment">cherry</span></span><br><span class="line"><span class="comment">[apple, banana, cherry]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用peek()方法遍历流中的对象,将用户的年龄加10,注意:这个修改会修改到流中数据和原始数据</span></span><br><span class="line">List&lt;userInfo&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(userList,</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">userInfo</span>(<span class="number">18</span>,<span class="number">30</span>),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">userInfo</span>(<span class="number">18</span>,<span class="number">34</span>),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">userInfo</span>(<span class="number">17</span>,<span class="number">28</span>));</span><br><span class="line">userList.stream().peek(userInfo -&gt; userInfo.setAge(userInfo.getAge()+<span class="number">10</span>))</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">System.out.println(userList);</span><br><span class="line"><span class="comment">/*输出:</span></span><br><span class="line"><span class="comment">userInof&#123;Age = 28, Money = 30&#125;</span></span><br><span class="line"><span class="comment">userInof&#123;Age = 28, Money = 34&#125;</span></span><br><span class="line"><span class="comment">userInof&#123;Age = 27, Money = 28&#125;</span></span><br><span class="line"><span class="comment">[userInof&#123;Age = 28, Money = 30&#125;, userInof&#123;Age = 28, Money = 34&#125;, userInof&#123;Age = 27, Money = 28&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 流中对象是StringBuilder类型，属于可变对象，对它们进行的操作会影响流中的数据以及原始数据。</span></span><br><span class="line">List&lt;StringBuilder&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;apple&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;banana&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;cherry&quot;</span>));</span><br><span class="line">        list.stream().peek(stringBuilder -&gt; stringBuilder.append(<span class="string">&quot;apple&quot;</span>))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">appleapple</span></span><br><span class="line"><span class="comment">bananaapple</span></span><br><span class="line"><span class="comment">cherryapple</span></span><br><span class="line"><span class="comment">[appleapple, bananaapple, cherryapple]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div><h4 id="3-6-3-peek-方法的时序图"><a href="#3-6-3-peek-方法的时序图" class="headerlink" title="3.6.3.peek()方法的时序图"></a>3.6.3.peek()方法的时序图</h4><p>针对前面的代码在peek()方法后执行forEach()方法时，输出顺序是先运行一次peek()方法，再运行一次forEach()方法，这样子迭代下去的这个问题，我们通过时序图来解释。</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先初始化输入列表</span></span><br><span class="line">List&lt;String&gt; list1 = List.of(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">List&lt;String&gt; list2 = List.of(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">List&lt;String&gt; list3 = List.of(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">List&lt;String &gt; list4 =List.of(<span class="string">&quot;5&quot;</span>,<span class="string">&quot;4&quot;</span>);</span><br><span class="line">List&lt;List&lt;String&gt;&gt; list = List.of(list1,list2,list3,list4);</span><br><span class="line"><span class="comment">//开始执行操作</span></span><br><span class="line">List&lt;String&gt; listT = list.stream()</span><br><span class="line">        .flatMap(Collection::stream)</span><br><span class="line">        .peek(e -&gt; System.out.println(e)).filter(x -&gt; Integer.parseInt(x) &gt; <span class="number">2</span>)</span><br><span class="line">        .peek(e -&gt; System.out.println(e))</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240508120158.png"><br>通过时序图我们可以发现，由于中间操作peek()、filter()和flatMap()都是属于无状态，所以在流(Stream)中，对于每个元素，会先执行完整条流中的所有操作，然后才处理下一个元素。这意味着，对于每个元素，先运行完整条流中的操作链，然后再处理下一个元素。而不是等待所有元素的某个操作完成后再进行下一个操作。</p><h4 id="3-6-4-peek-方法的坑"><a href="#3-6-4-peek-方法的坑" class="headerlink" title="3.6.4.peek()方法的坑"></a>3.6.4.peek()方法的坑</h4><ul><li><p><strong>坑一：peek() 不影响流的生成和消费</strong><br>peek()是一个中间操作，它并不会终止流的处理流程，因此如果不跟一个终端操作（如collect(), forEach(), count()等），则peek()中的操作不会被执行，换言之，只有当流被消耗时，peek()里的操作才会真正发生。</p></li><li><p><strong>坑二：peek() 的执行次数取决于下游操作</strong><br>peek()方法中的动作会在流的每个元素上执行一次，但具体执行多少次取决于下游的终端操作。例如，如果你在排序(sorted())前使用了peek()，而在排序后又使用了一次peek()，则同一个元素可能会被两次peek()。</p></li><li><p><strong>坑三：并发流中的peek()行为</strong><br>对于并行流，peek()操作的执行顺序没有保证，而且可能会多次执行（取决于JVM的具体调度）。如果你在并行流中依赖peek()的顺序性或唯一性，可能会遇到意想不到的问题。</p></li><li><p><strong>坑四：资源管理</strong><br>如果在peek()中打开了一些资源（如文件、数据库连接等），但在peek()内部并未妥善关闭它们，可能会导致资源泄露。因为在没有终端操作的情况下，流可能不会立即执行，资源也就无法及时释放。</p></li><li><p><strong>坑五：对流元素的修改可能无效</strong><br>peek()通常用于读取或打印流元素，而不是修改它们。虽然理论上可以尝试在peek()中修改元素，但由于流的惰性求值和可能的不可变性，这样的修改可能不会反映到源集合或后续流操作中。</p></li><li><p><strong>坑六：对于可变对象的处理可能会影响流中的数据和原始数据</strong><br>peek()方法通常用于读取或打印流元素，而不是修改它们。然而，如果流中的元素是可变对象，并且在peek()中对其进行了修改，这些修改可能会影响到流中的数据以及原始数据。这是因为可变对象的特性使得对其进行的修改会在流中传递，可能会对后续的操作产生意外的影响。因此，在处理可变对象时，需要格外小心，并确保了解其对流处理的影响。</p></li></ul><h2 id="4-终结操作"><a href="#4-终结操作" class="headerlink" title="4.终结操作"></a>4.终结操作</h2><p>结束操作又可以分为<strong>短路操作</strong>与<strong>非短路操作</strong>，前者是指遇到某些符合条件的元素就可以得到最终结果；而后者是指必须处理所有元素才能得到最终结果。<br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240508163154.png"></p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>forEach(Consumer&lt;? super T&gt; action)</code></td><td>遍历流中的元素，并对每个元素执行指定的操作。</td></tr><tr><td><code>findFirst()</code></td><td>返回流中的第一个元素，如果流为空，则返回一个空的Optional对象。</td></tr><tr><td><code>findAny()</code></td><td>返回流中的任意一个元素，如果流为空，则返回一个空的Optional对象。</td></tr><tr><td><code>anyMatch(Predicate&lt;? super T&gt; predicate)</code></td><td>判断流中是否存在至少一个元素满足指定的条件。返回一个boolean值。</td></tr><tr><td><code>allMatch(Predicate&lt;? super T&gt; predicate)</code></td><td>判断流中是否所有元素都满足指定的条件。返回一个boolean值。</td></tr><tr><td><code>noneMatch(Predicate&lt;? super T&gt; predicate)</code></td><td>判断流中是否没有元素满足指定的条件。返回一个boolean值。</td></tr><tr><td><code>reduce(BinaryOperator&lt;T&gt; accumulator)</code></td><td>将流中的元素按照指定的规则进行合并，返回合并后的结果。如果流为空，返回的 Optional 对象也为空。</td></tr><tr><td><code>reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code></td><td>对流中的元素进行累积操作，使用指定的初始值，并返回累积结果。如果流为空，返回的是初始值。</td></tr><tr><td><code>max(Comparator&lt;? super T&gt; comparator)</code></td><td>返回流中最大的元素，如果流为空，则返回一个空的Optional对象。</td></tr><tr><td><code>min(Comparator&lt;? super T&gt; comparator)</code></td><td>返回流中最小的元素，如果流为空，则返回一个空的Optional对象。</td></tr><tr><td><code>count</code></td><td>返回流中元素的数量【long类型】。</td></tr><tr><td><code>toArray()</code></td><td>将流中的元素转换为数组，返回一个数组。</td></tr><tr><td><code>toList()</code></td><td>将流中的元素转换为List，返回一个List。</td></tr><tr><td><code>collect(Collector&lt;? super T, A, R&gt; collector)</code></td><td>将流中的元素收集到一个容器中，返回该容器。方法中的参数<code>A</code>和<code>R</code>表示中间结果容器的类型和最终结果的类型。</td></tr></tbody></table><h3 id="4-1-遍历"><a href="#4-1-遍历" class="headerlink" title="4.1.遍历"></a>4.1.遍历</h3><p><code>forEach(Consumer&lt;? super T&gt; action)</code>：遍历流中的元素，并对每个元素执行指定的操作。【打印、计算、转换……】</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forEach遍历打印</span></span><br><span class="line">List&lt;Integer&gt; list1 = List.of(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>);</span><br><span class="line">list1.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach遍历求和</span></span><br><span class="line">List&lt;Integer&gt; list2 = List.of(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>);</span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(); <span class="comment">//将sum声明为AtomicInteger类型，因为AtomicInteger是原子性的，可以被匿名内部类访问。</span></span><br><span class="line">list2.forEach((Integer num) -&gt; sum.addAndGet(num));</span><br><span class="line">System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum); <span class="comment">// 输出 Sum: 27</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach遍历实现字母小写到大写的转换</span></span><br><span class="line">List&lt;String&gt; strings = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>);</span><br><span class="line">List&lt;String&gt; upperCaseStrings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">strings.forEach((String s) -&gt; upperCaseStrings.add(s.toUpperCase()));</span><br><span class="line">System.out.println(<span class="string">&quot;Upper case strings: &quot;</span> + upperCaseStrings); <span class="comment">// 输出 Upper case strings: [APPLE, BANANA, CHERRY]</span></span><br></pre></td></tr></table></figure></div><h3 id="4-2-匹配"><a href="#4-2-匹配" class="headerlink" title="4.2.匹配"></a>4.2.匹配</h3><ul><li><code>findFirst()</code>：返回流中的第一个元素，如果流为空，则返回一个空的Optional对象。</li><li><code>findAny()</code>：返回流中的任意一个元素，如果流为空，则返回一个空的Optional对象。</li><li><code>anyMatch(Predicate&lt;? super T&gt; predicate)</code>：判断流中是否存在至少一个元素满足指定的条件。返回一个boolean值。</li><li><code>allMatch(Predicate&lt;? super T&gt; predicate)</code>：判断流中是否所有元素都满足指定的条件。返回一个boolean值。</li><li><code>noneMatch(Predicate&lt;? super T&gt; predicate)</code>：判断流中是否没有元素满足指定的条件。返回一个boolean值。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 = List.of(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>);</span><br><span class="line">System.out.println(list1.stream().findFirst());<span class="comment">// 输出：Optional[3]</span></span><br><span class="line">System.out.println(list1.stream().findAny()); <span class="comment">// 输出：Optional[3]</span></span><br><span class="line">System.out.println(list1.stream().anyMatch(x -&gt; x % <span class="number">3</span> == <span class="number">0</span>));<span class="comment">// 输出：true</span></span><br><span class="line">System.out.println(list1.stream().allMatch(x -&gt; x % <span class="number">3</span> == <span class="number">0</span>));<span class="comment">// 输出：false</span></span><br><span class="line">System.out.println(list1.stream().noneMatch(x -&gt; x % <span class="number">3</span> == <span class="number">0</span>));<span class="comment">// 输出：false</span></span><br><span class="line"><span class="comment">// 如果流为空，则返回的 Optional 对象也为空。</span></span><br><span class="line">List&lt;Integer&gt; list2 = List.of();</span><br><span class="line">System.out.println(list2.stream().findFirst()); <span class="comment">// 输出：Optional.empty</span></span><br><span class="line">System.out.println(list2.stream().findAny());<span class="comment">// 输出：Optional.empty</span></span><br><span class="line">System.out.println(list2.stream().anyMatch(x -&gt; x % <span class="number">3</span> == <span class="number">0</span>));<span class="comment">// 输出：false</span></span><br><span class="line">System.out.println(list2.stream().allMatch(x -&gt; x % <span class="number">3</span> == <span class="number">0</span>)); <span class="comment">// 输出：true</span></span><br><span class="line">System.out.println(list2.stream().noneMatch(x -&gt; x % <span class="number">3</span> == <span class="number">0</span>));<span class="comment">// 输出：true</span></span><br><span class="line"><span class="comment">// 如果list是null,在执行流操作时，会抛出NullPointerException异常。</span></span><br></pre></td></tr></table></figure></div><h3 id="4-3-规约"><a href="#4-3-规约" class="headerlink" title="4.3.规约"></a>4.3.规约</h3><ul><li><code>reduce(BinaryOperator&lt;T&gt; accumulator)</code>：将流中的元素按照指定的规则进行合并，返回合并后的结果。如果流为空，返回的 Optional 对象也为空。<ul><li>参数：<code>BinaryOperator&lt;T&gt; accumulator</code>,<code>BinaryOperator</code>继承于 <code>BiFunction</code>, 这里实现 <code>BiFunction.apply(param1,param2)</code> 接口即可。支持lambda表达式，形如：(result,item)-&gt;{…} 。</li><li>返回值：返回Optional对象，由于结果存在空指针的情况（当集合为空时）因此需要使用Optional。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;Integer&gt; list=List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//将数组进行累加求和</span></span><br><span class="line"><span class="comment">//由于返回的是 Optional ，因此需要get()取出值。</span></span><br><span class="line">Integer total=list.stream().reduce((result,item)-&gt;result+item).get();</span><br><span class="line">System.out.println(total)</span><br><span class="line"> <span class="comment">// 输出：15</span></span><br><span class="line"> </span><br><span class="line"> List&lt;String&gt; strings = List.of(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line"> <span class="comment">// 使用 reduce 方法将字符串列表中的字符串拼接成一个新的字符串</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> strings.stream().reduce(<span class="string">&quot;&quot;</span>, (partialResult, str) -&gt; partialResult + str);</span><br><span class="line"> System.out.println(result);</span><br><span class="line"> <span class="comment">// 输出：Hello World!</span></span><br></pre></td></tr></table></figure></div></li><li><code>reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code>：对流中的元素进行累积操作，使用指定的初始值，并返回累积结果。如果流为空，返回的是初始值.<ul><li>参数1：T identity 为一个初始值（默认值） ，当集合为空时，就返回这个默认值，当集合不为空时，该值也会参与计算。</li><li>参数2：BinaryOperator<t>accumulator 这个与一个参数的reduce相同。</t></li><li>返回值：并非 Optional，由于有默认值 identity ，因此计算结果不存在空指针的情况。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list=List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">Integer total=list.stream().reduce(<span class="number">0</span>,(result,item)-&gt;result+item);</span><br><span class="line">System.out.println(total);<span class="comment">//结果为：15 </span></span><br><span class="line"></span><br><span class="line">list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">total=list.stream().reduce(<span class="number">0</span>,(result,item)-&gt;result+item);</span><br><span class="line">System.out.println(total);<span class="comment">//数组为空时，结果返回默认值0  </span></span><br></pre></td></tr></table></figure></div></li><li><code>reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator,BinaryOperator&lt;U&gt; combiner)</code>：这个方法允许更复杂的规约操作，可以用于计算任意类型的累加器值，而不仅仅是原始数据类型。同时，<strong>由于存在并行执行的可能性，需要确保累加器函数和组合器函数的实现是线程安全的</strong>。<ul><li>第一个参数和第二个参数的定义同上，第三个参数比较特殊，后面慢慢讲。</li><li>可以看到该方法有两个泛型 T 和 U ：<br>（1）泛型T是集合中元素的类型，<br>（2）泛型U是计算之后返回结果的类型，U的类型由第一个参数 identity 决定。<br>也就是说，三个参数的reduce()可以返回与集合中的元素不同类型的值，方便我们对复杂对象做计算式和转换。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; list= List.of(</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">1</span>)</span><br><span class="line">              ,<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">2</span>)</span><br><span class="line">              ,<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">3</span>)</span><br><span class="line">              ,<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>,<span class="number">4</span>)</span><br><span class="line">              ,<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小红&quot;</span>,<span class="number">5</span>));</span><br><span class="line">Integer total=list.stream()</span><br><span class="line">        .reduce(</span><br><span class="line">                Integer.valueOf(<span class="number">0</span>)  <span class="comment">/*初始值 identity*/</span></span><br><span class="line">                ,(integer, person)-&gt;integer+ person.getAge() <span class="comment">/*累加计算 accumulator*/</span></span><br><span class="line">                ,(integer1,integer2)-&gt;integer1+integer2 <span class="comment">/*第三个参数 combiner*/</span></span><br><span class="line">        );</span><br><span class="line">System.out.println(total);<span class="comment">//结果：15</span></span><br></pre></td></tr></table></figure></div><p>其实这相当于</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer total=list.stream().mapToInt(Person::getAge).sum();</span><br><span class="line">System.out.println(total);<span class="comment">//结果也是：15  </span></span><br></pre></td></tr></table></figure></div></li></ul><p>第三个参数 <code>BinaryOperator&lt;U&gt; combiner</code> 是个什么鬼？<br>这个参数的lambda表达式我是这么写的：<code>(integer1,integer2)-&gt;integer1+integer2</code><br>现在我将其打印出来：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer total=list.stream()</span><br><span class="line">        .reduce(</span><br><span class="line">                Integer.valueOf(<span class="number">0</span>)</span><br><span class="line">                ,(integer, person)-&gt;integer+ person.getAge()</span><br><span class="line">                ,(integer1,integer2)-&gt; &#123;</span><br><span class="line">                    <span class="comment">//这个println居然没有执行！！！</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;integer1=&quot;</span> + integer1 + <span class="string">&quot;, integer2=&quot;</span> + integer2);</span><br><span class="line">                    <span class="keyword">return</span> integer1 + integer2;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">System.out.println(total);<span class="comment">//结果：15</span></span><br></pre></td></tr></table></figure></div><p>发现这个参数的lambda表达式根本就没有执行？！<br>我换了一种方式，换成 parallelStream ，然后把线程id打印出来：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Integer total=list.parallelStream()</span><br><span class="line">        .reduce(</span><br><span class="line">                  Integer.valueOf(<span class="number">0</span>)</span><br><span class="line">                ,(integer, person)-&gt;integer+ person.getAge()</span><br><span class="line">                ,(integer1,integer2)-&gt; &#123;</span><br><span class="line">                      <span class="comment">//由于用的 parallelStream ，可发生并行计算，所以我增加线程id的打印：</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;threadId=&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;, integer1=&quot;</span>+integer1+<span class="string">&quot;, integer2=&quot;</span>+integer2);</span><br><span class="line">                    <span class="keyword">return</span> integer1 + integer2;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">System.out.println(total);</span><br><span class="line"><span class="comment">/*结果如下：</span></span><br><span class="line"><span class="comment">threadId=1, integer1=4, integer2=5</span></span><br><span class="line"><span class="comment">threadId=30, integer1=1, integer2=2</span></span><br><span class="line"><span class="comment">threadId=1, integer1=3, integer2=9</span></span><br><span class="line"><span class="comment">threadId=1, integer1=3, integer2=12</span></span><br><span class="line"><span class="comment">15*/</span></span><br></pre></td></tr></table></figure></div><p>把 stream 换成并行的 parallelStream，<br>可以看出，有两个线程在执行任务：线程1和线程30 ，<br>每个线程会分配几个元素做计算，<br>如上面的线程30分配了元素1和2，线程1分配了3、4、5。<br>至于线程1为什么会有两个3，是由于线程30执行完后得到的结果为3（1+2），而这个3又会作为后续线程1的入参进行汇总计算。<br>可以多跑几次，每次执行的结果不一定相同，如果看不出来规律，可以尝试增加集合中的元素个数，数据量大更有利于并行计算发挥作用。</p><p><mark>因此，第三个参数 <code>BinaryOperator&lt;U&gt; combiner</code> 的作用为：汇总所有线程的计算结果得到最终结果，</mark><br>并行计算会启动多个线程执行同一个计算任务，每个线程计算完后会有一个结果，最后要将这些结果汇总得到最终结果。</p><p>我们再来看一个有意思的结果，把第一个参数 identity 从0换成1：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Integer total=list.parallelStream()</span><br><span class="line">    .reduce(</span><br><span class="line">                    Integer.valueOf(<span class="number">1</span>)</span><br><span class="line">            ,(integer, person)-&gt;&#123; System.out.println(<span class="string">&quot;$ threadId=&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;, integer=&quot;</span>+integer+<span class="string">&quot;, scoreBean.getScore()=&quot;</span>+person.getAge());</span><br><span class="line">                      <span class="keyword">return</span> integer+ person.getAge();&#125;</span><br><span class="line">                  ,(integer1,integer2)-&gt; &#123;</span><br><span class="line">                            <span class="comment">//由于用的 parallelStream ，可发生并行计算，所以我增加线程id的打印：</span></span><br><span class="line">                      System.out.println(<span class="string">&quot;threadId=&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;, integer1=&quot;</span>+integer1+<span class="string">&quot;, integer2=&quot;</span>+integer2);</span><br><span class="line">                      <span class="keyword">return</span> integer1 + integer2;</span><br><span class="line">                  &#125;</span><br><span class="line">          );</span><br><span class="line">  System.out.println(total);</span><br><span class="line">  <span class="comment">/*结果如下：</span></span><br><span class="line"><span class="comment">  $ threadId=30, integer=1, scoreBean.getScore()=2</span></span><br><span class="line"><span class="comment">  $ threadId=1, integer=1, scoreBean.getScore()=3</span></span><br><span class="line"><span class="comment">  $ threadId=32, integer=1, scoreBean.getScore()=5</span></span><br><span class="line"><span class="comment">  $ threadId=33, integer=1, scoreBean.getScore()=4</span></span><br><span class="line"><span class="comment">  $ threadId=31, integer=1, scoreBean.getScore()=1</span></span><br><span class="line"><span class="comment">  threadId=33, integer1=5, integer2=6</span></span><br><span class="line"><span class="comment">  threadId=31, integer1=2, integer2=3</span></span><br><span class="line"><span class="comment">  threadId=33, integer1=4, integer2=11</span></span><br><span class="line"><span class="comment">  threadId=33, integer1=5, integer2=15</span></span><br><span class="line"><span class="comment">  20*/</span></span><br></pre></td></tr></table></figure></div><p>预期结果应该是16（初始值1+原来的结果15），但实际结果为20，多加了4次1，猜测是多加了四次初始值，<br>从打印的结果可以发现：<br>（1）并行计算时用了5个线程（线程id依次为：30, 1, 32, 33, 31），汇总合并时用了两个线程（线程id为33和31）<br>（2）并行计算的每一个线程都用了初始值参与计算，因此多加了4次初始值。</p><blockquote><p>总结：<br>使用 parallelStream 时，初始值 identity 应该设置一个不影响计算结果的值，比如本示例中设置为 0 就不会影响结果。<br>我觉得这个初始值 identity 有两个作用：<code>确定泛型U的类型</code> 和 <code>避免空指针</code>。<br>但是如果初始值本身就是一个复杂对象那该怎么办呢？<br>比如是初始值是一个数组，那么应该设定为一个空数组。如果是其他复杂对象那就得根据你reduce的具体含义来设定初始值了。</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t) </span><br><span class="line"><span class="comment">//combiner.apply(u1,u2) 接收两个相同类型U的参数 </span></span><br><span class="line"><span class="comment">//accumulator.apply(u, t) 接收两个不同类型的参数U和T，U是返回值的类型，T是集合中元素的类型</span></span><br><span class="line"><span class="comment">//这个等式恒等，parallelStream计算时就不会产生错误结果</span></span><br></pre></td></tr></table></figure></div></blockquote><h3 id="4-4-聚合"><a href="#4-4-聚合" class="headerlink" title="4.4.聚合"></a>4.4.聚合</h3><ul><li><code>max(Comparator&lt;? super T&gt; comparator)</code>: 返回流中最大的元素，如果流为空，则返回一个空的Optional对象。</li><li><code>max(Comparator&lt;? super T&gt; comparator)</code>: 返回流中最小的元素，如果流为空，则返回一个空的Optional对象。</li><li><code>count()</code>: 返回个数【long类型】</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line">  System.out.println(list.stream().max(Integer::compare));<span class="comment">// 输出：Optional[5]</span></span><br><span class="line">  System.out.println(list.stream().min(Comparator.comparing(Integer::intValue)).get());<span class="comment">// 输出：1</span></span><br><span class="line">  System.out.println(list.stream().count());<span class="comment">// 输出：5</span></span><br><span class="line">  list = List.of();</span><br><span class="line">  System.out.println(list.stream().max(Integer::compare));<span class="comment">// 输出：Optional.empty</span></span><br></pre></td></tr></table></figure></div><h3 id="4-5-收集"><a href="#4-5-收集" class="headerlink" title="4.5.收集"></a>4.5.收集</h3><h4 id="4-5-1-toArray"><a href="#4-5-1-toArray" class="headerlink" title="4.5.1.toArray"></a>4.5.1.toArray</h4><ul><li><code>toArray()</code>: 返回一个Object[]数组，其中包含Stream中的所有元素。</li><li><code>toArray(IntFunction&lt;A[]&gt; generator)</code>：可以指定返回数组的类型。参数 generator 是一个数组生成器函数，它根据提供的数组长度创建一个新数组。这使得我们可以在返回的数组中指定元素的类型。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; list = List.of(</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>),</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">24</span>),</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">25</span>)</span><br><span class="line">     );</span><br><span class="line">     Object[] array1 =list.stream().toArray();</span><br><span class="line">     System.out.println(Arrays.toString(array1));</span><br><span class="line">     <span class="comment">// 输出：[Person&#123;name = 张三, age = 23&#125;, Person&#123;name = 李四, age = 24&#125;, Person&#123;name = 王五, age = 25&#125;]</span></span><br><span class="line">     Person[] array2 = list.stream().toArray(v -&gt; <span class="keyword">new</span> <span class="title class_">Person</span>[v]);</span><br><span class="line">     System.out.println(Arrays.toString(array2));</span><br><span class="line">     <span class="comment">// 输出：[Person&#123;name = 张三, age = 23&#125;, Person&#123;name = 李四, age = 24&#125;, Person&#123;name = 王五, age = 25&#125;]</span></span><br></pre></td></tr></table></figure></div><h4 id="4-5-2-toList"><a href="#4-5-2-toList" class="headerlink" title="4.5.2.toList"></a>4.5.2.toList</h4><ul><li><code>toList()</code>: 返回一个包含Stream中所有元素的List。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Stream.of(<span class="number">32</span>, <span class="number">11</span>, <span class="number">23</span>, <span class="number">434</span>, <span class="number">54</span>).toList();</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// 输出：[32, 11, 23, 434, 54]</span></span><br></pre></td></tr></table></figure></div><h4 id="4-5-3-collect"><a href="#4-5-3-collect" class="headerlink" title="4.5.3.collect"></a>4.5.3.collect</h4><ul><li><code>collect(Collector&lt;? super T, A, R&gt; collector)</code>: 将Stream中的元素收集到一个容器中，并返回该容器。</li></ul><h5 id="4-5-3-1-统计"><a href="#4-5-3-1-统计" class="headerlink" title="4.5.3.1.统计"></a>4.5.3.1.统计</h5><ul><li><code>Collectors.counting()</code>: 返回流中元素的个数。</li><li><code>Collectors.summingInt(ToIntFunction&lt;? super T&gt; mapper)</code>: 返回流中元素的和。</li><li><code>Collectors.summingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code>: 返回流中元素的和。</li><li><code>Collectors.summingLong(ToLongFunction&lt;? super T&gt; mapper)</code>: 返回流中元素的和。</li><li><code>Collectors.averagingInt(ToIntFunction&lt;? super T&gt; mapper)</code>: 返回流中元素的平均值。</li><li><code>Collectors.averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code>: 返回流中元素的平均值。</li><li><code>Collectors.averagingLong(ToLongFunction&lt;? super T&gt; mapper)</code>: 返回流中元素的平均值。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 个数</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">collect</span> <span class="operator">=</span> numbers.stream().collect(Collectors.counting());</span><br><span class="line">System.out.println(<span class="string">&quot;collect = &quot;</span> + collect);<span class="comment">// collect = 5</span></span><br><span class="line"><span class="comment">// 求和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream().collect(Collectors.summingInt(Integer::intValue));</span><br><span class="line">System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum);<span class="comment">// Sum: 15</span></span><br><span class="line"><span class="comment">// 平均值</span></span><br><span class="line"><span class="type">double</span> <span class="variable">average</span> <span class="operator">=</span> numbers.stream().collect(Collectors.averagingInt(Integer::intValue));</span><br><span class="line">System.out.println(<span class="string">&quot;Average: &quot;</span> + average);<span class="comment">// Average: 3.0</span></span><br></pre></td></tr></table></figure></div><h5 id="4-5-3-2分组"><a href="#4-5-3-2分组" class="headerlink" title="4.5.3.2分组"></a>4.5.3.2分组</h5><ul><li><code>Collectors.groupingBy(Function&lt;? super T, ? extends K&gt; classifier)</code>: 根据给定的分类函数对Stream中的元素进行分组，并返回一个Map，其中键是分类函数的结果，值是包含对应分类的元素的List。</li><li><code>Collectors.partitioningBy(Predicate&lt;? super T&gt; predicate)</code>: 根据给定的断言函数对Stream中的元素进行分区，并返回一个Map，其中键是true和false，值是包含对应分类的元素的List。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按单词的首字母分组</span></span><br><span class="line">Map&lt;Character, List&lt;String&gt;&gt; groupedByFirstLetter = words.stream()</span><br><span class="line">        .collect(Collectors.groupingBy(word -&gt; word.charAt(<span class="number">0</span>)));</span><br><span class="line">System.out.println(<span class="string">&quot;Grouped by first letter: &quot;</span> + groupedByFirstLetter);</span><br><span class="line"><span class="comment">// 输出：Grouped by first letter: &#123;a=[apple], b=[banana], c=[cherry], g=[grape], o=[orange]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按单词的长度进行分区</span></span><br><span class="line">Map&lt;Boolean, List&lt;String&gt;&gt; partitionedByLength = words.stream()</span><br><span class="line">        .collect(Collectors.partitioningBy(word -&gt; word.length() &gt; <span class="number">5</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;Partitioned by length (&gt;5): &quot;</span> + partitionedByLength);</span><br><span class="line"><span class="comment">//输出：Partitioned by length (&gt;5): &#123;false=[apple, grape], true=[banana, orange, cherry]&#125;</span></span><br></pre></td></tr></table></figure></div><h5 id="4-5-3-3连接"><a href="#4-5-3-3连接" class="headerlink" title="4.5.3.3连接"></a>4.5.3.3连接</h5><ul><li><code>Collectors.joining(CharSequence delimiter)</code>: 将stream中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; list = List.of(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">24</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">25</span>)</span><br><span class="line">      );</span><br><span class="line"><span class="type">String</span> <span class="variable">collect</span> <span class="operator">=</span> list.stream().map(p -&gt; p.getName()).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">System.out.println(collect);<span class="comment">// 张三,李四,王五</span></span><br><span class="line">List&lt;String&gt; list1 = List.of(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">collect1</span> <span class="operator">=</span> list1.stream().collect(Collectors.joining(<span class="string">&quot;-&quot;</span>));</span><br><span class="line">System.out.println(collect1);<span class="comment">// A-B-C</span></span><br></pre></td></tr></table></figure></div><h5 id="4-5-3-4-规约"><a href="#4-5-3-4-规约" class="headerlink" title="4.5.3.4.规约"></a>4.5.3.4.规约</h5><p>Collectors类提供的reducing方法，相比于stream本身的reduce方法，增加了对自定义归约的支持。</p><ul><li><strong><code>Collectors.reducing(BinaryOperator&lt;T&gt; op)</code></strong>：这是最基本的 <code>reducing</code> 方法。它接受一个二元运算符，对流中的所有元素进行归约。该方法将返回一个收集器Optional，它使用提供的运算符对流中的元素进行归约。</li><li><strong><code>Collectors.reducing(T identity, BinaryOperator&lt;T&gt; op)</code></strong>：此方法是 <code>reducing</code> 方法的扩展，允许你指定一个初始值。提供的初始值将用作归约操作的起始值。如果流为空，则结果将是提供的初始值。</li><li><strong><code>Collectors.reducing(U identity, Function&lt;? super T, ? extends U&gt; mapper, BinaryOperator&lt;U&gt; op)</code></strong>：这个方法允许你在进行归约之前先将元素映射到另一种类型。你可以指定一个映射函数，并提供一个初始值。然后，它将使用映射函数将元素映射为指定类型，再使用提供的初始值对映射后的结果进行归约。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只传一个参数：定义运算规则</span></span><br><span class="line">System.out.println(list.stream().collect(Collectors.reducing(Integer::sum)));<span class="comment">// Optional[10]</span></span><br><span class="line"><span class="comment">// 等价于：System.out.println(list.stream().reduce(Integer::sum));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递两个参数：定义一个初始值和运算规则</span></span><br><span class="line">System.out.println(list.stream().collect(Collectors.reducing(<span class="number">0</span>, Integer::sum)));<span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 等价于：System.out.println(list.stream().reduce(0, Integer::sum));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递三个参数：定义一个初始值、映射函数和运算规则</span></span><br><span class="line">System.out.println(list.stream().collect(Collectors.reducing(<span class="number">0</span>, x -&gt; x * x, Integer::sum))); <span class="comment">//10</span></span><br><span class="line"><span class="comment">// 等价于：System.out.println(list.stream().map(x -&gt; x * x).reduce(0, Integer::sum));先映射在规约</span></span><br></pre></td></tr></table></figure></div><h5 id="4-5-3-5-归集"><a href="#4-5-3-5-归集" class="headerlink" title="4.5.3.5.归集"></a>4.5.3.5.归集</h5><ul><li><code>Collectors.toList()</code>: 将Stream中的元素收集到一个List中，并返回该List,元素可以重复,有序。</li><li><code>Collectors.toSet()</code>: 将Stream中的元素收集到一个Set中，并返回该Set，元素不能重复，无序</li><li><code>Collectors.toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper)</code>: 将Stream中的元素收集到一个Map中，并返回该Map。如果键重复会抛出 IllegalStateException 异常<ul><li>参数一表示键的生成规则</li><li>参数二表示值的生成规则</li><li><strong>Function</strong><ul><li>泛型一：表示流中每一个数据的类型</li><li>泛型二：表示Map集合中键的数据类型</li></ul></li><li><strong>重写方法apply</strong><ul><li>形参：依次表示流里面的每一个数据</li><li>方法体：生成键&#x2F;值的代码</li><li>返回值：已经生成的键&#x2F;值</li></ul></li></ul></li><li><code>Collectors.toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction)</code>: 收集到 Map 集合中，允许指定一个合并函数来处理键冲突。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list, <span class="string">&quot;张无忌-男-15&quot;</span>, <span class="string">&quot;周芷若-女-14&quot;</span>, <span class="string">&quot;赵敏-女-13&quot;</span>, <span class="string">&quot;张强-男-20&quot;</span>,</span><br><span class="line">        <span class="string">&quot;张三丰-男-100&quot;</span>, <span class="string">&quot;张翠山-男-40&quot;</span>, <span class="string">&quot;张良-男-35&quot;</span>, <span class="string">&quot;王二麻子-男-37&quot;</span>, <span class="string">&quot;谢广坤-男-41&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//收集List集合当中</span></span><br><span class="line"><span class="comment">//需求：</span></span><br><span class="line"><span class="comment">//我要把所有的男性收集起来</span></span><br><span class="line">List&lt;String&gt; newList1 = list.stream()</span><br><span class="line">        .filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(newList1);<span class="comment">// [张无忌-男-15, 张强-男-20, 张三丰-男-100, 张翠山-男-40, 张良-男-35, 王二麻子-男-37, 谢广坤-男-41]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//收集Set集合当中</span></span><br><span class="line"><span class="comment">//需求：</span></span><br><span class="line"><span class="comment">//我要把所有的男性收集起来</span></span><br><span class="line">Set&lt;String&gt; newList2 = list.stream().filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">        .collect(Collectors.toSet());</span><br><span class="line">System.out.println(newList2);<span class="comment">// [张强-男-20, 张良-男-35, 张三丰-男-100, 张无忌-男-15, 谢广坤-男-41, 张翠山-男-40, 王二麻子-男-37]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//收集Map集合当中</span></span><br><span class="line"><span class="comment">//我要把所有的男性收集起来</span></span><br><span class="line"><span class="comment">//键：姓名。 值：年龄</span></span><br><span class="line">Map&lt;String, Integer&gt; map = list.stream()</span><br><span class="line">        .filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))                </span><br><span class="line">        .collect(Collectors.toMap(</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, String&gt;() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Integer&gt;() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> Integer.parseInt(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">2</span>]);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;));</span><br><span class="line">System.out.println(map); <span class="comment">// &#123;张强=20, 张良=35, 张翠山=40, 王二麻子=37, 张三丰=100, 张无忌=15, 谢广坤=41&#125;</span></span><br><span class="line"><span class="comment">// lambda表达式简化</span></span><br><span class="line">Map&lt;String, Integer&gt; map2 = list.stream()</span><br><span class="line">        .filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">        .collect(Collectors.toMap(</span><br><span class="line">                s -&gt; s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>],</span><br><span class="line">                s -&gt; Integer.parseInt(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">2</span>])));</span><br><span class="line"></span><br><span class="line">System.out.println(map2); <span class="comment">// &#123;张强=20, 张良=35, 张翠山=40, 王二麻子=37, 张三丰=100, 张无忌=15, 谢广坤=41&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集到 Map 集合中，处理键冲突</span></span><br><span class="line">List&lt;Person&gt; persons = List.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">35</span>)</span><br><span class="line">        );</span><br><span class="line">Map&lt;String, Integer&gt; personMapWithMergeFunction = persons.stream()</span><br><span class="line">        .collect(Collectors.toMap(Person::getName, Person::getAge, (existing, replacement) -&gt; existing));<span class="comment">// 如果已经存在，保留原先存在的值</span></span><br><span class="line">System.out.println(personMapWithMergeFunction); <span class="comment">// &#123;Alice=30, Bob=25&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="5-stream-vs-parallelStream"><a href="#5-stream-vs-parallelStream" class="headerlink" title="5.stream() vs. parallelStream()"></a>5.stream() vs. parallelStream()</h2><p>1、<strong><code>Stream</code>（串行流）</strong> - 按顺序处理数据，单线程执行。</p><p>2、<strong><code>parallelStream</code>（并行流）</strong> - <strong>并行执行任务</strong>，使用 Fork&#x2F;Join 线程池，适用于大规模数据处理。</p><p><strong>不同点</strong></p><table><thead><tr><th><strong>对比项</strong></th><th><strong>串行流 (<code>stream()</code>)</strong></th><th><strong>并行流 (<code>parallelStream()</code>)</strong></th></tr></thead><tbody><tr><td><strong>执行方式</strong></td><td>单线程，顺序执行</td><td>多线程，并行执行</td></tr><tr><td><strong>顺序保证</strong></td><td><strong>保持数据原始顺序</strong></td><td><strong>顺序不可预测</strong></td></tr><tr><td><strong>适用场景</strong></td><td>小数据量，顺序重要的任务</td><td>大数据量，计算密集型任务</td></tr><tr><td><strong>底层实现</strong></td><td>普通迭代</td><td>Fork&#x2F;Join 线程池</td></tr><tr><td><strong>线程安全</strong></td><td>无需额外同步</td><td>需考虑<strong>共享资源竞争</strong></td></tr><tr><td><strong>性能</strong></td><td><strong>小数据量快</strong></td><td><strong>大数据量提升明显</strong></td></tr><tr><td><strong>开销</strong></td><td>低，适合简单操作</td><td>线程管理开销较大</td></tr></tbody></table><p><strong>如何选择</strong></p><table><thead><tr><th>适用场景</th><th>推荐使用</th></tr></thead><tbody><tr><td><strong>数据量较小（&lt;1000条）</strong></td><td><code>stream()</code></td></tr><tr><td><strong>顺序重要，如日志、事务处理</strong></td><td><code>stream()</code></td></tr><tr><td><strong>计算密集型任务，如矩阵运算</strong></td><td><code>parallelStream()</code></td></tr><tr><td><strong>大数据集（&gt;10万条），CPU 计算密集</strong></td><td><code>parallelStream()</code></td></tr><tr><td><strong>任务间无共享状态（无竞争资源）</strong></td><td><code>parallelStream()</code></td></tr><tr><td><strong>IO 操作、数据库查询（非 CPU 计算）</strong></td><td><code>stream()</code></td></tr></tbody></table><p><strong>🚨 <code>parallelStream()</code> 什么时候</strong>不<strong>适用？</strong></p><ul><li><strong>数据量小</strong>（线程管理开销 &gt; 计算开销）。</li><li><strong>任务有共享状态</strong>（可能会导致数据竞争）。</li><li><strong>IO 任务</strong>（如文件读写、数据库查询）<strong>通常不适合并行流</strong>，可能会增加开销。</li><li><strong>必须保证顺序的任务</strong>（<code>parallelStream()</code> 不能保证顺序）。</li></ul><p><strong><code>parallelStream()</code> 并行度控制</strong></p><p>默认情况下，<code>parallelStream()</code> 使用 <strong><code>ForkJoinPool</code> 线程池</strong>，线程数等于 <strong>CPU 核心数</strong>（<code>Runtime.getRuntime().availableProcessors()</code>）。</p><p>如果想<strong>控制并行线程数</strong>，可以使用 <code>ForkJoinPool</code>：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParallelStreamCustomThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 限制线程池大小（2个线程）</span></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">customPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">2</span>);</span><br><span class="line">        customPool.submit(() -&gt;</span><br><span class="line">            list.parallelStream().forEach(i -&gt; </span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - &quot;</span> + i)</span><br><span class="line">            )</span><br><span class="line">        ).join();</span><br><span class="line"></span><br><span class="line">        customPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>🔹 <strong>输出（并行但受限于 2 个线程）：</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool-1-worker-1 - 1</span><br><span class="line">ForkJoinPool-1-worker-2 - 2</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><ul><li>这样可以<strong>避免并行流过度占用 CPU 资源</strong>，提升系统稳定性。</li></ul><p><strong><code>Stream</code> 转换 <code>ParallelStream</code></strong></p><p>如果你已经有一个串行流，但希望在中途切换成<strong>并行处理</strong>，可以使用 <code>parallel()</code> 方法：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>);</span><br><span class="line"></span><br><span class="line">list.stream()</span><br><span class="line">    .parallel() <span class="comment">// 切换为并行流</span></span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure></div><p><strong>🚨 注意：</strong></p><ul><li><code>stream().parallel()</code> 和 <code>parallelStream()</code> <strong>效果相同</strong>。</li><li>但 <code>parallel()</code> 允许你动态切换，而 <code>parallelStream()</code> 直接创建的是并行流。</li></ul><p>如果想要从 <strong>并行流切换回串行流</strong>，可以使用 <code>sequential()</code>：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.parallelStream()</span><br><span class="line">    .sequential() <span class="comment">// 切换回串行流</span></span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure></div><p><strong>🚨 注意</strong></p><ul><li><p><strong>默认并行线程数 &#x3D; CPU 核心数</strong>（可能会影响系统性能）。</p></li><li><p><strong>并行流不能保证顺序</strong>，如果需要顺序输出，使用 <code>forEachOrdered()</code>：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.parallelStream().forEachOrdered(System.out::println);</span><br></pre></td></tr></table></figure></div></li><li><p><strong>如果共享资源竞争严重</strong>，考虑使用 <strong>线程池 + <code>CompletableFuture</code></strong> 代替 <code>parallelStream()</code>。</p></li></ul><h2 id="6-Java-Stream-底层实现"><a href="#6-Java-Stream-底层实现" class="headerlink" title="6.Java Stream 底层实现"></a>6.Java Stream 底层实现</h2><p><strong>参考文章：</strong><a class="link" target="_blank" rel="noopener" href="https://www.cnblogs.com/CarpenterLee/p/6637118.html">深入理解Java Stream流水线<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>Title:</strong> Stream流</li><li><strong>Author:</strong> Lu</li><li><strong>Created at :</strong> 2024-05-06 21:22:21</li><li><strong>Updated at :</strong> 2025-03-28 16:27:44</li><li><strong>Link:</strong> https://lusy.ink/2024/05/06/Stream流/</li><li><strong>License: </strong>This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">#学习总结</a>&nbsp;</li><li class="tag-item mx-0.5"><a href="/tags/Java/">#Java</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/2024/05/21/JDBC/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item">JDBC</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/2024/05/01/Java-IO%E6%B5%81/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">Java IO流</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div><div class="comment-container px-2 sm:px-6 md:px-8 pb-8"><div class="comments-container mt-10 w-full"><div id="comment-anchor" class="w-full h-2.5"></div><div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">Comments</div><div id="waline"></div><script type="module" data-swup-reload-script>import{init}from"/js/libs/waline.mjs";function loadWaline(){init({el:"#waline",serverURL:"https://comment.lusy.ink",lang:"zh-CN",dark:'body[class~="dark-mode"]',reaction:!1,requiredMeta:["nick","mail"],emoji:[]})}"undefined"!=typeof swup?loadWaline():window.addEventListener("DOMContentLoaded",loadWaline)</script></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">On this page</div><div class="page-title">Stream流</div><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-Stream%E6%B5%81"><span class="nav-text">Java Stream流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-text">1.概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%A6%82%E5%BF%B5"><span class="nav-text">1.1.概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Stream%E6%B5%81%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-text">1.2.Stream流的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Stream%E6%B5%81%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">1.3.Stream流的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-Stream%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="nav-text">1.4.Stream流的使用步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Stream%E7%9A%84%E7%94%9F%E6%88%90"><span class="nav-text">2.Stream的生成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Collection-stream-%E3%80%81Collection-parallelStream"><span class="nav-text">2.1.Collection.stream()、Collection.parallelStream()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Arrays-stream"><span class="nav-text">2.2.Arrays.stream()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Stream%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-text">2.3.Stream的静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA"><span class="nav-text">2.4.文件创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E5%85%B6%E4%BB%96"><span class="nav-text">2.5.其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="nav-text">3.中间操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E7%AD%9B%E9%80%89%E3%80%81%E5%8E%BB%E9%87%8D"><span class="nav-text">3.1.筛选、去重</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%98%A0%E5%B0%84"><span class="nav-text">3.2.映射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-map-%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-text">3.2.1.map() 方法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-flatMap-%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-text">3.2.2.flatMap() 方法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-map-%E5%92%8CflatMap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">3.2.3.map()和flatMap()的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%8E%92%E5%BA%8F"><span class="nav-text">3.3.排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E8%B7%B3%E8%BF%87%E3%80%81%E6%88%AA%E5%8F%96"><span class="nav-text">3.4.跳过、截取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E7%BB%93%E5%90%88"><span class="nav-text">3.5.结合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E8%B0%83%E8%AF%95"><span class="nav-text">3.6.调试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-1-%E5%AF%B9%E6%B5%81%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E9%81%8D%E5%8E%86"><span class="nav-text">3.6.1.对流中的元素进行遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-2-%E5%AF%B9%E6%B5%81%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9"><span class="nav-text">3.6.2.对流中的对象进行修改</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-3-peek-%E6%96%B9%E6%B3%95%E7%9A%84%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="nav-text">3.6.3.peek()方法的时序图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-4-peek-%E6%96%B9%E6%B3%95%E7%9A%84%E5%9D%91"><span class="nav-text">3.6.4.peek()方法的坑</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%BB%88%E7%BB%93%E6%93%8D%E4%BD%9C"><span class="nav-text">4.终结操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E9%81%8D%E5%8E%86"><span class="nav-text">4.1.遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%8C%B9%E9%85%8D"><span class="nav-text">4.2.匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E8%A7%84%E7%BA%A6"><span class="nav-text">4.3.规约</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E8%81%9A%E5%90%88"><span class="nav-text">4.4.聚合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E6%94%B6%E9%9B%86"><span class="nav-text">4.5.收集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-1-toArray"><span class="nav-text">4.5.1.toArray</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-2-toList"><span class="nav-text">4.5.2.toList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-3-collect"><span class="nav-text">4.5.3.collect</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-3-1-%E7%BB%9F%E8%AE%A1"><span class="nav-text">4.5.3.1.统计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-3-2%E5%88%86%E7%BB%84"><span class="nav-text">4.5.3.2分组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-3-3%E8%BF%9E%E6%8E%A5"><span class="nav-text">4.5.3.3连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-3-4-%E8%A7%84%E7%BA%A6"><span class="nav-text">4.5.3.4.规约</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-3-5-%E5%BD%92%E9%9B%86"><span class="nav-text">4.5.3.5.归集</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-stream-vs-parallelStream"><span class="nav-text">5.stream() vs. parallelStream()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Java-Stream-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-text">6.Java Stream 底层实现</span></a></li></ol></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2024</span> - 2025&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">Lu</a><p class="post-count space-x-0.5"><span>25 posts in total </span><span>175.5k words in total</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">VISITOR COUNT</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">TOTAL PAGE VIEWS</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span> <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span></div><div>Blog up for <span class="odometer" id="runtime_days"></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Swup.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupSlideTheme.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScriptsPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupProgressPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScrollPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/imageViewer.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/utils.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/main.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/navbarShrink.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/scrollTopBottom.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/lightDarkSwitch.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/categoryList.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/localSearch.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/codeBlock.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/lazyload.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/runtime.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/odometer.min.js"></script><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/assets/odometer-theme-minimal.css"><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Typed.min.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/typed.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/tabs.js" data-swup-reload-script></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/essays.js" data-swup-reload-script></script></body></html>