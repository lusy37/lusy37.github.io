<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="referrer" content="no-referrer"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Hexo Theme Redefine"><meta name="author" content="Lu"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://registry.npmmirror.com" crossorigin><link rel="canonical" href="https://lusy37.github.io/2024/05/21/mysql基础/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:type" content="article"><meta property="og:title" content="MySQL基础"><meta property="og:url" content="https://lusy37.github.io/2024/05/21/MySQL%E5%9F%BA%E7%A1%80/index.html"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://lusy37.github.io/images/redefine-og.webp"><meta property="article:published_time" content="2024-05-21T07:45:35.000Z"><meta property="article:modified_time" content="2025-03-14T07:04:13.303Z"><meta property="article:author" content="Lu"><meta property="article:tag" content="MySQL"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://lusy37.github.io/images/redefine-og.webp"><link rel="icon" type="image/png" href="/images/redefine-favicon.jpg" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.jpg"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="/images/redefine-favicon.jpg"><title>MySQL基础 | Lusy</title><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Chillax/chillax.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/css/build/tailwind.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Geist/geist.css"><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/anime.min.js"></script><script id="hexo-configurations">window.config={hostname:"lusy37.github.io",root:"/",language:"en",path:"search.xml"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,delete_mask:!1,title_alignment:"left",headings_top_spacing:{h1:"3.2rem",h2:"2.4rem",h3:"1.9rem",h4:"1.6rem",h5:"1.4rem",h6:"1.3rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",highlight_theme:{light:"github",dark:"vs2015"},font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:6,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,pangu_js:!1,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#A31F34",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null},title:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!0},scroll_progress:{bar:!1,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:{enable:!0,custom_message:null},open_graph:{enable:!0,image:"/images/redefine-og.webp",description:"Hexo Theme Redefine, Redefine Your Hexo Journey."},google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/wallhaven-wqery6-light.webp",dark:"/images/wallhaven-wqery6-dark.webp"},title:"等一场花开",subtitle:{text:["迷失的人迷失了，相遇的人再相遇","迷い人はまた迷い、巡り逢うべき人とは再び巡り逢う"],hitokoto:{enable:!1,show_author:!1,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!1,style:"default",links:{github:null,instagram:null,zhihu:null,twitter:null,email:null},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{enable:!1,type:"fixed",audios:[{name:null,artist:null,url:null,cover:null,lrc:null}]},mermaid:{enable:!1,version:"11.4.1"}},version:"2.8.2",navbar:{auto_hide:!1,color:{left:"#f78736",right:"#367df7",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-regular fa-house"},Essays:{path:"/essays",icon:"fa-regular fa-pen-to-square"},Think:{path:"/think",icon:"fa-regular fa-paper-plane"}},search:{enable:!0,preload:!0}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:"If its rainy, you won't see me.If its sunny ,you'll think of me.",show_on_mobile:!0,links:{Archives:{path:"/archives",icon:"fa-regular fa-archive"},Tags:{path:"/tags",icon:"fa-regular fa-tags"},Categories:{path:"/categories",icon:"fa-regular fa-folder"}}},article_date_format:"YYYY-MM-DD",excerpt_length:200,categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2024/2/12 15:45:14"},window.lang_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},window.data={masonry:!1}</script><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/brands.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/solid.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/regular.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span></div><style>:root{--preloader-background-color:#fff;--preloader-text-color:#000}@media (prefers-color-scheme:dark){:root{--preloader-background-color:#202124;--preloader-text-color:#fff}}@media (prefers-color-scheme:light){:root{--preloader-background-color:#fff;--preloader-text-color:#000}}@media (max-width:600px){.ml13{font-size:2.6rem!important}}.preloader{display:flex;flex-direction:column;gap:1rem;align-items:center;justify-content:center;position:fixed;padding:12px;top:0;right:0;bottom:0;left:0;width:100vw;height:100vh;background-color:var(--preloader-background-color);z-index:1100;transition:opacity .2s ease-in-out}.ml13{font-size:3.2rem;color:var(--preloader-text-color);letter-spacing:-1px;font-weight:500;font-family:Chillax-Variable,sans-serif;text-align:center}.ml13 .word{display:inline-flex;flex-wrap:wrap;white-space:nowrap}.ml13 .letter{display:inline-block;line-height:1em}</style><div class="preloader"><h2 class="ml13">Lusy</h2><script>var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });

        var animation = anime.timeline({ loop: true })
            .add({
                targets: '.ml13 .letter',
                translateY: [20, 0],
                translateZ: 0,
                opacity: [0, 1],
                filter: ['blur(5px)', 'blur(0px)'],
                easing: "easeOutExpo",
                duration: 1200,
                delay: (el, i) => 300 + 20 * i,
            })
            .add({
                targets: '.ml13 .letter',
                translateY: [0, -20],
                opacity: [1, 0],
                filter: ['blur(0px)', 'blur(5px)'],
                easing: "easeInExpo",
                duration: 1000,
                delay: (el, i) => 15 * i,
                complete: function() {
                    hidePreloader();
                }
            }, '-=700');


        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            setTimeout(hidePreloader, 5000); // Call hidePreloader after 5000 milliseconds if not already called by animation
        });

        function hidePreloader() {
            var preloader = document.querySelector('.preloader');
            preloader.style.opacity = '0';
            setTimeout(function () {
                preloader.style.display = 'none';
            }, 200);
        }</script></div><main class="page-container" id="swup"><div class="main-content-container flex flex-col justify-between min-h-dvh"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content transition-navbar"><div class="left"><a class="logo-title" href="/">Lusy</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house fa-fw"></i> HOME</a></li><li class="navbar-item"><a href="/essays"><i class="fa-regular fa-pen-to-square fa-fw"></i> ESSAYS</a></li><li class="navbar-item"><a href="/think"><i class="fa-regular fa-paper-plane fa-fw"></i> THINK</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>HOME </span><i class="fa-regular fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/essays"><span>ESSAYS </span><i class="fa-regular fa-pen-to-square fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/think"><span>THINK </span><i class="fa-regular fa-paper-plane fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/archives"><span>Archives</span> <i class="fa-regular fa-archive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/tags"><span>Tags</span> <i class="fa-regular fa-tags fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/categories"><span>Categories</span> <i class="fa-regular fa-folder fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">9</div><div class="label text-third-text-color text-sm">Tags</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">5</div><div class="label text-third-text-color text-sm">Categories</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">24</div><div class="label text-third-text-color text-sm">Posts</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body transition-fade-up"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">MySQL基础</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="/images/redefine-avatar.jpg"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">Lu</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv3</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2024-05-21 15:45:35</span> <span class="mobile">2024-05-21 15:45:35</span> <span class="hover-info">Created</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2025-03-14 15:04:13</span> <span class="mobile">2025-03-14 15:04:13</span> <span class="hover-info">Updated</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/MySQL/">MySQL</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/MySQL/">MySQL</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fa-regular fa-typewriter"></i>&nbsp;<span>20.5k Words</span> </span><span class="article-min2read article-meta-item"><i class="fa-regular fa-clock"></i>&nbsp;<span>77 Mins</span> </span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><h1 id="SQL基本命令"><a href="#SQL基本命令" class="headerlink" title="SQL基本命令"></a>SQL基本命令</h1><h2 id="启动与连接"><a href="#启动与连接" class="headerlink" title="启动与连接"></a>启动与连接</h2><ul><li><p>MySQL启动</p><p>启动MySQL：<code>net start mysql</code></p><p>停止MySQL：<code>net stop mysql</code></p><blockquote><p>这里的<code>mysql</code>是服务的名称，每个人可以自定义，初始化的名称是<code>mysql80</code></p></blockquote></li><li><p>MySQL客户端连接</p><p>MySQL自带的客户端命令行</p><p><code>mysql -u username -p [-h hostname] [-P port]</code></p><blockquote><p>-u username：用于指定用户名，比如：-u root</p><p>-p：用于提示输入密码</p><p>-h hostname：用于指定MySQL服务器的主机名或IP地址的选项，默认是<code>localhost</code></p><p>-P port：指定MySQL服务器的端口号，默认端口号是<code>3306</code></p></blockquote></li></ul><h2 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h2><ol><li>SQL语句可以单行或多行书写，<strong>以分号结尾</strong></li><li>SQL语句可以使用空格&#x2F;缩进来增强语句的可读性</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写</li><li>注释：<ul><li>单行注释：– 注释内容 或 # 注释内容(MySQL特有)</li><li>多行注释：&#x2F;* 注释内容 *&#x2F;</li></ul></li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>数值类型</li></ul><table><thead><tr><th>类型</th><th>大小(byte)</th><th>有符号(SIGNED)范围</th><th>无符号(UNSIGNED)范围</th><th>描述</th><th align="left">备注</th></tr></thead><tbody><tr><td><code>tinyint</code></td><td>1</td><td>(-128，127)</td><td>(0，255)</td><td>小整数值</td><td align="left"></td></tr><tr><td>smallint</td><td>2</td><td>(-32768，32767)</td><td>(0，65535)</td><td>大整数值</td><td align="left"></td></tr><tr><td>mediumint</td><td>3</td><td>(-8388608，8388607)</td><td>(0，16777215)</td><td>大整数值</td><td align="left"></td></tr><tr><td><code>int</code></td><td>4</td><td>(-2147483648，2147483647)</td><td>(0，4294967295)</td><td>大整数值</td><td align="left"></td></tr><tr><td><code>bigint</code></td><td>8</td><td>(-2^63，2^63-1)</td><td>(0，2^64-1)</td><td>极大整数值</td><td align="left"></td></tr><tr><td>float</td><td>4</td><td>(-3.402823466 E+38，3.402823466351 E+38)</td><td>0 和 (1.175494351 E-38，3.402823466 E+38)</td><td>单精度浮点数值</td><td align="left">float(5,2)：5表示整个数字长度，2 表示小数位个数</td></tr><tr><td>double</td><td>8</td><td>(-1.7976931348623157 E+308，1.7976931348623157 E+308)</td><td>0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308)</td><td>双精度浮点数值</td><td align="left">double(5,2)：5表示整个数字长度，2 表示小数位个数</td></tr><tr><td><code>decimal</code></td><td></td><td></td><td></td><td>小数值(精度更高)</td><td align="left">decimal(5,2)：5表示整个数字长度，2 表示小数位个数</td></tr></tbody></table><ul><li>字符串类型</li></ul><table><thead><tr><th>类型</th><th>大小</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>char</code></td><td>0-255 bytes</td><td>定长字符串</td><td>char(10): 最多只能存10个字符,不足10个字符,占用10个字符空间【性能高，浪费空间】</td></tr><tr><td><code>varchar</code></td><td>0-65535 bytes</td><td>变长字符串</td><td>varchar(10): 最多只能存10个字符,不足10个字符, 按照实际长度存储【性能低，节省空间】（实际上还会在数据库中单独开辟一个字符的空间，记录实际长度）</td></tr><tr><td>tinyblob</td><td>0-255 bytes</td><td>不超过255个字符的二进制数据</td><td></td></tr><tr><td>tinytext</td><td>0-255 bytes</td><td>短文本字符串</td><td></td></tr><tr><td>blob</td><td>0-65535 bytes</td><td>二进制形式的长文本数据</td><td></td></tr><tr><td>text</td><td>0-65535 bytes</td><td>长文本数据</td><td></td></tr><tr><td>mediumblob</td><td>0-16777215 bytes</td><td>二进制形式的中等长度文本数据</td><td></td></tr><tr><td>mediumtext</td><td>0-16777215 bytes</td><td>中等长度文本数据</td><td></td></tr><tr><td>longblob</td><td>0-4294967295 bytes</td><td>二进制形式的极大文本数据</td><td></td></tr><tr><td>longtext</td><td>0-4294967295 bytes</td><td>极大文本数据</td><td></td></tr></tbody></table><ul><li>日期时间类型</li></ul><table><thead><tr><th>类型</th><th>大小(byte)</th><th>范围</th><th>格式</th><th>描述</th></tr></thead><tbody><tr><td><code>date</code></td><td>3</td><td>1000-01-01 至 9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>time</td><td>3</td><td>-838:59:59 至 838:59:59</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>year</td><td>1</td><td>1901 至 2155</td><td>YYYY</td><td>年份值</td></tr><tr><td><code>datetime</code></td><td>8</td><td>1000-01-01 00:00:00 至 9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>timestamp</td><td>4</td><td>1970-01-01 00:00:01 至 2038-01-19 03:14:07</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><h2 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL(数据定义语言)"></a>DDL(数据定义语言)</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><ul><li><p>创建</p><ul><li>创建数据库：<code>create database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序规则]</code></li></ul><blockquote><p>在 MySQL 中，当你使用特殊符号、关键字或空格来命名数据库时，需要使用反引号 &#96; 符号括起来，而不是单引号。单引号通常用于字符串值，而反引号用于标识数据库对象名称。</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> `数据库名`;</span><br></pre></td></tr></table></figure></div></blockquote></li><li><p>使用</p><ul><li>使用数据库：<code>use 数据库名</code></li></ul></li><li><p>查询</p><ul><li><p>查询所有数据库：<code>show databases</code></p></li><li><p>查询当前数据库：<code>select database()</code></p></li></ul></li><li><p>修改数据库编码</p><ul><li>修改某个数据库字符编码：<code>alter database 数据库名 character set / charset 字符编码</code></li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> database mydb1 <span class="keyword">character set</span> utf8</span><br></pre></td></tr></table></figure></div><blockquote><p>修改数据库 mydb1 的编码为 utf8。注意，在 MySQL 中所有的 UTF-8 编码都<br>不能使用中间的<code>&quot;-&quot;</code>，即 UTF-8 要书写为 UTF8。</p><p><strong>注意</strong>：数据库的字符集不建议设置为utf8，因为这里的utf8只能是3个字节的，而数据库中存在一些数据是4个字节的，最好设置为<code>utf8mb4</code></p></blockquote></li><li><p>删除</p><ul><li>删除数据库：<code>drop database [ if exists ] 数据库名</code></li></ul></li></ul><blockquote><p>上述语法中的<code>database</code>，也可以替换成 <code>schema</code>，如：<code>create schema db01;</code></p></blockquote><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><ul><li><p>创建</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名(</span><br><span class="line">    字段<span class="number">1</span> 字段类型 [约束] [comment 字段<span class="number">1</span>注释],</span><br><span class="line">    ……</span><br><span class="line">    字段n 字段类型 [约束] [comment 字段n注释]</span><br><span class="line">)[comment 表标注];</span><br></pre></td></tr></table></figure></div></li><li><p>查询</p><ul><li>查询当前数据库所有表：<code>show tables</code></li><li>查询表结构：<code>desc 表名</code></li><li>查询创建表的SQL语句：<code>show create table 表名</code></li></ul></li><li><p>修改</p><ul><li>添加字段：<code>alter table 表名 add 字段名 数据类型 [comment 注释]</code></li><li>修改字段的数据类型：<code>alter table 表名 modify 字段名 新数据类型 [约束] [comment 新字段注释]</code> <strong>【字段的约束和注释并不会被继承下来】</strong></li><li>修改字段名和数据类型：<code>alter table 表名 change 旧字段名 新字段名 新数据类型 [约束] [comment 新字段注释]</code><strong>【旧字段的约束和注释并不会被继承下来】</strong></li><li>删除字段：<code>alter table 表名 drop column 字段名</code></li><li>修改表名：<code>rename table 表名 to 新表名</code></li></ul><blockquote><p>在修改字段名或数据类型的时候，若表中已经存在数据，修改成不能兼容原先数据的数据类型的话会报错。因此，在修改字段的数据类型时，你需要考虑到已有数据的情况，并确保新的数据类型与现有数据兼容。如果需要更改数据类型，最好先对现有数据进行备份或转换，然后再进行数据类型修改。</p></blockquote></li><li><p>删除</p><ul><li>删除表：<code>drop table [ if exists ] 表名</code><strong>【在删除表时，表中的全部数据也会被删除】</strong></li><li>删除并重建该表：<code>truncate table 表名</code></li></ul></li></ul><h2 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML(数据操作语言)"></a>DML(数据操作语言)</h2><h3 id="插入数据-INSERT"><a href="#插入数据-INSERT" class="headerlink" title="插入数据(INSERT)"></a>插入数据(INSERT)</h3><ul><li>指定字段添加数据：<code>insert into 表名 (字段名1，字段名2……) values (值1，值2……)</code></li><li>全部字段添加数据：<code>insert into 表名 values (值1，值2……)</code></li><li>批量添加数据( 指定字段 )：<code>insert into 表名 (字段名1，字段名2……) values (值1，值2……)，(值1，值2……)</code></li><li>批量添加数据( 全部字段 )：<code>insert into 表名 values (值1，值2……)，(值1，值2……)</code></li></ul><blockquote><p><strong>注意事项：</strong></p><ol><li>插入数据时，指定的字段顺序需要与值的顺序一一对应。</li><li>字符串和日期型数据应该包含在引号中。</li><li>插入的数据大小，应该在字段的规定范围内。</li></ol></blockquote><h3 id="修改数据-UPDATE"><a href="#修改数据-UPDATE" class="headerlink" title="修改数据(UPDATE)"></a>修改数据(UPDATE)</h3><ul><li>修改数据：<code>update 表名 set 字段名1 = 值1，字段名2 = 值2，… [where 条件]</code></li></ul><blockquote><p><strong>注意事项：</strong><br>修改语句的条件可以有，也可以没有。如果没有条件，则会修改整张表的所有数据。</p></blockquote><h3 id="删除数据-DELETE"><a href="#删除数据-DELETE" class="headerlink" title="删除数据(DELETE)"></a>删除数据(DELETE)</h3><ul><li>删除数据：<code>delete from 表名 [where 条件]</code></li></ul><blockquote><p><strong>注意事项：</strong></p><ol><li>delete语句的条件可以有，也可以没有。如果没有条件，则会删除整张表的所有数据。</li><li>delete语句不能删除某一个字段的值（如果要操作，可以使用UPDATE，将该字段的值设置为NULL）</li></ol></blockquote><h2 id="DQL-数据查询语言"><a href="#DQL-数据查询语言" class="headerlink" title="DQL(数据查询语言)"></a>DQL(数据查询语言)</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>将一列数据作为一个整体，进行纵向计算。</p><p>常见聚合函数</p><table><thead><tr><th align="left">函数</th><th>功能</th></tr></thead><tbody><tr><td align="left">count</td><td>统计数量</td></tr><tr><td align="left">max</td><td>最大值</td></tr><tr><td align="left">min</td><td>最小值</td></tr><tr><td align="left">avg</td><td>平均值</td></tr><tr><td align="left">sum</td><td>求和</td></tr></tbody></table><p>语法：<br><code>select 聚合函数(字段列表) from 表名;</code><br><strong>【注意：null值不参与所有聚合函数运算】</strong></p><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>语法：<br><code>select 字段列表 from 表名 where 条件列表;</code></p><p>条件：</p><table><thead><tr><th>比较运算符</th><th>功能</th><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;，&gt;&#x3D;，&lt;，&lt;&#x3D;，&#x3D;</td><td>大于、小于、等于</td><td>and 或 &amp;&amp;</td><td>并且(多条件同时成立)</td></tr><tr><td>&lt;&gt; 或 !&#x3D;</td><td>不等于</td><td>or 或 ||</td><td>或者(多条件成立一个)</td></tr><tr><td>between…and…</td><td>在某个范围之内(闭区间)</td><td>not 或 !</td><td>非，不是</td></tr><tr><td>in(…，…)</td><td>在in之后的列表中的值，多选一</td><td></td><td></td></tr><tr><td>like ‘占位符’</td><td>模糊匹配( _匹配单个字符，%匹配任意个字符)</td><td></td><td></td></tr><tr><td>is null &#x2F; is not null</td><td>是null &#x2F; 不是null</td><td></td><td></td></tr></tbody></table><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p>语法：<br><code>select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后的过滤条件]</code></p><blockquote><p>where 与 having 区别：</p><ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件的不参与分组；<br>而having是分组之后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以在后面跟上聚合函数进行判断</li></ul><p><strong>注意：</strong><br>1.执行顺序：where &gt; 聚合函数 &gt; having<br>2.分组之后，查询的字段一般为聚合函数和分组字段，查询其它字段无任何意义</p></blockquote><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p>语法：<br><code>select 字段列表 from 表名 order by (字段1 排序方式1，字段2 排序方式2)</code></p><p>排序方式：<br><code>asc</code>：升序(默认值)<br><code>desc</code>：降序</p><p>排序类型：<br>1.<strong>数字排序</strong>：对数值类型的数据进行升序或降序排序<br>2.<strong>字符串排序</strong>：对字符类型的数据进行字典序的升序或降序排序<br>3.<strong>日期排序</strong>：对日期和时间类型的数据进行升序或降序排序<br>4.<strong>布尔值排序</strong>：对布尔类型的数据进行升序或降序排序（<code>false</code>被认为小于<code>true</code>）</p><blockquote><p><strong>注意：</strong></p><ul><li>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。</li><li>当排序字段值相同时，默认情况下MySQL会按照记录在表中的物理存储顺序返回结果。</li></ul></blockquote><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>语法：<br><code>select 字段列表 from 表名 limit 起始索引，查询记录数</code></p><blockquote><p><strong>注意：</strong></p><ul><li>起始索引从 0 开始，起始索引 &#x3D; （查询页码 - 1）* 每页显示的记录数</li><li>分页查询是数据库的方言。不同的数据库有不同的实现，MySQL中是 limit</li><li>如果查询的是第一页，起始索引可以省略，直接简写为 limit 10</li></ul></blockquote><h2 id="DCL-数据控制语言"><a href="#DCL-数据控制语言" class="headerlink" title="DCL(数据控制语言)"></a>DCL(数据控制语言)</h2><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><ol><li><p>查询用户</p><ul><li><code>select user ，host from mysql.user;</code></li></ul></li><li><p>创建用户</p><ul><li><code>create user &#39;用户名&#39;@&#39;主机名&#39; identified by &#39;密码&#39;;</code></li></ul></li><li><p>修改用户密码</p><ul><li><code>alter user &#39;用户名&#39;@&#39;主机名&#39; identified with mysql_native_password by &#39;新密码&#39;;</code></li></ul><blockquote><p><strong>注意：</strong></p><ul><li>在MySQL 5.7及之前版本中，<code>WITH mysql_native_password</code> 可以省略，系统会默认使用 <code>mysql_native_password</code> 插件。</li><li>在MySQL 8.0及以上版本中，省略 <code>WITH mysql_native_password</code> 时，系统会默认使用 <code>caching_sha2_password</code> 插件。如果希望使用 <code>mysql_native_password</code> 插件，则需要显式指定。</li></ul></blockquote></li><li><p>删除用户</p><ul><li><code>drop user &#39;用户名&#39;@&#39;主机名&#39;;</code></li></ul></li></ol><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><ol><li>查询权限<ul><li><code>show grants for &#39;用户名&#39;@&#39;主机名&#39;;</code></li></ul></li><li>授予权限<ul><li><code>grant 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></li></ul></li><li>撤销权限<ul><li><code>revoke 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></li></ul></li></ol><h3 id="常用权限"><a href="#常用权限" class="headerlink" title="常用权限"></a>常用权限</h3><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL、ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td>CREATE</td><td>创建数据库&#x2F;表</td></tr></tbody></table><h2 id="SQL关键字的编写顺序"><a href="#SQL关键字的编写顺序" class="headerlink" title="SQL关键字的编写顺序"></a>SQL关键字的编写顺序</h2><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	字段列表</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	表名列表</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">	条件列表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">	分组字段列表</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">	分组后条件列表</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">	排序字段列表</span><br><span class="line">limit </span><br><span class="line">	分页参数</span><br></pre></td></tr></table></figure></div><h2 id="SQL关键字的执行优先级"><a href="#SQL关键字的执行优先级" class="headerlink" title="SQL关键字的执行优先级"></a>SQL关键字的执行优先级</h2><p>在 SQL 查询中，不同的子句按照特定的顺序执行：</p><ol><li><p><strong>FROM</strong>: 确定查询的数据来源，通常是表或子查询。</p></li><li><p><strong>JOIN</strong>: 如果存在 JOIN，在此阶段将多个表连接成一个结果集，这是基于 ON 或 USING 子句中指定的条件。</p></li><li><p><strong>ON&#x2F;USING</strong>: 这是 JOIN 操作的一部分，用于定义表之间连接的条件。</p></li><li><p><strong>WHERE</strong>: 根据 WHERE 子句的条件过滤记录，只有满足条件的记录才会被保留。</p></li><li><p><strong>GROUP BY</strong>: 将结果集按照一个或多个列进行分组。</p></li><li><p><strong>HAVING</strong>: 过滤分组后的结果，只有满足 HAVING 条件的分组才会被包含在最终结果中。</p></li><li><p><strong>SELECT</strong>: 选择最终输出的列或计算表达式。注意，SELECT 通常在逻辑上认为是在 FROM 和 WHERE 之后，但在实际的查询执行计划中，它通常与 DISTINCT 和 ORDER BY 一起考虑。</p></li><li><p><strong>DISTINCT</strong>: 如果存在，DISTINCT 会在所有行被处理之后，SELECT 之前，去除结果集中的重复行。</p></li><li><p><strong>ORDER BY</strong>: 将结果集按照一个或多个列进行排序。</p></li><li><p><strong>LIMIT</strong>: 在某些数据库系统中（如 MySQL），LIMIT 用于限制结果集的行数。在其他数据库系统中（如 SQL Server），可能使用 TOP 或 ROWNUM 等其他子句来实现类似的功能。</p></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>函数</strong> 是指一段可以直接被另一段程序直接调用的程序或代码</p><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>concat(S_1_， S_2_，…，S_n_)</td><td>字符串拼接，将S_1_， S_2_，…，S_n_拼接成一个字符串</td></tr><tr><td>lower(str)</td><td>将字符串str全部转为小写</td></tr><tr><td>upper(str)</td><td>将字符串str全部转为大写</td></tr><tr><td>lpad(str，n，pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>rpad(str，n，pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>trim(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>substring(str，start，len)</td><td>返回字符串str从start位置起的len长度的字符串【<strong>MySQL的起始索引是1，不是0</strong>】</td></tr></tbody></table><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>ceil(x)</td><td>向上取整</td></tr><tr><td>floor(x)</td><td>向下取整</td></tr><tr><td>mod(x,y)</td><td>返回x&#x2F;y的模</td></tr><tr><td>rand()</td><td>返回0~1内的随机小数</td></tr><tr><td>round(x,y)</td><td>求参数x的四舍五入的值，保留y位小数</td></tr></tbody></table><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>curdate()</td><td>返回当前日期</td></tr><tr><td>curtime()</td><td>返回当前时间</td></tr><tr><td>now()</td><td>返回当前日期和时间</td></tr><tr><td>year(date)</td><td>获取指定date的年份</td></tr><tr><td>month(date)</td><td>获取指定date的月份</td></tr><tr><td>day(date)</td><td>获取指定date的日期</td></tr><tr><td>date_add(date，interval expr type)</td><td>返回一个日期&#x2F;时间值增加上一个时间间隔expr后的时间值</td></tr><tr><td>datediff(date1，date2)</td><td>返回起始时间date1和结束时间date2之间的天数 <strong>【date1 - date2】</strong></td></tr></tbody></table><p>eg：<br><code>SELECT DATE_ADD(&#39;2024-07-26&#39;, INTERVAL 10 DAY) AS new_date;</code><br>类似day的时间单位还有：</p><ul><li><code>second</code>：秒</li><li><code>minute</code>：分钟</li><li><code>hour</code>：小时</li><li><code>week</code>：周</li><li><code>month</code>：月</li><li><code>year</code>：年</li><li><code>quarter</code>：季度</li><li><code>microsecond</code>：微秒</li></ul><h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><p>可以在SQL语句中实现条件筛选，从而提高语句的效率。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>if(value，t，f)</td><td>如果value为true，则返回 t，否则返回 f</td></tr><tr><td>ifnull(value1，value2)</td><td>如果value1部位空，返回value1，否则返回value2</td></tr><tr><td>case when [val1] then [res1] … else [default] end</td><td>如果val1为true，返回res1，…否则返回default默认值</td></tr><tr><td>case [expr] when [val1] then [res1] … else [default] end</td><td>如果expr的值等于val1，返回res1，…否则返回default默认值</td></tr></tbody></table><blockquote><p><strong>注意：</strong></p><ul><li>不带表达式的case语句可以使用比较运算符等，适用于更灵活的条件判断。</li><li>带表达式的case语句不可以使用比较运算符，只能用于具体值匹配。</li></ul></blockquote><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul><li>概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。</li><li>目的：保证数据库的正确性、有效性和完整性。</li></ul><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段值不能为null</td><td><code>not null</code></td></tr><tr><td>唯一约束</td><td>保证字段的所有数据都是唯一、不重复的</td><td><code>unique</code></td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td><code>primary key</code>(常搭配<code>auto_increment</code>)</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段值，则采用默认值(默认值可以用引号括起来)</td><td><code>default</code></td></tr><tr><td>外键约束</td><td>让两张表的数据建立连接，保证数据的一致性和完整性</td><td><code>foreign key</code></td></tr><tr><td>检查约束</td><td>确保列中的所有值满足特定条件</td><td><code>check</code></td></tr></tbody></table><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><ul><li>语法：</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名(</span><br><span class="line">	字段<span class="number">1</span> 字段类型 [约束] [comment 字段<span class="number">1</span>注释],</span><br><span class="line">    ……</span><br><span class="line">    字段n 字段类型 [约束] [comment 字段n注释],</span><br><span class="line">    [<span class="keyword">constraint</span>] [外键名称] <span class="keyword">foreign key</span> (外键字段名) <span class="keyword">references</span> 主表 (主表列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">add constraint</span> 外键名称 <span class="keyword">foreign key</span> (外键字段名) <span class="keyword">references</span> 主表 (主表列名)</span><br></pre></td></tr></table></figure></div><p><strong>注意：</strong> 主表是父表，包含外键约束的是子表。</p><ul><li>删除&#x2F;更新行为：</li></ul><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。</td></tr><tr><td>RESTRICT</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。</td></tr><tr><td>CASCADE</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有，也删除&#x2F;更新外键在子表中的记录。</td></tr><tr><td>SET NULL</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（这里要求外键允许取null）</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键列设置成一个默认的值(Innodb&#x2F;MySQL不支持)</td></tr></tbody></table><blockquote><p><strong>注意：</strong><br>删除和更新操作需要分别单独进行设置，可以根据具体的需求设置这两个选项。<br>eg：<code>alter table 表名 add constraint 外键名称 foreign key (外键字段) references 主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;</code></p></blockquote><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><ul><li><strong>一对多：</strong> 在多的一方设置外键，关联一的一方的主键</li><li><strong>多对多：</strong> 建立中间表，中间表包含两个外键，关联两张表的主键</li><li><strong>一对一：</strong> 用于表结构拆分，在其中任何一方设置外键(UNIQUE)，关联另一方的主键</li></ul><h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询"></a>多表查询</h3><ul><li><strong>内连接</strong><ul><li><strong>隐式：</strong> select … from 表A，表B where 条件 …</li><li><strong>显式：</strong> select … from 表A [inner] join 表B on 条件 …</li></ul></li><li><strong>外连接</strong><ul><li><strong>左外：</strong> select … from 表A left [outer] join 表B on 条件 …</li><li><strong>右外：</strong> select … from 表A right [outer] join 表A on 条件 …</li></ul></li><li><strong>自连接：</strong> select … from 表A 别名1 ，表A 别名2 where 条件 …【也可以使用外连接】</li><li><strong>子查询：</strong> 标量子查询、列子查询、行子查询、表子查询</li></ul><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A …</span><br><span class="line"><span class="keyword">union</span> [<span class="keyword">all</span>]</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表B …</span><br></pre></td></tr></table></figure></div><blockquote><p>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</p><ul><li><strong>union all：</strong> 会将全部的数据直接合并在一起</li><li><strong>union：</strong> 会对合并之后的数据去重</li></ul></blockquote><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>概念：SQL语句中嵌套select语句，称为<strong>嵌套语句</strong> ，又称<strong>子查询</strong><br>eg：<code>select * from t1 where column1 = (select column1 form t2);</code><br>子查询外部的语句可以是 insert &#x2F; update &#x2F; delete &#x2F; select 的任何一个。</p><h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>子查询返回的结果是单个值 (数字、字符串、日期等)，最简单的形式，这种子查询称为<strong>标量子查询</strong><br>常用的操作符：&#x3D;、&lt;&gt;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;</p><h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h4><p>子查询返回的结果是一行(可以是多列)，这种子查询被称为<strong>行子查询</strong><br>常用的操作符：&#x3D;、&lt;&gt;、in、not in</p><h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h4><p>子查询返回的结果是一列(可以是多行)，这种查询被称为<strong>列子查询</strong><br>常用的操作符：in、not in、any、some、all</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>in</td><td>在指定的集合范围内，多选一</td></tr><tr><td>not in</td><td>不在指定的集合范围之内</td></tr><tr><td>any</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>some</td><td>与any等同，使用some的地方都可以使用any</td></tr><tr><td>all</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table><h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><p>子查询返回的结果是多行多列，这种子查询称为<strong>表子查询</strong><br>常用的操作符：in</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h4 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h4><ol><li>事务简介：<br>事务是一组操作的集合，这组操作要么全部执行成功，要么全部执行失败。</li><li>事务操作：<ul><li><code>start transaction;</code>：开启事务</li><li><code>commit / rollback;</code>：提交&#x2F;回滚事务</li></ul></li><li>事务四大特性(ACID)：<ul><li>原子性(Atomicity)：原子性是指一个事务中的所有操作要么全部执行，要么全部不执行。</li><li>一致性(Consistency)：一致性确保事务在完成时，数据库从一个一致性状态转换到另一个一致性状态。事务的执行不会违反数据库的完整性约束。</li><li>隔离性(Isolation)：隔离性确保并发事务的执行不会相互干扰，每个事务的操作对其他事务是隔离的，中间状态对其他事务不可见。</li><li>持久性(Durability)：持久性确保一旦事务提交，其对数据库的修改将永久保存，即使系统发生故障，数据也不会丢失。</li></ul></li><li>并发事务问题</li></ol><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另一个事务还没有提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但在插入数据时，又发现这行数据已经存在</td></tr></tbody></table><ol start="5"><li>事务隔离级别</li></ol><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√(会出现)</td><td>√</td><td>√</td></tr><tr><td>Read committed（Oracle默认）</td><td>×(不会出现)</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read（MySQL默认）</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li>开启事务<br><code>start transaction</code>或<code>begin</code></li><li>提交事务<br><code>commit</code></li><li>回滚事务<br><code>rollback</code></li><li>查看事务隔离级别<br><code>select @@TRANSACTION_ISOLATION;</code></li><li>设置事务隔离级别<br><code>set [session | global] transaction isolation level &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125;</code><br><strong>注意：</strong> 花括号在写的时候不用加</li></ul><h2 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h2><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729133637.jpeg"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729133733.png"></p><h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><ol><li>在建表的时，指定存储引擎</li></ol><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名(</span><br><span class="line">	字段<span class="number">1</span> 字段<span class="number">1</span>类型 [comment 字段<span class="number">1</span>注释],</span><br><span class="line">     …… ,</span><br><span class="line">    字段n 字段n类型 [comment 字段n注释]</span><br><span class="line">) engine <span class="operator">=</span> innodb [comment 表注释];</span><br></pre></td></tr></table></figure></div><ol start="2"><li>查看当前数据库支持的存储引擎</li></ol><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729134651.png" alt="image-20240729134651824"></p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ul><li><p>介绍：<br>InnoDB是一种兼顾可靠性和高性能的通用存储引擎，在MySQL 5.5 之后，InnoDB是默认的MySQL存储引擎</p></li><li><p>特点：</p><ul><li>DML操作遵守ACID模型，支持<strong>事务</strong>；</li><li><strong>行级锁</strong>，提高并发访问性能；</li><li>支持<strong>外键</strong> foreign key 约束，保证数据的完整性和正确性；</li></ul></li><li><p>文件：<br>xxx.ibd：xxx代表的是表名，InnoDB引擎的每一张表都会对应这样一个表空间文件，存储该表的结构(frm，sdi)、数据和索引。</p><ul><li>参数设置：innodb_file_per_table【MySQL 5.6及以上默认值为’ON‘】</li></ul><blockquote><p>当’innodb_file_per_table’设置为’ON‘时，每一个InnoDB表的数据和索引都会储存在独立的表空间文件中，未必是在共享表空间文件(如’ibdata1‘)中。这些独立的表文件通常以<code>.ibd</code>为后缀,存储在数据库的目录中。</p><p>查看状态的SQL语句：<code>show variables like &#39;innodb_file_per_table&#39;;</code></p><p>查看ibd文件的SQL语句：<code>ibd2sdi 文件名.ibd;</code></p></blockquote></li></ul><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729163604.png"></p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><ul><li><p>介绍：<br>MyISAM是MySQL早期的默认存储引擎</p></li><li><p>特点：</p><ul><li>不支持<strong>事务</strong>，不支持<strong>外键</strong>；</li><li>支持<strong>表锁</strong>，不支持行锁；</li><li>访问速度快；</li></ul></li><li><p>文件：<br>xxx.sdi：存储表结构信息</p><p>xxx.MYD：存储数据</p><p>xxx.MYI：存储索引</p></li></ul><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><ul><li><p>介绍：<br>Memory引擎的表数据存储在内存中，由于受到硬件问题，或断电问题的影响，只能将这些表作为临时表或缓存使用。</p></li><li><p>特点：</p><ul><li>内存存放</li><li>hash索引（默认）</li></ul></li><li><p>文件：<br>xxx.sdi：存储表结构信息</p></li></ul><h3 id="不同引擎的区别与选择"><a href="#不同引擎的区别与选择" class="headerlink" title="不同引擎的区别与选择"></a>不同引擎的区别与选择</h3><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729162442.png"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729162647.png"></p><blockquote><ul><li>InnoDB：存储业务系统中对事务、数据完整性要求较高的核心数据。</li><li>MyISAM：存储业务系统的非核心事务。</li></ul></blockquote><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>介绍：<br>索引(index)是帮助MySQL高效获取数据的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</li><li>优缺点：</li></ul><table><thead><tr><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>提高数据检索的效率，降低数据库的IO成本</td><td>索引列也是要占用空间的</td></tr><tr><td>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</td><td>索引大大提高了查询效率，同时却也降低了更新表的速度，如对表进行insert、update、delete时，效率降低。</td></tr></tbody></table><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729170831.png"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729170900.png"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729171005.png"></p><p>思考题</p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729175532.png"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>primary</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>unique</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个·</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>fulltext</td></tr></tbody></table><p>在Innodb存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚焦索引(Clustered Index)</td><td>将数据存储和索引放到了一块，索引结构的叶子节点保存了行数据</td><td>必须有，且有且仅有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个非空唯一（not null unique）索引作为聚集索引</li><li>如果表没有主键，或没有合适的唯一索引，Innodb会自动生成一个<code>rowid</code>作为隐藏的聚集索引</li></ul><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729193024.png"></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li><p>创建索引</p><p><code>create [unique | fulltext ] index index_name on table_name (index_col_name,…);</code></p></li><li><p>查看索引<br><code>show index from table_name;</code></p></li><li><p>删除索引</p><p><code>drop index index_name on table_name;</code></p></li></ul><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li><p>查看执行频次<br><code>show [session | global] status like &#39;Com_______&#39;;</code>【一共7个下划线】</p></li><li><p>慢查询日志<br>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。MySQL的慢查询日志默认没有开启。</p><ul><li>查看慢查询日志是否开启<br><code>show variables like &#39;slow_query_log&#39;;</code></li><li>开启慢查询日志<br>需要在MySQL的配置文件（ &#x2F;etc&#x2F;my.cnf ）中配置如下信息</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 开启MySQL慢查询日志开关</span><br><span class="line">slow_query_log <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"># 设置慢查询的时间为<span class="number">2</span>s，<span class="keyword">SQL</span>语句执行时间超过<span class="number">2</span>s，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></div><p>配置完毕后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息 <strong>&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log</strong>，开启慢查询后，会自动创建这个文件夹。</p></li><li><p>profile详情<br>show profiles 能够在做SQL优化时帮助我们了解时间都消耗到哪里去了。</p><ul><li>通过<code>have_profiling</code>参数，能够看到当前MySQL是否支持profile操作<br><code>select @@have_profiling;</code></li><li>默认profiling是关闭的，可以通过set语句在session &#x2F; global级别开启profiling<br><code>set profiling = 1;</code></li><li>常用指令</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看每一条<span class="keyword">SQL</span>的耗时基本情况</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"></span><br><span class="line"># 查看指定query_id的<span class="keyword">SQL</span>语句各个阶段的耗时情况【query_id是在执行完<span class="keyword">show</span> profiles会提供的】</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br><span class="line"></span><br><span class="line"># 查看指定query_id的<span class="keyword">SQL</span>语句CPU的使用情况</span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure></div></li><li><p>explain执行计划<br>explain &#x2F; desc 命令获取MySQL如何执行select语句的信息，包括在select语句执行过程中表如何连接和连接的顺序。</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 直接在<span class="keyword">select</span>语句之间加上关键字 explain <span class="operator">/</span> <span class="keyword">desc</span></span><br><span class="line">explain <span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240730124417.png"></p><ul><li><strong>id</strong>：select查询的序列号，表示查询中执行select子句或者操作表的顺序( id相同，执行顺序从上到下；id不同，值越大，越先执行)。</li><li><strong>select_type</strong>：表示select的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（select&#x2F;where之后包含了子查询）等。</li><li><strong>type</strong>：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all。</li><li><strong>possible_key</strong>：显示可能应用在这张表上的索引，可以是一个或多个。</li><li><strong>key</strong>：实际使用到的索引，如果为NULL，表示没有使用索引。</li><li><strong>key_len</strong>：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</li><li><strong>rows</strong>：MySQL认为必须要执行查询的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的。</li><li><strong>filtered</strong>：表示返回结果的行数占需要读取行数的百分比，filtered的值越大越好，最大等于100。</li></ul></li></ul><h3 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h3><h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><p>如果索引了多列（联合索引），要遵守最左前缀法则，查询从最左列开始，并且不跳过索引中的列。如果跳跃某一列，<strong>索引将部分失效（后面的字段索引失效）</strong>。</p><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>联合索引中，出现范围查询(&gt;，&lt;)，<strong>范围查询右侧的列索引失效</strong></p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age<span class="operator">&gt;</span><span class="number">30</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 注意：<span class="operator">&gt;=</span>、<span class="operator">&lt;=</span>不会失效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age<span class="operator">&gt;=</span><span class="number">30</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;0&#x27;</span>;【不会失效】</span><br></pre></td></tr></table></figure></div><h4 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h4><ul><li><strong>索引列运算</strong>：不要在索引列上进行运算操作，索引将失效</li><li><strong>字符串不加引号</strong>：字符串类型字段使用时不加引号，索引将失效</li><li><strong>模糊查询</strong>：如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效</li><li><strong>or连接的条件</strong>：用or分割开的条件，如果or前的条件的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到</li><li><strong>数据分布影响</strong>：如果MySQL评估使用索引比全表更慢，则不使用索引</li></ul><h4 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h4><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># use index:(建议使用)</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_name use index(idx_user_pro) <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># ignore index:(忽略索引<span class="operator">/</span>不使用)</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_name ignore index(idx_user_pro) <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># force index:(强制使用)</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_name force index(idx_user_pro) <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure></div><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在索引中已经全部能够找到，减少<code>select *</code></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240730171450.png" alt="image-20240730171450404"></p><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>当字段类型为字符串（varchar，text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时浪费大量的磁盘IO，影响查询效率。此时可以只将字符的一部分前缀建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><ul><li><p>语法：<br><code>create index idx_xxxx on table_name(column(n));</code></p></li><li><p>前缀长度</p><p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性时1，这是最好的索引选择性，性能也是最好的。</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email,<span class="number">1</span>,<span class="number">5</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240730173359.png"></p></li></ul><h4 id="单列索引与联合索引"><a href="#单列索引与联合索引" class="headerlink" title="单列索引与联合索引"></a>单列索引与联合索引</h4><ul><li>单列索引：即一个索引只包含单个列。</li><li>联合索引：即一个索引包含了多个列。</li></ul><p>【在业务场景中，如果存在多个查询条件时，考虑针对查询字段建立索引时，建议建立联合索引，而非单列索引】</p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240730174806.png" alt="image-20240730174806656"></p><blockquote><p>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询。<br>也就是说当你只查询一个条件时，也有可能是用到联合索引。</p></blockquote><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240730174832.png" alt="image-20240730174832726"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240730183811.png" alt="image-20240730183810887" style="zoom:50%"> <img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240730183901.png" alt="image-20240730183901044" style="zoom:33%"><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="insert优化"><a href="#insert优化" class="headerlink" title="insert优化"></a>insert优化</h3><ul><li>批量插入<br><code>insert into table_name values (值1，值2……)，(值1，值2……);</code></li><li>手动提交事务</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert into</span> table_name <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span>……)，(值<span class="number">1</span>，值<span class="number">2</span>……),……;</span><br><span class="line"><span class="keyword">insert into</span> table_name <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span>……)，(值<span class="number">1</span>，值<span class="number">2</span>……),……;</span><br><span class="line"><span class="keyword">insert into</span> table_name <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span>……)，(值<span class="number">1</span>，值<span class="number">2</span>……),……;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></div><ul><li>主键顺序插入</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 主键乱序插入：<span class="number">8</span> <span class="number">1</span> <span class="number">9</span> <span class="number">21</span> <span class="number">88</span> <span class="number">2</span> <span class="number">4</span> <span class="number">15</span> 速度慢</span><br><span class="line"># 主键顺序插入：<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">9</span> <span class="number">15</span> <span class="number">21</span> <span class="number">88</span> 速度更快</span><br></pre></td></tr></table></figure></div><ul><li>大批量插入数据</li></ul><p>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 客户端连接服务端时，加上参数 <span class="comment">--local-infile</span></span><br><span class="line">mysql <span class="comment">--local-infile -u root -p</span></span><br><span class="line"># 设置全局参数local_infile为<span class="number">1</span>，开启从本地加载文件导入数据的开关</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"># 执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;数据文件路径&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> `tb_name` fields terminated <span class="keyword">by</span> <span class="string">&#x27;区分一行小数据的符号&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;区分每行大数据的符号&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 查看local_infile状态的语句</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@local_infile</span>;</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731190144.png" alt="image-20240731190136913"></p><h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731192536.png" alt="image-20240731192535901"></p><ul><li>页分裂</li></ul><p>主键顺序插入的话并不会发生页分裂的问题。</p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731192618.png" alt="image-20240731192618271"></p><p>主键乱序插入的情况</p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731192836.png" alt="image-20240731192835678"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731192941.png" alt="image-20240731192941544"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731192851.png" alt="image-20240731192851083"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731192859.png" alt="image-20240731192859507"></p><ul><li>页合并</li></ul><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731193030.png" alt="image-20240731193029775"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731193043.png" alt="image-20240731193043025"></p><ul><li>页分裂(合并)的危害<ul><li>页分裂和合并涉及大量的数据移动和重组操作。频繁进行这些操作会追加数据库的 I&#x2F;O 负担和CPU消耗，从而影响数据库的整体性能。</li><li>分裂和合并可能会导致 B+树索引结构频繁地进行调整，这会影响插入和删除操作的性能。</li><li>频繁的页分裂和合并还可能导致磁盘上存在较多的空间碎片。新分出的数据页通常会有大量的空闲空间，则会导致数据库表占用更多的磁盘空间，造成资源浪费。</li></ul></li></ul><p><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43957967/article/details/140259106#t3">如何避免分页<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><ul><li>主键设计原则<ul><li>满足业务需求的情况下，尽量降低主键的长度。</li><li>插入数据时，尽量选择顺序插入，选择使用<code>auto_increment</code>自增主键。</li><li>尽量不要使用UUID做主键或者其它自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改。</li></ul></li></ul><h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><ol><li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序。</li><li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高。</li></ol><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li><li>尽量使用覆盖索引，避免回表。</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则(ASC&#x2F;DESC)是否和排序规则一致。</li><li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小<code>sort_buffer_size</code>（默认值256k）</li></ul><h3 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h3><ul><li>在分组操作时，可以通过索引来提高效率。</li><li>分组操作时，索引的使用也是满足最左前缀法则的。</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 假设存在索引 idx_user_pro_age</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> age, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> age;  </span><br><span class="line"># 不满足最左前缀法则，使用的是临时表</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> age, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> age;</span><br><span class="line"># 满足最左前缀法则，使用的是索引</span><br></pre></td></tr></table></figure></div><h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p>当搜索是limit 20000000，10时，此时需要MySQL排序前20000010记录，仅仅返回20000000 - 20000010的记录，其它记录丢弃，查询排序的代价非常大。</p><p>优化思路：一般分页查询时，通过建立 <strong>覆盖索引</strong> 能够比较好的提高性能，可以通过<strong>覆盖索引</strong> 加 <strong>子查询</strong>形式进行优化</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_sku t , (<span class="keyword">select</span> id <span class="keyword">from</span> tb_sku <span class="keyword">order</span> id limit <span class="number">2000000</span>,<span class="number">10</span>) a <span class="keyword">where</span> t.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure></div><h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><ul><li><p>count( )是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是null，累计值就加1，否则不加，最后返回累计值</p></li><li><p>用法：count(*)、count(主键)、count(字段)、count(1)</p><ul><li><p>count(主键)</p><p>InnoDB引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行累加（主键不可能为null）。</p></li><li><p>count(字段)</p><p>没有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务端，服务层判断是否为null，不为null，计数累加。</p><p>有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</p></li><li><p>count(1)</p><p>InnoDB引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个字”1“进去，直接按行进行累加。</p><p>【括号里的也可以是2，3，4……不一定是1】</p></li><li><p>count(*)</p><p>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</p></li></ul><blockquote><p>按效率排序：</p><p>count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)，尽量使用 count(*)</p></blockquote></li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure></div><ul><li><p>MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高；</p></li><li><p>InnoDB引擎就比较麻烦，它执行count(*)的时候，需要把数据一个一个地从引擎里面读取出来，然后累积计数。</p><p><code>优化思路：自己计数。</code></p></li></ul><h3 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h3><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731233825.png" alt="image-20240731233824572"></p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>视图(View) 是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p><blockquote><p>视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作在于创建这条SQL查询语句上。</p></blockquote><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li><p>创建</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">or</span> replace] <span class="keyword">view</span> 视图名称[(列名列表)] <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span>[<span class="keyword">cascaded</span> <span class="operator">|</span> <span class="keyword">local</span>] <span class="keyword">check</span> option];</span><br></pre></td></tr></table></figure></div><p>如果不定义 <code>列名列表</code>，那么视图中的列名将默认采用 <code>SELECT</code> 语句中所选择的列名。这意味着视图中的每一列将继承 <code>SELECT</code> 语句中的列名。</p><p>如果不定义<code>cascaded | local</code>且写了<code>with check option</code>,默认是<code>with cascaded check option</code></p><blockquote><ul><li><p><strong>什么都不写</strong></p><p>在执行插入、更新、删除等操作时并没有条件约束。</p></li><li><p><strong>cascaded check option</strong></p><p>创建视图时加上了<code>cascaded check option</code>,在执行插入、更新、删除等操作时会递归所有底层视图的约束条件，确保每一层次的条件都满足。</p></li><li><p><strong>local check option</strong></p><p><code>local check option</code>只检查直接视图的定义条件，而不会检查底层视图的约束条件。</p></li><li><p><strong>如果视图是基于其它视图创建的</strong></p><p>会去查看基于的视图是否被<code>[with[cascaded | local] check option]</code>定义。</p></li></ul></blockquote><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240801213751.png" alt="image-20240801213751217"></p><ul><li>查询</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看创建视图语句</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> 视图名称;</span><br><span class="line"># 查看视图数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 视图名称 ……;</span><br></pre></td></tr></table></figure></div><ul><li>修改</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 方式一</span><br><span class="line"><span class="keyword">create</span> [<span class="keyword">or</span> replace] <span class="keyword">view</span> 视图名称[(列名列表)] <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span>[<span class="keyword">cascaded</span> <span class="operator">|</span> <span class="keyword">local</span>] <span class="keyword">check</span> option];</span><br><span class="line"># 方式二</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> 视图名称[(列名列表)] <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span>[<span class="keyword">cascaded</span> <span class="operator">|</span> <span class="keyword">local</span>] <span class="keyword">check</span> option];</span><br></pre></td></tr></table></figure></div><ul><li>删除</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> [if <span class="keyword">exists</span>] 视图名称 [,视图名称] …;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则视图不可更新：</p><ol><li>聚合函数或窗口函数：sum( )、min( )、max( )、count( )等</li><li>distinct</li><li>group by</li><li>having</li><li>union 或者 union all</li></ol><blockquote><p>这里的“更新”包括插入操作、更新操作和删除操作。具体来说，当视图包含聚合函数、<code>DISTINCT</code>、<code>GROUP BY</code>、<code>HAVING</code> 或 <code>UNION</code>（<code>UNION ALL</code>）时，视图不仅不可更新，还不可进行插入和删除操作。这是因为这些操作都要求视图中的行能够直接映射回基础表中的行，而上述项使得这种映射无法实现。</p><p><strong>为什么不能进行插入操作？</strong><br>视图是基于基础表定义的虚拟表，它并不实际存储数据，而是动态地从基础表中检索和计算数据。因此，通过视图进行的插入操作实际上需要插入到基础表中。如果视图包含聚合函数、<code>GROUP BY</code>、<code>HAVING</code> 等特性，视图中的数据与基础表中的具体行并不直接一一对应，这导致插入操作无法匹配并插入到基础表中。</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> sales (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    salesperson_id <span class="type">INT</span>,</span><br><span class="line">    sales_amount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> sales (id, salesperson_id, sales_amount) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">101</span>, <span class="number">500.00</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="number">102</span>, <span class="number">300.00</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="number">101</span>, <span class="number">700.00</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="number">103</span>, <span class="number">200.00</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> sales_summary <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> salesperson_id, <span class="built_in">SUM</span>(sales_amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> salesperson_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> sales_summary (salesperson_id, total_sales) <span class="keyword">VALUES</span> (<span class="number">104</span>, <span class="number">400.00</span>);</span><br><span class="line"># 报错：The target <span class="keyword">table</span> sales_summary <span class="keyword">of</span> the <span class="keyword">INSERT</span> <span class="keyword">is</span> <span class="keyword">not</span> insertable<span class="operator">-</span><span class="keyword">into</span></span><br></pre></td></tr></table></figure></div></blockquote><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>简单<br>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作指定全部的条件。</li><li>安全<br>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能看到的数据</li><li>数据独立<br>视图可帮助用户屏蔽真实表结构变化带来的影响。</li></ul><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>封装、复用</strong></li><li>可以接受参数，也可以返回数据</li><li>减少网络交流、效率提升</li></ul><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li>创建</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([参数列表])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">--SQL语句</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div><ul><li>调用</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> 名称([参数]);</span><br></pre></td></tr></table></figure></div><ul><li>查看</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.routines <span class="keyword">where</span> routine_schema<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line"># 查询指定数据库的存储过程及状态信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称;</span><br><span class="line"># 查询某个存储过程的定义</span><br></pre></td></tr></table></figure></div><ul><li>删除</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> [if <span class="keyword">exists</span>] 存储过程名称;</span><br></pre></td></tr></table></figure></div><blockquote><p><strong>注意：</strong></p><p>在命令行中，执行创建存储过程的SQL时，需要通过关键字 delimiter 指定SQL语句的结束符。</p><p>比如：<code>delimiter $$;</code> ，表明以$$结尾来作为结束语句，默认是<code>;</code></p></blockquote><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><p>系统变量是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（global）、会话变量（session）</p><ul><li>查看系统变量</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有系统变量</span><br><span class="line"><span class="keyword">show</span> [session <span class="operator">|</span> <span class="keyword">global</span>] variables;</span><br><span class="line"></span><br><span class="line"># 可以通过<span class="keyword">like</span>模糊匹配方式查找变量</span><br><span class="line"><span class="keyword">show</span> [session <span class="operator">|</span> <span class="keyword">global</span>] variables <span class="keyword">like</span> <span class="string">&#x27;……&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 查看指定变量的值</span><br><span class="line"><span class="keyword">select</span> @@[session. <span class="operator">|</span> global.]系统变量名;</span><br></pre></td></tr></table></figure></div><ul><li>设置系统变量</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> [session <span class="operator">|</span> <span class="keyword">global</span>] 系统变量名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">set</span> @@[session. <span class="operator">|</span> global.]系统变量名 <span class="operator">=</span> 值;</span><br></pre></td></tr></table></figure></div><blockquote><p><strong>注意：</strong></p><ol><li><p>如果没有指定 session | global，默认是session，会话变量。</p></li><li><p>MySQL服务重启之后，所设置的全局参数会失效，想要不失效，可以在 &#x2F;etc&#x2F;my.cnf 中配置</p></li></ol></blockquote><h4 id="用户定义变量"><a href="#用户定义变量" class="headerlink" title="用户定义变量"></a>用户定义变量</h4><p>用户定义变量是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接通过<code>@变量名</code>使用就可以。其作用域为当前连接。</p><ul><li>赋值</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@var_name</span> <span class="operator">=</span> expr [, <span class="variable">@var_name</span> <span class="operator">=</span> expr] ……;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr [, <span class="variable">@var_name</span> :<span class="operator">=</span> expr] ……;</span><br><span class="line">更推荐使用 :<span class="operator">=</span> , 因为在<span class="keyword">SQL</span>语言中的等于用的就是 <span class="operator">=</span> ,为了让赋值和比较逻辑中的等于区分开来。</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr [, <span class="variable">@var_name</span> :<span class="operator">=</span> expr] ……;</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> <span class="variable">@var_name</span> <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure></div><ul><li>使用</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="variable">@var_name</span>;</span><br></pre></td></tr></table></figure></div><blockquote><p><strong>注意：</strong></p><p>用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="variable">@abc</span>; <span class="comment">-- 事先没有定义过 @abc</span></span><br><span class="line"># 输出的值为<span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></div></blockquote><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>局部变量是根据需要定义的在局部生效的变量，访问之前需要<code>declare</code>声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内部声明的<code>begin … end</code>块。</p><ul><li>声明</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> 变量名 变量类型 [<span class="keyword">default</span> …];</span><br></pre></td></tr></table></figure></div><p>变量类型就是数据库字段类型：int、bigint、double、char、varchar、date、time等。</p><ul><li>赋值</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> 变量名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">set</span> 变量名 :<span class="operator">=</span> 值；</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> 变量名 <span class="keyword">from</span> 表名…;</span><br></pre></td></tr></table></figure></div><h4 id="用户定义变量-VS-局部变量"><a href="#用户定义变量-VS-局部变量" class="headerlink" title="用户定义变量 VS 局部变量"></a>用户定义变量 VS 局部变量</h4><table><thead><tr><th>特性</th><th>用户定义变量</th><th>局部变量</th></tr></thead><tbody><tr><td>作用范围</td><td>会话级别</td><td>begin…end 块内</td></tr><tr><td>声明方式</td><td>无需显式声明，以‘@’符号开头</td><td>通过’declare’语句声明</td></tr><tr><td>生命周期</td><td>会话期间</td><td>begin…end 块内</td></tr><tr><td>使用场景</td><td>跨多个语句使用</td><td>存储过程、函数或触发器内</td></tr><tr><td>数据类型</td><td>自动确定</td><td>必须指定数据类型</td></tr></tbody></table><ul><li><p>用户定义变量</p><ul><li>可以在存储过程中使用，但不推荐在复杂的SQL查询中频繁使用。</li></ul></li><li><p>局部变量</p><ul><li>仅在存储过程、函数或触发器中使用，生命周期受限于它们的作用范围。</li><li>更适合在存储过程或函数内部处理复杂的逻辑。</li></ul></li></ul><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><table><thead><tr><th>类型</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>IN</td><td>该类参数作为输入，也就是需要调用时传入值</td><td>默认</td></tr><tr><td>OUT</td><td>该类参数作为输出，也就是该参数可以作为返回值</td><td></td></tr><tr><td>INOUT</td><td>既可以作为输入参数，也可以作为输出参数</td><td></td></tr></tbody></table><p>语法：</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([<span class="keyword">IN</span><span class="operator">/</span><span class="keyword">OUT</span><span class="operator">/</span><span class="keyword">INOUT</span> 参数名 参数类型])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">--SQL语句</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div><h3 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>语法：</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if 条件<span class="number">1</span> <span class="keyword">then</span> ……</span><br><span class="line">elseif 条件<span class="number">2</span> <span class="keyword">then</span> ……	 	<span class="comment">-- 可选</span></span><br><span class="line"><span class="keyword">else</span> ……		<span class="comment">-- 可选</span></span><br><span class="line"><span class="keyword">end</span> if;</span><br></pre></td></tr></table></figure></div><h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><p>语法1（填准确值）：</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> case_value</span><br><span class="line">	<span class="keyword">when</span> when_value1 <span class="keyword">then</span> statement_list1</span><br><span class="line">	[<span class="keyword">when</span> when_value2 <span class="keyword">then</span> statement_list2]</span><br><span class="line">	……</span><br><span class="line">	[<span class="keyword">else</span> statement_list]</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure></div><p>语法2（填表达式）：</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span></span><br><span class="line">	<span class="keyword">when</span> search_condition1 <span class="keyword">then</span> statement_list1</span><br><span class="line">	[<span class="keyword">when</span> search_condition2 <span class="keyword">then</span> statement_list2]</span><br><span class="line">	……</span><br><span class="line">	[<span class="keyword">else</span> statement_list]</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure></div><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>while循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 先判定条件，如果条件为<span class="literal">true</span>，则执行逻辑，否则，不执行逻辑</span><br><span class="line">while 条件 do</span><br><span class="line">	<span class="keyword">SQL</span>逻辑…</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> while;</span><br></pre></td></tr></table></figure></div><h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><p>repeat是有条件的循环2控制语句，当满足条件的时候推出循环。【相当于do…while语句，先执行一次再判断条件】</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repeat</span><br><span class="line">	<span class="keyword">SQL</span>逻辑……</span><br><span class="line">	until 条件</span><br><span class="line"><span class="keyword">end</span> repeat;</span><br></pre></td></tr></table></figure></div><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><p>loop实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用来实现简单的死循环。loop可以配合以下两个语句使用：</p><ul><li>leave：配合循环使用，退出循环。</li><li>iterate：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环</li></ul><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] loop</span><br><span class="line">	<span class="keyword">SQL</span>逻辑…</span><br><span class="line"><span class="keyword">end</span> loop [end_label];</span><br></pre></td></tr></table></figure></div><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leave label; <span class="comment">-- 退出指定标记的循环体</span></span><br><span class="line">iterate label; <span class="comment">-- 直接进入下一次循环</span></span><br><span class="line"># 搭配if <span class="keyword">then</span> 语句使用</span><br></pre></td></tr></table></figure></div><p>eg：</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	sum: loop</span><br><span class="line">		if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span> leave sum;</span><br><span class="line">		<span class="keyword">end</span> if;</span><br><span class="line">	<span class="keyword">end</span> loop sum;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>游标（cursor）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明，open、fetch和close。</p><ul><li><p>声明游标</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> 游标名称 <span class="keyword">cursor</span> <span class="keyword">for</span> 查询语句;</span><br></pre></td></tr></table></figure></div></li><li><p>打开游标</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> 游标名称;</span><br></pre></td></tr></table></figure></div></li><li><p>获取游标记录</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fetch</span> 游标名称 <span class="keyword">into</span> 变量[,变量];</span><br></pre></td></tr></table></figure></div></li><li><p>关闭游标</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">close</span> 游标名称;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="条件处理程序"><a href="#条件处理程序" class="headerlink" title="条件处理程序"></a>条件处理程序</h3><p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> handler_action handler <span class="keyword">for</span> condition_value [,condition_value]… statement;</span><br></pre></td></tr></table></figure></div><ul><li>handler_action<ul><li>**continue：**继续执行当前程序</li><li>**exit：**终止执行当前程序</li></ul></li><li>condition_value<ul><li>**sqlstate sqlstate_value：**状态码，sqlstate_value可以是02000等</li><li>**sqlwarning：**所有以01开头的sqlstate代码的简写</li><li>**not found：**所有以02开头的sqlstate代码的简写</li><li>**sqlexception：**所有没有被 sqlwarning 或 not found 捕获的sqlstate代码的简写</li></ul></li></ul><p>状态码的查询网址：<a class="link" target="_blank" rel="noopener" href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html">https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p2(<span class="keyword">in</span> uage <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">	<span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name,profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">&lt;=</span> uage;</span><br><span class="line">	<span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">sqlstate</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">close</span> u_cursor;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro;</span><br><span class="line">	<span class="keyword">create table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tb_user_pro(</span><br><span class="line">    	id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment,</span><br><span class="line">        name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    	profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> u_cursor;</span><br><span class="line">    while <span class="literal">true</span> do</span><br><span class="line">    	<span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname,upro;</span><br><span class="line">    	<span class="keyword">insert into</span> tb_user_pro <span class="keyword">values</span> (<span class="keyword">null</span>,uname,upro);</span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">close</span> u_cursor;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div><h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><p>存储函数是有返回值的存储过程，存储函数的参数只能是 in 类型的。</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 存储函数的名称([参数列表])</span><br><span class="line"><span class="keyword">return</span> type [characteristic…]</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	…<span class="keyword">SQL</span>语句</span><br><span class="line">	<span class="keyword">return</span>…;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div><ul><li>type<ul><li>int、bigint、double、char、varchar、date、time等。</li></ul></li><li>characteristic<ul><li>determinstic：相同的输入参数总是产生相同的结果</li><li>no sql：不含sql语句</li><li>reads sql data：包含读取数据的语句，但不包含写入数据的语句</li></ul></li></ul><blockquote><p>可以用存储函数的场景都可以使用存储过程。</p></blockquote><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><ul><li><p>介绍</p><p>触发器是与表有关的数据库对象，指在 insert &#x2F; update &#x2F; delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。</p><p>使用别名 <code>old</code> 和 <code>new</code> 来引用触发器中发生变化的记录内容，这与其它的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p></li></ul><table><thead><tr><th>触发器类型</th><th>NEW和OLD</th></tr></thead><tbody><tr><td>insert型触发器</td><td>new表示将要或者已经新增的数据</td></tr><tr><td>update型触发器</td><td>old表示修改之前的数据，new表示将要或已经修改后的数据</td></tr><tr><td>delete型触发器</td><td>old表示将要或者已经删除的数据</td></tr></tbody></table><ul><li><p>语法</p><ul><li><p>创建</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name</span><br><span class="line">before<span class="operator">/</span>after <span class="keyword">insert</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">/</span><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">on</span> tbl_name <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> <span class="comment">-- 行级触发器</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	trigger_stmt;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div></li><li><p>查看</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> triggers;</span><br></pre></td></tr></table></figure></div></li><li><p>删除</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> [schema_name.]trigger_name;<span class="comment">-- 如果没有指定schema_name,默认为当前数据库</span></span><br></pre></td></tr></table></figure></div></li></ul></li></ul><p>eg：</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_update_trigger</span><br><span class="line">	after <span class="keyword">update</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">insert into</span> user_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span></span><br><span class="line">	(<span class="keyword">null</span>,<span class="string">&#x27;insert&#x27;</span>,now(),new.id,</span><br><span class="line">     concat(<span class="string">&#x27;插入的数据内容为：id=&#x27;</span>,new.id,<span class="string">&#x27;,name=&#x27;</span>,new.name));</span><br><span class="line"> <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>锁是计算机协调多个进程或者线程并发访问某一资源的机制。在数据库中，除传统计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。</p><p>MySQL中的锁，按照锁的颗粒度分为以下三类：</p><ol><li>全局锁：锁定数据库的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据。</li></ol><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。【DQL查询语句可以继续执行】</p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240803201459.png" alt="image-20240803201458973"></p><blockquote><p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p></blockquote><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Step <span class="number">1</span>：锁定数据库</span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"></span><br><span class="line"># Step <span class="number">2</span>：打开另一个终端窗口，执行备份[在终端中执行，而不是在MySQL窗口中]</span><br><span class="line">mysqldump <span class="operator">-</span>u <span class="operator">-</span>p 数据库名 <span class="operator">&gt;</span> 备份文件.<span class="keyword">sql</span></span><br><span class="line"></span><br><span class="line"># Step <span class="number">3</span>：返回MySQL会话，解锁数据库</span><br><span class="line">unlock tables;</span><br><span class="line"></span><br><span class="line"># 在一个窗口中执行的情况<span class="comment">---------------------------------------</span></span><br><span class="line"></span><br><span class="line"># Step <span class="number">1</span>: 登录MySQL并启用全局锁</span><br><span class="line">mysql <span class="operator">-</span>u 用户名 <span class="operator">-</span>p <span class="operator">-</span>e &quot;FLUSH TABLES WITH READ LOCK;&quot;</span><br><span class="line"></span><br><span class="line"># Step <span class="number">2</span>: 在同一个终端中执行备份操作</span><br><span class="line">mysqldump <span class="operator">-</span>u 用户名 <span class="operator">-</span>p 数据库名 <span class="operator">&gt;</span> 备份文件.<span class="keyword">sql</span></span><br><span class="line"></span><br><span class="line"># Step <span class="number">3</span>: 解除全局锁</span><br><span class="line">mysql <span class="operator">-</span>u 用户名 <span class="operator">-</span>p <span class="operator">-</span>e &quot;UNLOCK TABLES;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><blockquote><p>在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致性数据备份</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="comment">--single-transaction -u 用户名 -p  数据库名 &gt; 备份文件.sql</span></span><br></pre></td></tr></table></figure></div><p>备份过程中不会锁定表，因此可以最大限度地减少对数据库的干扰。这对于高并发、需要持续写操作的数据库尤为重要。但在高负载环境中，长时间的备份可能会增加I&#x2F;O负担，影响数据库性能。</p></blockquote><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ol><li>如果在主库上备份，那么在备份期间不能执行更新，业务基本上就得停摆。</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</li></ol><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InooDB、BDB等存储引擎中。</p><p>表级锁主要分为以下三类：</p><ul><li>表锁</li><li>元数据锁（meta data lock，MDL）</li><li>意向锁</li></ul><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><ul><li>表共享读锁（read lock）：不会阻塞其它客户端的读，但是会阻塞写。</li><li>表独占写锁（write lock）：既阻塞其它客户端的读，有阻塞其它客户端的写。</li></ul><p>语法：</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 加锁</span><br><span class="line">lock tables 表名… read<span class="operator">/</span>write;</span><br><span class="line"></span><br><span class="line"># 释放锁</span><br><span class="line">unlock tables; <span class="operator">/</span> 客户端断开连接</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240803201344.png" alt="image-20240803201337334"></p><h4 id="元数据锁（meta-data-lock，MDL）"><a href="#元数据锁（meta-data-lock，MDL）" class="headerlink" title="元数据锁（meta data lock，MDL）"></a>元数据锁（meta data lock，MDL）</h4><p>MDL加锁过程是系统自动控制，无需显式使用。在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML与DDL冲突，保证读写的正确性</strong>。</p><p>在MySQL5.5中引入了MDL，<strong>当对一张表进行增删改查的时候，加MDL读锁（共享）；当对表结构进行变更操作的时候，加MDL写锁（排他）</strong>。</p><table><thead><tr><th>对应SQL</th><th>锁类型</th><th>说明</th></tr></thead><tbody><tr><td>lock tables xxx read &#x2F; write</td><td>SHARED_READ_ONLY &#x2F; SHARED_NO_READ_WRITE</td><td></td></tr><tr><td>select、select … lock in share mode</td><td>SHARED_READ</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>insert、update、delete、select … for update</td><td>SHARED_WRITE</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>alter table ……</td><td>EXCLUSIVE</td><td>与其它的MDL都互斥</td></tr></tbody></table><p>查看元数据锁</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_type,object_schema,object_name,lock_type,lock_duration <span class="keyword">from</span> performance_schema.metadata_locks;</span><br></pre></td></tr></table></figure></div><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>意向锁的主要作用是实现多粒度锁定（即表级和行级锁定）的高效管理。通过在表级别使用意向锁，InnoDB可以快速确定某个事务是否可以安全地在行级别加锁，而不需要检查表中的每一行是否已被其他事务锁定。</p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240803205817.png" alt="image-20240803205817547"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240803205834.png" alt="image-20240803205834335"></p><ol><li>意向共享锁（IS）：由语句 <strong>select … lock in share mode</strong> 添加。<ul><li>与表锁共享锁（read）兼容，与表锁排他锁（write）互斥</li></ul></li><li>意向排他锁（IX）：由<strong>insert、update、delete、select … for update</strong>添加。<ul><li>与表锁共享锁（read）及排他锁（write）都互斥。意向锁之间不会互斥。</li></ul></li></ol><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure></div><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><h4 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h4><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ol><li>行锁（Record Lock）：锁定单个行记录的锁，防止其它事务对此行进行update和delete。在RC、RR隔离级别下都支持。</li><li>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录，开区间），确保索引记录间隙不变，防止其它事务在这个间隙进行insert，产生幻读。在RR隔离级别下支持。</li><li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap，在RR隔离级别下支持。</li></ol><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>InnoDB实现了以下两种类型的行锁：</p><ol><li>共享锁（S）：允许一个事务去读一行，阻止其它事务获得相同数据集的排他锁。</li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其它事务获得相同数据集的共享锁和排他锁。</li></ol><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240803221030.png"></p><p><strong>SQL语句的行锁类型：</strong></p><table><thead><tr><th>SQL</th><th>行锁类型</th><th>说明</th></tr></thead><tbody><tr><td>insert ……</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>update ……</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>delete ……</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>select（正常）</td><td><strong>不加任何锁</strong></td><td></td></tr><tr><td>select……lock in share mode</td><td>共享锁</td><td>需要手动在select之后加lock in share mode</td></tr><tr><td>select……for update</td><td>排他锁</td><td>需要手动在select之后加for update</td></tr></tbody></table><blockquote><p>默认情况下，InnoDB在repeatable read事务隔离级别运行，InnoDB使用 next-key锁进行搜索和索引扫描，以防止幻读。</p><ol><li>针对唯一索引进行检验索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li><li>InnoDB的行锁是针对索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时<strong>就会升级为表锁</strong>。</li></ol></blockquote><h4 id="间隙锁-临键锁"><a href="#间隙锁-临键锁" class="headerlink" title="间隙锁&#x2F;临键锁"></a>间隙锁&#x2F;临键锁</h4><p>默认情况下，InnoDB 在 repeatable read 事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ol><li>索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。</li><li>索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁。</li><li>索引上的范围查询（唯一索引）–会访问到不满足条件的第一个值为止。</li></ol><blockquote><p><strong>注意：</strong></p><p>间隙锁唯一目的是防止其它事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p></blockquote><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul><li>全局锁<ul><li>对整个数据库实例加锁，加锁后整个实例就处于只读状态</li><li>性能较差，数据逻辑备份时使用</li></ul></li><li>表级锁<ul><li>操作锁住整张表，锁定颗粒度大，发生锁冲突的概率高</li><li>表锁，元数据锁，意向锁</li></ul></li><li>行级锁<ul><li>操作锁住对应的行数据，锁定颗粒度最小，发生锁冲突的概率最低</li><li>行锁，间隙锁，临键锁</li></ul></li></ul><h2 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h2><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804170348.png" alt="image-20240804170347868"></p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>MySQL5.5版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804170802.png" alt="image-20240804170802270"></p><h4 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h4><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804172201.png" alt="image-20240804172200790"></p><p><strong>Change Buffer的意义是什么？</strong><br>与聚焦索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了Change Buffer之后，我们可以在缓冲池中合并处理，减少磁盘IO。【<strong>针对的是非唯一的二级索引页</strong>】</p><p><strong>Buffer Pool 和 Change Buffer 的主要区别：</strong></p><ul><li>用途不同：Buffer Pool 用于缓存所有类型的数据页和索引页，而 Change Buffer 仅用于缓存非唯一二级索引的修改。</li><li>缓存内容：Buffer Pool 缓存的是实际的数据页和索引页，Change Buffer 缓存的是对非唯一二级索引的<strong>变更操作</strong>。</li><li>写入时机：Buffer Pool 中的脏页会在适当的时候异步写回磁盘，而 Change Buffer中的变更会在索引页被访问或后台定期合并时写入磁盘。</li></ul><p><strong>Change Buffer缓存的是对应的变更操作</strong></p><p>变更信息结构通常包括：</p><ol><li>索引页的Page ID：指示要修改的二级索引页在磁盘上的位置。</li><li>变更类型：插入（insert）、更新（update）、删除（delete）</li><li>索引键值：要变更的索引项的具体键值。</li><li>变更的具体数据：包括插入的新索引项、更新后的索引项或删除的索引项。</li></ol><blockquote><p>eg：<br>假设我们有一个表<code>employees</code>，其非唯一二级索引<code>idx_salary</code>记录了员工的工资信息。<br>现在插入一条新记录：</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> employees (id,name,salary) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;Alice&#x27;</span>,<span class="number">5000</span>);</span><br></pre></td></tr></table></figure></div><p>这条插入操作在 Change Buffer 中的变更信息可能类似如下：</p><ul><li>Page ID：1234 （假设索引页ID为1234）</li><li>变更类型：Insert</li><li>索引键值：（salary&#x3D;5000，id&#x3D;1）</li><li>变更数据：将（salary&#x3D;5000，id&#x3D;1）插入索引页</li></ul><div class="code-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;page_id&quot;</span><span class="punctuation">:</span> <span class="number">1234</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;change_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;insert&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;index_key&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;salary&quot;</span><span class="punctuation">:</span> <span class="number">5000</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;change_data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;insert&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> (<span class="number">5000</span><span class="punctuation">,</span> <span class="number">1</span>)<span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>相关数据<span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page_id: 这是需要变更的二级索引页在磁盘上的位置。</span></span><br><span class="line"><span class="comment">// change_type: 表示变更的类型，在这个例子中是插入操作。</span></span><br><span class="line"><span class="comment">// index_key: 要变更的索引项的键值，表示salary和id。</span></span><br><span class="line"><span class="comment">// change_data: 具体的变更数据，这里是插入操作，将键值(salary=5000, id=1)插入索引页。</span></span><br></pre></td></tr></table></figure></div></blockquote><h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804190657.png" alt="image-20240804190657195"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804190711.png" alt="image-20240804190710823"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804190718.png" alt="image-20240804190718542"></p><h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804191845.png" alt="image-20240804191845143"></p><h3 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h3><h4 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h4><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p><strong>特性</strong></p><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（DUrability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804193258.png" alt="image-20240804193257888"></p><h4 id="redo-log-持久性"><a href="#redo-log-持久性" class="headerlink" title="redo log(持久性)"></a>redo log(持久性)</h4><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。<br>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805155500.png"></p><h4 id="undo-log-原子性"><a href="#undo-log-原子性" class="headerlink" title="undo log(原子性)"></a>undo log(原子性)</h4><p>回滚日志，用于记录数据被修改前的信息，作用包含两个：<strong>提供回滚</strong>和<strong>MVCC(多版本并发控制)</strong>。<br>undo log 和 redo log记录物理日志不一样，它记录的是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行 roll back 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。</p><ul><li>undo log的销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</li><li>undo log的存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 roll back segment 回滚段中，内部包含1024个undo log segment。</li></ul><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><h5 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h5><ul><li><p>当前读</p><p>读取的是记录的最新版本，读取时还要保证其它并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：<strong>select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读。</strong></p></li><li><p>快照读</p><p><strong>简单的select（不加锁）就是快照读</strong>，快照读读取的是记录数据的可见版本，有可能是历史数据。不加锁，是非阻塞读。</p><ul><li>Read Committed：每次select，都生成一个快照读。</li><li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li><li>Serializable：快照读会退化为当前读。</li></ul></li><li><p>MVCC</p><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p></li></ul><h4 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h4><table><thead><tr><th>隐藏字段</th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</td></tr><tr><td>DB_ROLL_PIR</td><td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</td></tr></tbody></table><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。<br>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。<br>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p><ul><li>undo log 版本链</li></ul><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804205208.png"></p><h4 id="readView"><a href="#readView" class="headerlink" title="readView"></a>readView</h4><p>readView（读视图）是 <strong>快照读</strong> SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p><p>readView中包含了四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务ID集合（所有未提交的事务集合）</td></tr><tr><td>min_trx_id</td><td>最小活跃事务ID</td></tr><tr><td>max_trx_id</td><td>预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td></tr><tr><td>creator_trx_id</td><td>readView创建者的事务ID</td></tr></tbody></table><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804210219.png" alt="image-20240804210219378"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804211326.png"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804211435.png" alt="image-20240804211434665"></p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志是MySQL中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。</p><p>该日志是默认开启的，默认存放目录 &#x2F;var&#x2F;log&#x2F;，默认的日志文件名为 mysqld.log 。查看日志位置的SQL语句：</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_error%&#x27;</span></span><br></pre></td></tr></table></figure></div><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><ul><li><p>介绍</p><p>二进制日志（BINLOG）记录了所有的DDL（数据定义语言）语句和DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW）语句。</p><p>作用：</p><pre><code>1. 灾难时的数据恢复；
1. MySQL的主从复制，在MySQL8版本中，默认二进制日志是开启着的，涉及到的参数如下：
</code></pre><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805171448.png" alt="image-20240805171447473"></p></li><li><p>日志格式</p><table><thead><tr><th>日志格式</th><th>含义</th></tr></thead><tbody><tr><td>STATEMENT</td><td>基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中。</td></tr><tr><td>ROW</td><td>基于行的日志记录，记录的是每一行的数据变更。（默认）</td></tr><tr><td>MIXED</td><td>混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会自动切换为ROW进行记录。</td></tr></tbody></table><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_format%&#x27;</span>; <span class="comment">-- 查看</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span><span class="operator">/</span>session binlog_format <span class="operator">=</span> <span class="string">&#x27;ROW&#x27;</span><span class="operator">/</span><span class="string">&#x27;STATEMENT&#x27;</span><span class="operator">/</span>……;</span><br></pre></td></tr></table></figure></div></li><li><p>日志查看</p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805173557.png" alt="image-20240805173557201"></p></li></ul><p><strong>ROW格式下查看的日志格式：</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805174014.png" alt="image-20240805174014623"></p><p><strong>STATEMENT格式下查看的日志格式：</strong></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805174134.png" alt="image-20240805174134528"></p><ul><li><p>日志删除</p><p>对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量的磁盘空间。可以通过以下几种方式清理日志：</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>reset master</td><td>删除全部binlog日志，删除之后，日志编号将从binlog.000001重新开始。</td></tr><tr><td>purge master logs to ‘binlog.******‘</td><td>删除 *<em>***</em>* 编号之前的所有日志，不包含该日志。</td></tr><tr><td>purge master logs before ‘yyyy-mm-dd hh:mi:ss’</td><td>删除日志为”yyyy-mm-dd hh:mi:ss”之前产生的所有日志，这里的hh是24小时制的。</td></tr></tbody></table><p>也可以在mysql的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除。</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_expire_logs_seconds%&#x27;</span>; <span class="comment">-- 默认设置是30天</span></span><br></pre></td></tr></table></figure></div></li></ul><h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。默认情况下，查询日志是未开启的。如果需要开启查询日志，可以设置以下配置：</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看查询日志的开启状态</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805181122.png" alt="image-20240805181121871"></p><p>修改MySQL的配置文件 &#x2F;etc&#x2F;my.cnf 文件，添加如下内容：</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 该选项用来开启查询日志，可选值：<span class="number">0</span>或者<span class="number">1</span>；<span class="number">0</span>代表关闭，<span class="number">1</span>代表开启</span><br><span class="line">general_log <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"># 设置日志的文件名，如果没有指定，默认的文件名为 host_name.log</span><br><span class="line">general_log_file <span class="operator">=</span> mysql_query.log</span><br></pre></td></tr></table></figure></div><p>文件内容示图：</p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805181610.png" alt="image-20240805181609856"></p><h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的SQL语句的日志，默认未开启。long_query_time 默认为10秒，最小为0，精度可以准确到微妙。</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在<span class="operator">/</span>etc<span class="operator">/</span>my.cnf配置文件中添加如下内容</span><br><span class="line"># 开启慢查询日志</span><br><span class="line">slow_query_log <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"># 执行时间参数</span><br><span class="line">long_query_time <span class="operator">=</span> <span class="number">2</span> <span class="comment">-- 设置成2s</span></span><br></pre></td></tr></table></figure></div><p>默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以使用 log_slow_admin_statements 和log_queries_not_using_indexes 更改此行为。</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 记录执行较慢的管理语句</span><br><span class="line">log_slow_admin_statements <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">#记录执行较慢的未使用索引的语句</span><br><span class="line">log_queries_not_using_indexes <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></div><p>查询示图</p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805183430.png" alt="image-20240805183430193"></p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>主从复制是指将主数据库的DDL和DML操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p><p>MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其它从服务器的主库，实现链状复制。</p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805190532.png" alt="image-20240805190531871"></p><blockquote><p>MySQL 的主从复制（Replication）是一种用于将数据从一个 MySQL 服务器（主服务器）复制到一个或多个 MySQL 服务器（从服务器）的机制。主从复制的主体是<strong>整个服务器</strong>，而不是单独的数据库或表。</p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805190731.png" alt="image-20240805190731673"></p><h3 id="服务器准备"><a href="#服务器准备" class="headerlink" title="服务器准备"></a>服务器准备</h3><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805191623.png" alt="image-20240805191623628"></p><h3 id="主库配置"><a href="#主库配置" class="headerlink" title="主库配置"></a>主库配置</h3><ol><li>修改配置文件 &#x2F;etc&#x2F;my.cnf</li></ol><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># mysql服务ID，保证整个集群环境中唯一，取值范围：<span class="number">1</span> <span class="operator">~</span> <span class="number">2</span><span class="operator">^</span><span class="number">32</span> <span class="number">-1</span>,默认值为<span class="number">1</span></span><br><span class="line">server<span class="operator">-</span>id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"># 是否只读，<span class="number">1</span>代表只读，<span class="number">0</span>代表读写</span><br><span class="line">read<span class="operator">-</span><span class="keyword">only</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"># 忽略的数据，指不需要同步的数据库</span><br><span class="line"># binlog<span class="operator">-</span>ignore<span class="operator">-</span>db <span class="operator">=</span> mysql</span><br><span class="line"># 指定同步的数据库</span><br><span class="line">#binlog<span class="operator">-</span>do<span class="operator">-</span>db<span class="operator">=</span>db01</span><br></pre></td></tr></table></figure></div><ol start="2"><li>重启MySQL服务器</li></ol><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld <span class="comment">-- 针对Linux而言</span></span><br></pre></td></tr></table></figure></div><ol start="3"><li>登录MySQL，创建远程连接的账号，并赋予主从复制的权限</li></ol><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建itcast用户，并设置密码，该用户可以在任意主机连接该MySQL服务</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;%&#x27;</span> indentified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;Root@123456&#x27;</span>;</span><br><span class="line"># 为<span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;%&#x27;</span>用户分配主从复制权限</span><br><span class="line"><span class="keyword">grant</span> replication slave <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure></div><ol start="4"><li>通过指令，查看二进制日志坐标</li></ol><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure></div><p>字段含义说明：</p><ul><li>file：从哪个日志文件开始推送日志文件</li><li>position：从哪个位置开始推送日志</li><li>binlog_ignore_db：指定不需要同步的数据库</li></ul><h3 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h3><ol><li>修改配置文件 &#x2F;etc&#x2F;my.cnf</li></ol><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># mysql服务ID，保证在整个集群环境中唯一，取值范围：<span class="number">1</span> <span class="operator">~</span> <span class="number">2</span><span class="operator">^</span><span class="number">32</span> <span class="number">-1</span>，和主库不一样即可</span><br><span class="line">server<span class="operator">-</span>id <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">#是否只读，<span class="number">1</span>代表只读，<span class="number">0</span>代表读写</span><br><span class="line">read<span class="operator">-</span><span class="keyword">only</span> <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></div><ol start="2"><li>重启MySQL服务</li></ol><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld; <span class="comment">-- 针对Linux而言</span></span><br></pre></td></tr></table></figure></div><ol start="3"><li>登录MySQL，设置主库配置</li></ol><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">8.0</span><span class="number">.23</span>之后的语法</span><br><span class="line">change replication source <span class="keyword">to</span> source_host<span class="operator">=</span><span class="string">&#x27;xxx.xxx&#x27;</span>, source_user<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>,source_password<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>,source_log_file<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>,source_log_pos<span class="operator">=</span>xxx;</span><br><span class="line"></span><br><span class="line"># <span class="number">8.0</span><span class="number">.23</span>之前的语法</span><br><span class="line">change master source <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;xxx.xxx&#x27;</span>, master_user<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>,master_log_pos<span class="operator">=</span>xxx;</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805194728.png" alt="image-20240805194727987"></p><ol start="4"><li>开启同步操作</li></ol><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> replica; # <span class="number">8.0</span><span class="number">.22</span>之后</span><br><span class="line"><span class="keyword">start</span> slave; # <span class="number">8.0</span><span class="number">.22</span>之前</span><br></pre></td></tr></table></figure></div><ol start="5"><li>查看主从同步状态</li></ol><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> replica status; # <span class="number">8.0</span><span class="number">.22</span>之后</span><br><span class="line"><span class="keyword">show</span> slave status; # <span class="number">8.0</span><span class="number">.22</span>之前</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805195127.png" alt="image-20240805195127196"></p><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807193841.png" alt="image-20240807193834457"></p><h3 id="拆分方式"><a href="#拆分方式" class="headerlink" title="拆分方式"></a>拆分方式</h3><h4 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h4><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807184355.png"></p><h4 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h4><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807184414.png"></p><h4 id="实现技术"><a href="#实现技术" class="headerlink" title="实现技术"></a>实现技术</h4><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807184447.png"></p><h3 id="Mycat"><a href="#Mycat" class="headerlink" title="Mycat"></a>Mycat</h3><h4 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h4><p>Mycat是开源的、活跃的，基于Java语言编写的MySQL<strong>数据库中间件</strong>。可以像使用MySQL一样来使用Mycat，对于开发人员来说根本感觉不到Mycat的存在。【Mycat使用了MySQL的伪装协议】</p><p>优势：</p><ol><li>性能可靠稳定</li><li>强大的技术团队</li><li>体系完善</li><li>社区活跃</li></ol><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807194522.png" alt="image-20240807194522163"></p><p>结构示图：</p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807194728.png" alt="image-20240807194728336"></p><h4 id="启动与连接-1"><a href="#启动与连接-1" class="headerlink" title="启动与连接"></a>启动与连接</h4><ul><li><p>启动服务</p><p>切换到Mycat的安装目录，执行如下指令，启动Mycat：</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 启动</span><br><span class="line">bin<span class="operator">/</span>mycat <span class="keyword">start</span></span><br><span class="line"># 停止</span><br><span class="line">bin<span class="operator">/</span>mycat stop</span><br></pre></td></tr></table></figure></div><p><strong>Mycat启动之后，占用端口号 8066</strong></p></li><li><p>连接Mycat</p><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h 主机号 <span class="operator">-</span>P <span class="number">8066</span>[端口号] <span class="operator">-</span>u 用户名 <span class="operator">-</span>p;</span><br></pre></td></tr></table></figure></div></li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><h5 id="schema-xml"><a href="#schema-xml" class="headerlink" title="schema.xml"></a>schema.xml</h5><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807201109.png" alt="image-20240807201109146"></p><p>schema.xml作为Mycat中最重要的配置文件之一，涵盖了Mycat的逻辑库、逻辑表、分片规则、分片节点及数据源的配置。</p><p>主要包含以下三组标签：</p><ol><li>schema标签</li><li>datanode标签</li><li>datahost标签</li></ol><p><em><strong>schema标签</strong></em></p><p>schema标签用于定义Mycat实例中的逻辑库，一个Mycat实例中，可以有多个逻辑库，可以通过schema标签来划分不同的数据库。</p><p>Mycat中逻辑库的概念，等同于MySQL中的database概念，需要操作某个逻辑库下的表时，也需要切换逻辑库（use xxx）。</p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807201702.png" alt="image-20240807201702402"></p><p>核心属性：</p><ul><li>**name：**指定自定义的逻辑库库名</li><li>**checkSQLschema：**在SQL语句操作时指定了数据库名，执行时是否自动去除；true：自动去除，false：不自动去除</li><li>**sqlMaxLimit：**如果未指定limit进行查询，列表查询模式最多查询多少条记录</li></ul><p><em><strong>schema标签(table)</strong></em></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807203508.png" alt="image-20240807203508570"></p><p>table标签定义了Mycat中数据库schema下的逻辑表，所有需要拆分的表都需要在table标签中的定义。</p><ul><li>**name：**自定义逻辑表名，在该逻辑库下唯一</li><li>**dataNode：**定义逻辑表所属的dataNode，该属性需要与dataNode标签中name对应；多个dataNode逗号分隔</li><li>**rule：**分片规则的名字，分片规则名字是在<code>rule.xml</code>中定义的</li><li>**primaryKey：**逻辑表对应真实表的主键</li><li>**type：**逻辑表的类型，目前逻辑表只有全局表和普通表，如果未配置，就是普通表；全局表，配置为global</li></ul><p><em><strong>dataNode标签</strong></em></p><p>dataNode标签中定义了Mycat中的数据节点，也就是我们通常说的数据分片。一个dataNode标签就是一个独立的数据节点。</p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807205018.png" alt="image-20240807205018175"></p><p>核心属性：</p><ul><li>**name：**定义数据节点名称</li><li>**dataHost：**数据库实例主机名称，引用自 dataHost 标签中的name属性</li><li>**database：**定义分片所属数据库</li></ul><p><em><strong>dataHost标签</strong></em></p><p>该标签在Mycat逻辑库中作为底层标签存在，直接定义了具体的数据库实例、读写分离、心跳语句。</p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807205450.png" alt="image-20240807205450186"></p><p>核心属性：</p><ul><li>**name：**唯一标识，供上层标签使用</li><li>**maxCon&#x2F;minCon：**最大连接数&#x2F;最小连接数</li><li>**balance：**负载均衡策略，取值0，1，2，3</li><li>**writeType：**写操作分发方式（0：写操作转发到第一个writeHost，第一个挂了，切换到第二个；1：写操作随机分发到配置的writeHost）</li><li>**dbDriver：**数据库驱动，支持native、jdbc</li></ul><p><em>小结：</em></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807210444.png" alt="image-20240807210444239"></p><h5 id="rule-xml"><a href="#rule-xml" class="headerlink" title="rule.xml"></a>rule.xml</h5><p>rule.xml中定义所有拆分表的规则，在使用过程中可以灵活的使用分片算法，或者对同一个分片算法使用不同的参数，它让分片过程可配置化。主要包含两类标签：tableRule、Function。</p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807211807.png" alt="image-20240807211807001"></p><h5 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h5><p>server.xml配置文件包含了Mycat的系统配置信息，主要有两个重要的标签：system、user。</p><p><em><strong>system标签</strong></em></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807212245.png" alt="image-20240807212245198"></p><p>对应的系统配置项及其含义参考下列表格：</p><table><thead><tr><th>属性</th><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>charset</td><td>utf8</td><td>设置Mycat的字符集, 字符集需要与MySQL的字符集保持一致</td></tr><tr><td>nonePasswordLogin</td><td>0,1</td><td>0为需要密码登陆、1为不需要密码登陆 ,默认为0，设置为1则需要指定默认账户</td></tr><tr><td>useHandshakeV10</td><td>0,1</td><td>使用该选项主要的目的是为了能够兼容高版本的jdbc驱动, 是否采用HandshakeV10Packet来与client进行通信, 1:是, 0:否</td></tr><tr><td>useSqlStat</td><td>0,1</td><td>开启SQL实时统计, 1 为开启 , 0 为关闭 ; 开启之后, MyCat会自动统计SQL语句的执行情况 ; mysql -h 127.0.0.1 -P 9066 -u root -p 查看MyCat执行的SQL, 执行效率比较低的SQL , SQL的整体执行情况、读写比例等 ; show @@sql ; show @@sql.slow ; show @@sql.sum ;</td></tr><tr><td>useGlobleTableCheck</td><td>0,1</td><td>是否开启全局表的一致性检测。1为开启 ，0为关闭 。</td></tr><tr><td>sqlExecuteTimeout</td><td>1000</td><td>SQL语句执行的超时时间 , 单位为 s ;</td></tr><tr><td>sequnceHandlerType</td><td>0,1,2</td><td>用来指定Mycat全局序列类型，0 为本地文件，1 为数据库方式，2 为时间戳列方式，默认使用本地文件方式，文件方式主要用于测试</td></tr><tr><td>sequnceHandlerPattern</td><td>正则表达式</td><td>必须带有MYCATSEQ或者 mycatseq进入序列匹配流程 注意MYCATSEQ_有空格的情况</td></tr><tr><td>subqueryRelationshipCheck</td><td>true,false</td><td>子查询中存在关联查询的情况下,检查关联字段中是否有分片字段 .默认 false</td></tr><tr><td>useCompression</td><td>0,1</td><td>开启mysql压缩协议 , 0 : 关闭, 1 : 开启</td></tr><tr><td>fakeMySQLVersion</td><td>5.5,5.6</td><td>设置模拟的MySQL版本号</td></tr><tr><td>defaultSqlParser</td><td></td><td>由于MyCat的最初版本使用了FoundationDB的SQL解析器, 在MyCat1.3后增加了Druid解析器, 所以要设置defaultSqlParser属性来指定默认的解析器; 解析器有两个 : druidparser 和 fdbparser, 在MyCat1.4之后,默认是druidparser, fdbparser已经废除了</td></tr><tr><td>processors</td><td>1,2….</td><td>指定系统可用的线程数量, 默认值为CPU核心 x 每个核心运行线程数量; processors 会影响processorBufferPool, processorBufferLocalPercent, processorExecutor属性, 所有, 在性能调优时, 可以适当地修改processors值</td></tr><tr><td>processorBufferChunk</td><td></td><td>指定每次分配Socket Direct Buffer默认值为4096字节, 也会影响BufferPool长度, 如果一次性获取字节过多而导致buffer不够用, 则会出现警告, 可以调大该值</td></tr><tr><td>processorExecutor</td><td></td><td>指定NIOProcessor上共享 businessExecutor固定线程池的大小; MyCat把异步任务交给 businessExecutor线程池中, 在新版本的MyCat中这个连接池使用频次不高, 可以适当地把该值调小</td></tr><tr><td>packetHeaderSize</td><td></td><td>指定MySQL协议中的报文头长度, 默认4个字节</td></tr><tr><td>maxPacketSize</td><td></td><td>指定MySQL协议可以携带的数据最大大小, 默认值为16M</td></tr><tr><td>idleTimeout</td><td>30</td><td>指定连接的空闲时间的超时长度;如果超时,将关闭资源并回收, 默认30分钟</td></tr><tr><td>txIsolation</td><td>1,2,3,4</td><td>初始化前端连接的事务隔离级别,默认为 REPEATED_READ , 对应数字为3 READ_UNCOMMITED&#x3D;1; READ_COMMITTED&#x3D;2; REPEATED_READ&#x3D;3; SERIALIZABLE&#x3D;4;</td></tr><tr><td>sqlExecuteTimeout</td><td>300</td><td>执行SQL的超时时间, 如果SQL语句执行超时,将关闭连接; 默认300秒;</td></tr><tr><td>serverPort</td><td>8066</td><td>定义MyCat的使用端口, 默认8066</td></tr><tr><td>managerPort</td><td>9066</td><td>定义MyCat的管理端口, 默认9066</td></tr></tbody></table><p><em><strong>user标签</strong></em></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807212422.png" alt="image-20240807212421991"></p><h4 id="分片规则"><a href="#分片规则" class="headerlink" title="分片规则"></a>分片规则</h4><h5 id="范围分片"><a href="#范围分片" class="headerlink" title="范围分片"></a>范围分片</h5><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807220135.png" alt="image-20240807220135577"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807220149.png" alt="image-20240807220149320"></p><h5 id="去模分片"><a href="#去模分片" class="headerlink" title="去模分片"></a>去模分片</h5><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807220236.png" alt="image-20240807220236397"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807220250.png" alt="image-20240807220249980"></p><h5 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h5><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807220807.png" alt="image-20240807220807274"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807220818.png" alt="image-20240807220818067"></p><h5 id="枚举分片"><a href="#枚举分片" class="headerlink" title="枚举分片"></a>枚举分片</h5><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807221140.png" alt="image-20240807221140275"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807221240.png" alt="image-20240807221240239"></p><h5 id="应用指定"><a href="#应用指定" class="headerlink" title="应用指定"></a>应用指定</h5><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807223441.png" alt="image-20240807223440974"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807223453.png" alt="image-20240807223453361"></p><h5 id="固定分片hash算法"><a href="#固定分片hash算法" class="headerlink" title="固定分片hash算法"></a>固定分片hash算法</h5><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807223530.png" alt="image-20240807223530065"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807223543.png" alt="image-20240807223542684"></p><h5 id="字符串hash解析"><a href="#字符串hash解析" class="headerlink" title="字符串hash解析"></a>字符串hash解析</h5><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807224800.png" alt="image-20240807224800100"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807224813.png" alt="image-20240807224813189"></p><h5 id="按（天）日期分片"><a href="#按（天）日期分片" class="headerlink" title="按（天）日期分片"></a>按（天）日期分片</h5><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807224949.png" alt="image-20240807224949404"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807225009.png" alt="image-20240807225008912"></p><h5 id="自然月"><a href="#自然月" class="headerlink" title="自然月"></a>自然月</h5><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807225025.png" alt="image-20240807225024836"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807225048.png" alt="image-20240807225048044"></p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808100902.png" alt="image-20240808100854948"></p><h4 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h4><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808101218.png" alt="image-20240808101217635"></p><h4 id="管理工具"><a href="#管理工具" class="headerlink" title="管理工具"></a>管理工具</h4><p><strong>Mycat-eye</strong></p><p>Mycat-web（Mycat-eye）是对Mycat-server提供监控服务，功能不局限于对Mycat-server使用。他通过JDBC连接对Mycat、MySQL监控，监控远程服务（目前仅局限于Linux系统）的CPU、内存、网络、磁盘。</p><p>Mycat-eye运行过程中需要依赖zookeeper。</p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>读写分离，简单地说就是把数据库的读和写操作分开，以对应不同的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。</p><p>通过Mycat即可轻易实现上述功能，不仅可以支持MySQL，也可以支持Oracle和SQL Server。</p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808111617.png" alt="image-20240808111616641"></p><h3 id="一主一从读写分离"><a href="#一主一从读写分离" class="headerlink" title="一主一从读写分离"></a>一主一从读写分离</h3><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808111701.png" alt="image-20240808111701174"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808111709.png" alt="image-20240808111709697"></p><h3 id="双主双从读写分离"><a href="#双主双从读写分离" class="headerlink" title="双主双从读写分离"></a>双主双从读写分离</h3><ul><li>双主双重介绍</li></ul><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808111956.png" alt="image-20240808111956237"></p><ul><li>双主双重的搭建</li></ul><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808112637.png" alt="image-20240808112636652"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808112648.png" alt="image-20240808112648091"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808112655.png" alt="image-20240808112654844"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808112700.png" alt="image-20240808112659878"></p><ul><li>双主双从的读写分离</li></ul><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808113017.png" alt="image-20240808113016811"></p><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808113025.png" alt="image-20240808113025031"></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="单引号-vs-双引号"><a href="#单引号-vs-双引号" class="headerlink" title="单引号 vs. 双引号"></a>单引号 vs. 双引号</h3><p>在 SQL 中，字符串通常是用单引号 (<code>&#39;</code>) 包围起来的，这是标准的 SQL 规范。然而，不同的数据库管理系统（如 MySQL、PostgreSQL、SQL Server 等）可能有各自的一些特殊规则和扩展，允许在某些情况下使用双引号，但通常是用于其他目的。以下是一些常见的情况：</p><ol><li><p><strong>标准 SQL</strong>：</p><ul><li>字符串必须用单引号包围。例如：<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li></ul></li><li><p><strong>双引号的用途</strong>：</p><ul><li>在标准 SQL 中，双引号 (<code>&quot;</code>) 通常用于标识符（如表名、列名）而非字符串。例如：<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &quot;column_name&quot; <span class="keyword">FROM</span> &quot;table_name&quot;;</span><br></pre></td></tr></table></figure></div></li><li>双引号可以用于表示区分大小写的标识符（例如 PostgreSQL 中的表或列名）。</li></ul></li><li><p><strong>使用双引号表示字符串</strong>：</p><ul><li>某些数据库（如 MySQL）可能允许你在 SQL 模式中启用 <code>ANSI_QUOTES</code> 选项，从而将双引号用于字符串。这种情况下，双引号和单引号的作用类似，但这种用法并不符合标准 SQL 规范：<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION sql_mode <span class="operator">=</span> <span class="string">&#x27;ANSI_QUOTES&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;John&quot;;  <span class="comment">-- 这种用法在启用了 ANSI_QUOTES 模式后有效</span></span><br></pre></td></tr></table></figure></div></li></ul></li><li><p><strong>数据库特定的字符串分隔符</strong>：</p><ul><li>某些数据库还支持自定义分隔符，比如 PostgreSQL 支持用 <code>E&#39;...&#39;</code> 处理带有转义字符的字符串，或用 <code>$$... $$</code> 表示大文本块（如函数体）。</li></ul></li></ol><p>因此，在标准 SQL 和大多数数据库的默认配置下，字符串应当使用单引号包围。如果需要使用双引号，必须确认数据库的特定配置或扩展支持这一功能。一般情况下，为了确保跨数据库的兼容性，使用单引号是最安全的做法。</p></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>Title:</strong> MySQL基础</li><li><strong>Author:</strong> Lu</li><li><strong>Created at :</strong> 2024-05-21 15:45:35</li><li><strong>Updated at :</strong> 2025-03-14 15:04:13</li><li><strong>Link:</strong> https://lusy.ink/2024/05/21/MySQL基础/</li><li><strong>License: </strong>This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/MySQL/">#MySQL</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/2024/05/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item">Java 多线程</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/2024/05/21/JDBC/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">JDBC</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div><div class="comment-container px-2 sm:px-6 md:px-8 pb-8"><div class="comments-container mt-10 w-full"><div id="comment-anchor" class="w-full h-2.5"></div><div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">Comments</div><div id="waline"></div><script type="module" data-swup-reload-script>import{init}from"/js/libs/waline.mjs";function loadWaline(){init({el:"#waline",serverURL:"https://comment.lusy.ink",lang:"zh-CN",dark:'body[class~="dark-mode"]',reaction:!1,requiredMeta:["nick","mail"],emoji:[]})}"undefined"!=typeof swup?loadWaline():window.addEventListener("DOMContentLoaded",loadWaline)</script></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">On this page</div><div class="page-title">MySQL基础</div><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="nav-text">SQL基本命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%8E%E8%BF%9E%E6%8E%A5"><span class="nav-text">启动与连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E9%80%9A%E7%94%A8%E8%AF%AD%E6%B3%95"><span class="nav-text">SQL通用语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DDL-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80"><span class="nav-text">DDL(数据定义语言)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="nav-text">数据库操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E6%93%8D%E4%BD%9C"><span class="nav-text">表操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DML-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80"><span class="nav-text">DML(数据操作语言)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-INSERT"><span class="nav-text">插入数据(INSERT)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE-UPDATE"><span class="nav-text">修改数据(UPDATE)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE-DELETE"><span class="nav-text">删除数据(DELETE)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DQL-%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80"><span class="nav-text">DQL(数据查询语言)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="nav-text">聚合函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2"><span class="nav-text">条件查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2"><span class="nav-text">分组查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2"><span class="nav-text">排序查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="nav-text">分页查询</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DCL-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80"><span class="nav-text">DCL(数据控制语言)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7"><span class="nav-text">管理用户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="nav-text">权限控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%9D%83%E9%99%90"><span class="nav-text">常用权限</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%BC%96%E5%86%99%E9%A1%BA%E5%BA%8F"><span class="nav-text">SQL关键字的编写顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%89%A7%E8%A1%8C%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">SQL关键字的执行优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="nav-text">字符串函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0"><span class="nav-text">数值函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="nav-text">日期函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="nav-text">流程函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9F"><span class="nav-text">约束</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="nav-text">外键约束</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="nav-text">多表查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB"><span class="nav-text">多表关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2-1"><span class="nav-text">多表查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="nav-text">联合查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-text">子查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E9%87%8F%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-text">标量子查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-text">行子查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-text">列子查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-text">表子查询</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9"><span class="nav-text">主要内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">基本操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">MySQL体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E6%93%8E"><span class="nav-text">引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-text">常用指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB"><span class="nav-text">InnoDB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MyISAM"><span class="nav-text">MyISAM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory"><span class="nav-text">Memory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E5%BC%95%E6%93%8E%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E9%80%89%E6%8B%A9"><span class="nav-text">不同引擎的区别与选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-text">结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-text">分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-text">语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-text">性能分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99"><span class="nav-text">使用原则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="nav-text">最左前缀法则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="nav-text">范围查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-text">索引失效的情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL%E6%8F%90%E7%A4%BA"><span class="nav-text">SQL提示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-text">覆盖索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="nav-text">前缀索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-text">单列索引与联合索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-text">设计原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="nav-text">SQL优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#insert%E4%BC%98%E5%8C%96"><span class="nav-text">insert优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96"><span class="nav-text">主键优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#order-by%E4%BC%98%E5%8C%96"><span class="nav-text">order by优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#group-by%E4%BC%98%E5%8C%96"><span class="nav-text">group by优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#limit%E4%BC%98%E5%8C%96"><span class="nav-text">limit优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#count%E4%BC%98%E5%8C%96"><span class="nav-text">count优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#update%E4%BC%98%E5%8C%96"><span class="nav-text">update优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE"><span class="nav-text">视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0"><span class="nav-text">更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-text">作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">存储过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="nav-text">系统变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="nav-text">用户定义变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-text">局部变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F-VS-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-text">用户定义变量 VS 局部变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0"><span class="nav-text">参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5"><span class="nav-text">判断语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#if"><span class="nav-text">if</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#case"><span class="nav-text">case</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="nav-text">循环语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#while"><span class="nav-text">while</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#repeat"><span class="nav-text">repeat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#loop"><span class="nav-text">loop</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%B8%E6%A0%87"><span class="nav-text">游标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-text">条件处理程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="nav-text">存储函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-text">触发器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81"><span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="nav-text">全局锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-3"><span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="nav-text">语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="nav-text">表级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-4"><span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E9%94%81"><span class="nav-text">表锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81%EF%BC%88meta-data-lock%EF%BC%8CMDL%EF%BC%89"><span class="nav-text">元数据锁（meta data lock，MDL）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="nav-text">意向锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="nav-text">行级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-5"><span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E9%94%81"><span class="nav-text">行锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%B4%E9%9A%99%E9%94%81-%E4%B8%B4%E9%94%AE%E9%94%81"><span class="nav-text">间隙锁&#x2F;临键锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="nav-text">小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB%E5%BC%95%E6%93%8E"><span class="nav-text">InnoDB引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">逻辑存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84"><span class="nav-text">架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-text">内存结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="nav-text">磁盘结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="nav-text">后台线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86"><span class="nav-text">事务原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1-1"><span class="nav-text">事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redo-log-%E6%8C%81%E4%B9%85%E6%80%A7"><span class="nav-text">redo log(持久性)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undo-log-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-text">undo log(原子性)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVCC"><span class="nav-text">MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-6"><span class="nav-text">概念</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5"><span class="nav-text">隐藏字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undo-log"><span class="nav-text">undo log</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readView"><span class="nav-text">readView</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97"><span class="nav-text">日志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97"><span class="nav-text">错误日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97"><span class="nav-text">二进制日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="nav-text">查询日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="nav-text">慢查询</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-text">主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%86%E5%A4%87"><span class="nav-text">服务器准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%BA%93%E9%85%8D%E7%BD%AE"><span class="nav-text">主库配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%BA%93%E9%85%8D%E7%BD%AE"><span class="nav-text">从库配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="nav-text">分库分表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-text">问题分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%86%E5%88%86%E6%96%B9%E5%BC%8F"><span class="nav-text">拆分方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86"><span class="nav-text">垂直拆分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86"><span class="nav-text">水平拆分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF"><span class="nav-text">实现技术</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mycat"><span class="nav-text">Mycat</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-7"><span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%8E%E8%BF%9E%E6%8E%A5-1"><span class="nav-text">启动与连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE"><span class="nav-text">配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#schema-xml"><span class="nav-text">schema.xml</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#rule-xml"><span class="nav-text">rule.xml</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#server-xml"><span class="nav-text">server.xml</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%89%87%E8%A7%84%E5%88%99"><span class="nav-text">分片规则</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E5%88%86%E7%89%87"><span class="nav-text">范围分片</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%BB%E6%A8%A1%E5%88%86%E7%89%87"><span class="nav-text">去模分片</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7hash"><span class="nav-text">一致性hash</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E5%88%86%E7%89%87"><span class="nav-text">枚举分片</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E6%8C%87%E5%AE%9A"><span class="nav-text">应用指定</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E7%89%87hash%E7%AE%97%E6%B3%95"><span class="nav-text">固定分片hash算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2hash%E8%A7%A3%E6%9E%90"><span class="nav-text">字符串hash解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%89%EF%BC%88%E5%A4%A9%EF%BC%89%E6%97%A5%E6%9C%9F%E5%88%86%E7%89%87"><span class="nav-text">按（天）日期分片</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E7%84%B6%E6%9C%88"><span class="nav-text">自然月</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-1"><span class="nav-text">原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%90%86"><span class="nav-text">管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="nav-text">管理工具</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-text">读写分离</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%BB%E4%B8%80%E4%BB%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-text">一主一从读写分离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%B8%BB%E5%8F%8C%E4%BB%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-text">双主双从读写分离</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E5%AE%83"><span class="nav-text">其它</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%BC%95%E5%8F%B7-vs-%E5%8F%8C%E5%BC%95%E5%8F%B7"><span class="nav-text">单引号 vs. 双引号</span></a></li></ol></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2024</span> - 2025&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">Lu</a><p class="post-count space-x-0.5"><span>24 posts in total </span><span>172.3k words in total</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">VISITOR COUNT</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">TOTAL PAGE VIEWS</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span> <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span></div><div>Blog up for <span class="odometer" id="runtime_days"></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Swup.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupSlideTheme.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScriptsPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupProgressPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScrollPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/imageViewer.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/utils.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/main.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/navbarShrink.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/scrollTopBottom.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/lightDarkSwitch.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/categoryList.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/localSearch.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/codeBlock.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/lazyload.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/runtime.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/odometer.min.js"></script><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/assets/odometer-theme-minimal.css"><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Typed.min.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/typed.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/tabs.js" data-swup-reload-script></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/essays.js" data-swup-reload-script></script></body></html>