<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="referrer" content="no-referrer"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Hexo Theme Redefine"><meta name="author" content="Lu"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://registry.npmmirror.com" crossorigin><link rel="canonical" href="https://lusy37.github.io/2024/05/30/多线程/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:type" content="article"><meta property="og:title" content="Java 多线程"><meta property="og:url" content="https://lusy37.github.io/2024/05/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://lusy37.github.io/images/redefine-og.webp"><meta property="article:published_time" content="2024-05-30T01:36:01.000Z"><meta property="article:modified_time" content="2025-03-10T05:30:10.725Z"><meta property="article:author" content="Lu"><meta property="article:tag" content="学习总结"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://lusy37.github.io/images/redefine-og.webp"><link rel="icon" type="image/png" href="/images/redefine-favicon.jpg" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.jpg"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="/images/redefine-favicon.jpg"><title>Java 多线程 | Lusy</title><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Chillax/chillax.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/css/build/tailwind.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fonts/Geist/geist.css"><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/anime.min.js"></script><script id="hexo-configurations">window.config={hostname:"lusy37.github.io",root:"/",language:"en",path:"search.xml"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,delete_mask:!1,title_alignment:"left",headings_top_spacing:{h1:"3.2rem",h2:"2.4rem",h3:"1.9rem",h4:"1.6rem",h5:"1.4rem",h6:"1.3rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",highlight_theme:{light:"github",dark:"vs2015"},font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:6,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,pangu_js:!1,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#A31F34",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null},title:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!0},scroll_progress:{bar:!1,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:{enable:!0,custom_message:null},open_graph:{enable:!0,image:"/images/redefine-og.webp",description:"Hexo Theme Redefine, Redefine Your Hexo Journey."},google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/wallhaven-wqery6-light.webp",dark:"/images/wallhaven-wqery6-dark.webp"},title:"等一场花开",subtitle:{text:["迷失的人迷失了，相遇的人再相遇","迷い人はまた迷い、巡り逢うべき人とは再び巡り逢う"],hitokoto:{enable:!1,show_author:!1,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!1,style:"default",links:{github:null,instagram:null,zhihu:null,twitter:null,email:null},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{enable:!1,type:"fixed",audios:[{name:null,artist:null,url:null,cover:null,lrc:null}]},mermaid:{enable:!1,version:"11.4.1"}},version:"2.8.2",navbar:{auto_hide:!1,color:{left:"#f78736",right:"#367df7",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-regular fa-house"},Essays:{path:"/essays",icon:"fa-regular fa-pen-to-square"},Think:{path:"/think",icon:"fa-regular fa-paper-plane"}},search:{enable:!0,preload:!0}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:"If its rainy, you won't see me.If its sunny ,you'll think of me.",show_on_mobile:!0,links:{Archives:{path:"/archives",icon:"fa-regular fa-archive"},Tags:{path:"/tags",icon:"fa-regular fa-tags"},Categories:{path:"/categories",icon:"fa-regular fa-folder"}}},article_date_format:"YYYY-MM-DD",excerpt_length:200,categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2024/2/12 15:45:14"},window.lang_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},window.data={masonry:!1}</script><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/brands.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/solid.min.css"><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/fontawesome/regular.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span></div><style>:root{--preloader-background-color:#fff;--preloader-text-color:#000}@media (prefers-color-scheme:dark){:root{--preloader-background-color:#202124;--preloader-text-color:#fff}}@media (prefers-color-scheme:light){:root{--preloader-background-color:#fff;--preloader-text-color:#000}}@media (max-width:600px){.ml13{font-size:2.6rem!important}}.preloader{display:flex;flex-direction:column;gap:1rem;align-items:center;justify-content:center;position:fixed;padding:12px;top:0;right:0;bottom:0;left:0;width:100vw;height:100vh;background-color:var(--preloader-background-color);z-index:1100;transition:opacity .2s ease-in-out}.ml13{font-size:3.2rem;color:var(--preloader-text-color);letter-spacing:-1px;font-weight:500;font-family:Chillax-Variable,sans-serif;text-align:center}.ml13 .word{display:inline-flex;flex-wrap:wrap;white-space:nowrap}.ml13 .letter{display:inline-block;line-height:1em}</style><div class="preloader"><h2 class="ml13">Lusy</h2><script>var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });

        var animation = anime.timeline({ loop: true })
            .add({
                targets: '.ml13 .letter',
                translateY: [20, 0],
                translateZ: 0,
                opacity: [0, 1],
                filter: ['blur(5px)', 'blur(0px)'],
                easing: "easeOutExpo",
                duration: 1200,
                delay: (el, i) => 300 + 20 * i,
            })
            .add({
                targets: '.ml13 .letter',
                translateY: [0, -20],
                opacity: [1, 0],
                filter: ['blur(0px)', 'blur(5px)'],
                easing: "easeInExpo",
                duration: 1000,
                delay: (el, i) => 15 * i,
                complete: function() {
                    hidePreloader();
                }
            }, '-=700');


        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            setTimeout(hidePreloader, 5000); // Call hidePreloader after 5000 milliseconds if not already called by animation
        });

        function hidePreloader() {
            var preloader = document.querySelector('.preloader');
            preloader.style.opacity = '0';
            setTimeout(function () {
                preloader.style.display = 'none';
            }, 200);
        }</script></div><main class="page-container" id="swup"><div class="main-content-container flex flex-col justify-between min-h-dvh"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content transition-navbar"><div class="left"><a class="logo-title" href="/">Lusy</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house fa-fw"></i> HOME</a></li><li class="navbar-item"><a href="/essays"><i class="fa-regular fa-pen-to-square fa-fw"></i> ESSAYS</a></li><li class="navbar-item"><a href="/think"><i class="fa-regular fa-paper-plane fa-fw"></i> THINK</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>HOME </span><i class="fa-regular fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/essays"><span>ESSAYS </span><i class="fa-regular fa-pen-to-square fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/think"><span>THINK </span><i class="fa-regular fa-paper-plane fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/archives"><span>Archives</span> <i class="fa-regular fa-archive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/tags"><span>Tags</span> <i class="fa-regular fa-tags fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/categories"><span>Categories</span> <i class="fa-regular fa-folder fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">10</div><div class="label text-third-text-color text-sm">Tags</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">5</div><div class="label text-third-text-color text-sm">Categories</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">25</div><div class="label text-third-text-color text-sm">Posts</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body transition-fade-up"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Java 多线程</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="/images/redefine-avatar.jpg"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">Lu</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv3</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2024-05-30 09:36:01</span> <span class="mobile">2024-05-30 09:36:01</span> <span class="hover-info">Created</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2025-03-10 13:30:10</span> <span class="mobile">2025-03-10 13:30:10</span> <span class="hover-info">Updated</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/Java/">Java</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">学习总结</a>&nbsp;</li><li>| <a href="/tags/Java/">Java</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fa-regular fa-typewriter"></i>&nbsp;<span>27.3k Words</span> </span><span class="article-min2read article-meta-item"><i class="fa-regular fa-clock"></i>&nbsp;<span>106 Mins</span> </span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><h1 id="Java-多线程"><a href="#Java-多线程" class="headerlink" title="Java 多线程"></a>Java 多线程</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-1-程序、进程、线程"><a href="#1-1-程序、进程、线程" class="headerlink" title="1.1.程序、进程、线程"></a>1.1.程序、进程、线程</h3><ul><li>程序(program)<ul><li>程序是为完成特定任务，使用某种语言编写的一组指令的集合。即指 <strong>一段静态的代码</strong>（还没有运行起来），静态对象。</li></ul></li><li>进程(process)<ul><li>进程是程序的一次执行过程，也就是说程序运行起来了，加载到内存中，并占用了CPU的资源。这是一个动态的过程：有自身的产生、存在和消亡的过程，这也就是一个进程的生命周期。</li><li><strong>进程是系统资源分配的单位</strong> ，系统在运行时会为每一个进程分配不同的内存区域。</li></ul></li><li>线程(thread)<ul><li>线程可进一步细化线程，是一个程序内部的执行路径。</li><li>若一个进程同一时间并行执行了多个线程，那么这个进程就是支持多线程的。</li><li><strong>线程是CPU调度和执行的单位，每一个线程都拥有独立的运行栈和程序计数器(pc)</strong>，线程切换的开销小。</li><li>一个进程中，所有的线程<strong>共享相同的内存单元&#x2F;内存地址空间</strong>，它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程之间的通信更加便捷、高效。但多个线程操作共享的系统资源也带来了一些潜在的<strong>安全隐患</strong>，例如：数据竞争和死锁等问题。</li><li>配合JVM内存结构了解<br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240509225613.png"><br>class文件会通过类加载器加载到内存空间。<br>其中内存区域中的每一个线程都会有一个独立的虚拟机栈和程序计数器。<br>每一个进程都会有一个方法区和堆，多个线程共享同一个进程下的方法区和堆。</li></ul></li></ul><blockquote><p><strong>多线程与多进程的比较：</strong></p><ul><li>创建线程的开销通常小于创建进程的开销，因为线程共享了进程的资源。</li><li>线程之间的通信相对容易，因为它们共享同一进程的地址空间。</li><li>多进程的稳定性高于多线程，因为一个进程的崩溃通常不会影响其他进程，但线程的崩溃可能导致整个程序的崩溃。</li></ul></blockquote><h3 id="1-2-并行与并发"><a href="#1-2-并行与并发" class="headerlink" title="1.2.并行与并发"></a>1.2.并行与并发</h3><ul><li>并行：多个CPU同时执行多个任务。eg：多个人做不同的事。</li><li>并发：一个CPU（采用时间片）同时执行多个任务。eg：一个人做多个事。</li></ul><h3 id="1-3-CPU单核和多核的理解"><a href="#1-3-CPU单核和多核的理解" class="headerlink" title="1.3.CPU单核和多核的理解"></a>1.3.CPU单核和多核的理解</h3><ul><li>单核CPU在同一时间只能执行一个线程的任务，同时间段内有多个线程需要CPU去运行时，CPU也只能交替地执行这些线程中的一个线程，并不能真正实现并行执行，但由于CPU的执行速度非常快，多个线程之间的切换可能会发生得非常快，给人的感觉就像是同时运行一样，造成单核的CPU可以实现多线程的假象。</li><li>多核CPU则可以同时执行多个线程的任务，每个核心都能独立地执行线程，从而更好地发挥多线程的效率。在多核CPU上，可以实现真正的并行执行，每个核心都可以独立地执行一个线程的任务，提高了系统的整体性能。</li></ul><p>对于Java应用程序java.exe来讲，至少会存在三个线程：main（）主线程、gcc（）垃圾回收线程、异常处理线程【如果发生异常时会影响主线程】。</p><h3 id="1-4-用户线程与守护线程"><a href="#1-4-用户线程与守护线程" class="headerlink" title="1.4.用户线程与守护线程"></a>1.4.用户线程与守护线程</h3><ul><li>用户线程：用户自定义创建的进程，它们由用户代码启动并执行。JVM会在终止之前等待任何用户进程完成其任务。【<strong>主线程停止，用户线程并不会直接停止，会继续执行，直到完成其任务或显式被中止</strong>】</li><li>守护线程：守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程。守护线程通常用于执行一些不需要在程序结束前完全执行的后台任务。【<strong>当所有的用户线程都执行完毕并且主线程退出时，JVM 会自动停止所有的守护线程，即使它们还没有执行完任务</strong>】 eg：Java的gc()垃圾回收线程就是一个守护线程。</li></ul><h3 id="1-5-多线程的优点"><a href="#1-5-多线程的优点" class="headerlink" title="1.5.多线程的优点"></a>1.5.多线程的优点</h3><ul><li>提高应用程序的响应。对图像化界面更有意义，可以增强用户体验。</li><li>提高计算机CPU的利用率。</li><li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。</li></ul><h3 id="1-6-应用场景"><a href="#1-6-应用场景" class="headerlink" title="1.6.应用场景"></a>1.6.应用场景</h3><ul><li>程序需要同时执行两个或多个任务</li><li>IO密集型程序：1.解决超时 2.防止阻塞</li><li>需要一些后台运行的程序时</li><li>迅雷多线程下载、数据库连接池、分批发送短信等</li></ul><h2 id="2-线程的生命周期"><a href="#2-线程的生命周期" class="headerlink" title="2. 线程的生命周期"></a>2. 线程的生命周期</h2><h3 id="2-1-线程的状态图"><a href="#2-1-线程的状态图" class="headerlink" title="2.1.线程的状态图"></a>2.1.线程的状态图</h3><p><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240511201316.png"></p><h3 id="2-2-线程状态详细说明"><a href="#2-2-线程状态详细说明" class="headerlink" title="2.2.线程状态详细说明"></a>2.2.线程状态详细说明</h3><h4 id="新建（New）"><a href="#新建（New）" class="headerlink" title="新建（New）"></a>新建（New）</h4><ul><li>使用new创建一个线程（Thread）之后，但还没有调用start()方法时。</li><li>该状态下线程对象已经被创建，但还未开始执行。</li></ul><h4 id="可运行（Runnable）"><a href="#可运行（Runnable）" class="headerlink" title="可运行（Runnable）"></a>可运行（Runnable）</h4><ul><li>当线程调用start()方法之后，线程就处于可运行状态，会创建方法调用栈和程序计数器，这个状态还可继续拆分成2个状态：<ul><li>就绪（Ready）：处于线程就绪队列、等待分配CPU时间片</li><li>运行（Running）：线程获得CPU时间片，开始执行run()方法，可能变为阻塞状态、就绪状态、死亡状态</li></ul></li></ul><h4 id="阻塞（Blocked）"><a href="#阻塞（Blocked）" class="headerlink" title="阻塞（Blocked）"></a>阻塞（Blocked）</h4><ul><li>纯粹的阻塞状态通常是指线程被动地暂时停止执行，直到某些条件满足为止，而不涉及等待一段时间或等待其他线程的唤醒。存在以下两种情况：<ul><li>等待获得锁</li><li>调用一个阻塞式IO</li></ul></li><li>阻塞状态线程无法直接转为运行状态，需要先转为就绪状态</li></ul><h4 id="等待（Waiting）"><a href="#等待（Waiting）" class="headerlink" title="等待（Waiting）"></a>等待（Waiting）</h4><ul><li>线程进入等待状态通常是因为需要等待其他线程满足某些条件或执行某些操作，等待的时间是不确定的。</li><li>进入等待状态的方法：<ul><li><p><code>Object.wait()方法</code>：</p><ul><li>只能在synchronized代码块或synchronized方法中调用。</li><li>调用前必须获得对象的锁，否则会抛出IllegalMonitorStateException异常。</li><li>wait()方法调用时会释放持有的对象锁。</li><li>调用wait()方法，需要等待<code>notify()</code>或<code>notifyAll()</code>方法唤醒。</li></ul></li><li><p><code>Thread.join()方法</code>:</p><ul><li>可以在任何时候调用，通常用于等待指定的线程【即调用join()方法的线程】执行完毕。</li><li>调用前不需要获得任何锁，但会等待目标线程执行完毕后返回。</li><li>若调用前持有对象锁，并不会释放持有的对象锁。</li></ul></li><li><p><code>LockSupport.park()/LockSupport.park(Thread thread)方法</code>：</p><ul><li>可以在任何时候调用，通常和LockSupport类一起使用。</li><li>无参时当前线程进入等待状态，有参时指定线程进入等待状态。</li><li>调用前不需要获得任何锁。</li><li>若调用前持有对象锁，并不会释放持有的对象锁。</li><li>调用LockSupport.park()方法，需要等待<code>LockSupport.unpark(Thread thread)</code>方法唤醒，这种方式唤醒打断标记为false。</li><li>也可以使用 <code>thread.interrupt ()</code> 进行唤醒，但是这样子打断标记会标记为 true。</li></ul><blockquote><ul><li>如果打断标记已经是 true, 则 park 会失效</li><li>如果在 park 之前调用了 unpark 方法，那么 park 将不会使线程进入等待状态，而是继续执行，也就是说 unpark 方法可以提前调用</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;打断状态：&quot;</span> + Thread.currentThread().isInterrupted());<span class="comment">//打断状态：true</span></span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    </span><br><span class="line">    t1.interrupt();<span class="comment">////打断状态：true</span></span><br><span class="line">    <span class="comment">//LockSupport.unpark(t1);//打断状态：false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出：</span></span><br><span class="line"><span class="comment"> * park...</span></span><br><span class="line"><span class="comment"> * unpark...</span></span><br><span class="line"><span class="comment"> * 打断状态：true</span></span><br><span class="line"><span class="comment"> * unpark...</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div></blockquote></li></ul></li></ul><h4 id="超时等待（TIME-WAITING）"><a href="#超时等待（TIME-WAITING）" class="headerlink" title="超时等待（TIME_WAITING）"></a>超时等待（TIME_WAITING）</h4><ul><li>线程进入超时等待状态是因为需要等待一段时间后再继续执行，等待的时间是确定的。</li><li>进入超时等待状态的方法：<ul><li><code>Thread.sleep(long millis)</code>:<ul><li>让当前线程睡眠指定的毫秒数。</li><li>调用该方法后，当前线程会暂停执行指定的毫秒数，然后继续执行。</li><li>这个方法不会释放持有的锁。</li></ul></li><li><code>Object.wait(long timeout)</code>:<ul><li>使当前线程等待指定的毫秒数，或者直到其他线程调用了相同对象的<code>notify()</code>或<code>notifyAll()</code>方法。</li><li>当前线程会进入超时等待状态，直到等待时间超时，或者其他线程调用了相同对象的<code>notify()</code>或<code>notifyAll()</code>方法。</li><li>调用wait()方法会释放持有的对象锁，直到被唤醒后重新获取锁才会继续执行。</li></ul></li><li><code>Thread.join(long millis)</code>:<ul><li>等待调用join()方法的线程执行完毕，或者直到指定的毫秒数之后。【若参数为0，则表示永远等待】</li><li>如果调用join()方法的线程在指定的时间内执行完毕，则当前线程会恢复执行。</li><li>这个方法不会释放持有的锁。</li></ul></li><li><code>LockSupport.parkNanos(long nanos)</code>:<ul><li>使当前线程进入超时等待状态，直到指定的<strong>纳秒数</strong>后或者被中断。</li><li>这个方法不会释放持有的锁。</li></ul></li><li><code>LockSupport.parkUntil(long deadline)</code>:<ul><li>参数 deadline 是一个表示时间戳的长整型数值，单位是毫秒。</li><li>使当前线程进入超时等待状态，直到指定的时间点后或者被中断。</li><li>这个方法不会释放持有的锁。</li></ul></li></ul></li></ul><h4 id="死亡（Dead）"><a href="#死亡（Dead）" class="headerlink" title="死亡（Dead）"></a>死亡（Dead）</h4><ul><li>当一个线程已经执行完run()&#x2F;call()方法中的所有操作时，该线程就处于死亡状态。</li><li>线程抛出一个未捕获的Exception或Error，线程就会死亡。</li><li>一旦线程处于死亡状态，线程对象就会被垃圾回收器移除。</li></ul><h3 id="2-3-状态之间的转换及调用方法："><a href="#2-3-状态之间的转换及调用方法：" class="headerlink" title="2.3.状态之间的转换及调用方法："></a>2.3.状态之间的转换及调用方法：</h3><ul><li><strong>New -&gt; Runnable：</strong> 调用start()方法启动线程。</li><li><strong>Runnable -&gt; Running：</strong> 线程被操作系统调度并获取CPU时间片。</li><li><strong>Running -&gt; Blocked：</strong> 线程等待获取锁或执行阻塞式IO操作。</li><li><strong>Running -&gt; Waiting：</strong> 调用wait()、join()、park()等方法，线程进入等待状态。</li><li><strong>Running -&gt; Timed_Waiting：</strong> 调用Thread.sleep(long)、wait(timeout)等方法，线程进入超时等待状态。</li><li><strong>Blocked -&gt; Runnable：</strong> 获取到锁或IO操作完成，线程重新进入可运行状态。</li><li><strong>Waiting -&gt; Runnable：</strong> 其他线程调用notify()、notifyAll()、interrupt()方法，或者等待时间到达，线程重新进入可运行状态。</li><li><strong>Timed_Waiting -&gt; Runnable：</strong> 等待时间到达，线程重新进入可运行状态。</li><li><strong>Running&#x2F;Blocked&#x2F;Waiting&#x2F;Timed Waiting -&gt; Dead：</strong> 线程执行完run()方法中的所有代码，或者抛出未捕获的异常，线程进入死亡状态。</li></ul><h3 id="2-4-几个方法的比较"><a href="#2-4-几个方法的比较" class="headerlink" title="2.4.几个方法的比较"></a>2.4.几个方法的比较</h3><ul><li><strong>Thread.sleep(long millis)</strong>：一定是当前线程调用此方法，当前线程进入TIMED_WAITING状态，但不释放对象锁，millis后线程自动苏醒进入就绪状态。作用：<strong>给其它线程执行机会的最佳方式</strong>。</li><li><strong>Thread.yield()</strong>：一定是当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让CPU再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。<strong>实际中无法保证yield()达到让步目的</strong>，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。该方法与sleep()类似，只是不能由用户指定暂停多长时间。</li><li><strong>thread.join()&#x2F;thread.join(long millis)</strong>：当前线程里调用其它线程T的join方法，当前线程进入WAITING&#x2F;TIMED_WAITING状态，<strong>当前线程不会释放已经持有的对象锁</strong>。线程T执行完毕或者millis时间到，当前线程一般情况下进入RUNNABLE状态，也有可能进入BLOCKED状态（因为join是基于wait实现的）。</li><li><strong>obj.wait()</strong>：当前线程调用对象的wait()方法，<strong>当前线程释放对象锁</strong>，进入等待队列。依靠notify()&#x2F;notifyAll()唤醒或者wait(long timeout) timeout时间到自动唤醒。</li><li><strong>obj.notify()</strong>：唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。</li><li><strong>LockSupport.park()&#x2F;LockSupport.parkNanos(long nanos),LockSupport.parkUntil(long deadlines)</strong>：当前线程进入WAITING&#x2F;TIMED_WAITING状态。<strong>对比wait方法,不需要获得锁</strong>就可以让线程进入WAITING&#x2F;TIMED_WAITING状态，需要通过LockSupport.unpark(Thread thread)唤醒。</li></ul><p><strong>进入等待状态的几个方法比较</strong>：</p><ul><li>方法比较<ul><li>Thread.sleep(long millis)<ul><li>释放资源问题：不会释放资源</li><li>底层调用：是一个native方法</li><li>是否需要声明异常：方法声明要捕获异常</li><li>线程状态：TIMED_WAITING</li><li>作用范围：任意地方</li></ul></li><li>Object.wait(long millis)<ul><li>释放资源问题：会释放资源，被唤醒后需要重新竞争资源</li><li>底层调用：超时的wait(long millis)是一个native方法 wait调用的是wait(0)</li><li>是否需要声明异常：方法声明有中断异常</li><li>线程状态：无参时是Waiting，有参时是TIMED_WAITING</li><li>作用范围：是synchronized的 通知机制中的方法</li><li>唤醒操作：notify()、notifyAll()，不能在wait()前面执行</li></ul></li><li>LockSupport.park()<ul><li>释放资源问题：不会释放资源</li><li>底层调用：底层调用的Unsafe下的native的park()方法进入等待状态，park(Thread thread)指定线程进入等待状态</li><li>是否需要声明异常：不需要</li><li>线程状态：在synchronized中，获取到锁的线程调用该方法进入waiting状态，其他线程都是Bolcked状态<br>如果是ReentratLock锁，因为是重入锁，所有线程都是waiting状态</li><li>作用范围：任意范围</li><li>唤醒操作：LockSupport.unpark(Thread thread)可以在LockSupport.park( )之前调用</li></ul></li><li>Condition.await()<ul><li>释放资源问题：会释放资源</li><li>底层调用：底层使用的是LockSupport.park( )</li><li>是否需要声明异常：需要</li><li>线程状态：waiting</li><li>作用范围：需要在Lock块中执行，用来lock对象的</li><li>唤醒操作：signal()、signalAll()，不能在await()前面执行</li></ul></li></ul></li></ul><h2 id="3-Thread类"><a href="#3-Thread类" class="headerlink" title="3.Thread类"></a>3.Thread类</h2><h3 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1.基本概念"></a>3.1.基本概念</h3><ul><li>Thread类是Java中用于表示线程的类。通过Thread类，可以创建新的线程、启动线程的执行、控制线程的状态和执行等。除了线程对象本身的操作，Thread类还提供了对线程组（ThreadGroup）的支持，以便更好地管理和组织线程。</li></ul><p><strong>什么是线程组（ThreadGroup）：</strong></p><ul><li>线程组是线程的集合，它用于对线程进行逻辑上的分组。线程组可以包含其他线程组，形成一棵树状结构。每个线程组可以有一个父线程组，除了顶级线程组外，其他线程组必须有一个明确定义的父线程组。</li></ul><p><strong>线程组的作用：</strong></p><ul><li><strong>组织管理</strong>：通过线程可以更好地组织和管理多个线程,便于对线程进行批量操作和控制</li><li><strong>权限控制</strong>：线程组可以应用安全策略和权限控制，限制线程组中线程的行为</li><li><strong>资源分配</strong>：线程组可以分配资源，例如线程组中的线程可以共享资源，例如文件、数据库连接等</li><li><strong>异常处理</strong>：线程组可以统一处理线程中抛出的未捕获异常，提高异常处理的效率和统一性</li></ul><p><strong>线程组的父子关系：</strong></p><ul><li><strong>父子关系</strong>：每个线程组可以有一个父线程组，除了顶级线程组外，其他线程组必须有一个明确定义的父线程组。这种关系通过ThreadGroup类来实现，构成了线程组的树形结构</li><li><strong>组织结构</strong>：线程组可以包含其他线程组，形成多层次的组织结构，便于对线程进行层次化管理</li></ul><p><strong>父线程组的作用：</strong></p><ul><li><strong>创建与销毁子线程组</strong>：父线程组可以创建和销毁子线程组，从而实现对线程组的管理</li><li><strong>管理权限</strong>：父线程组可以授予或限制子线程组的权限，例如访问特定的资源或执行特定的操纵</li><li><strong>监控和控制</strong>：父线程组可以监控和控制子线程组的状态和行为，例如暂停、恢复或终止子线程组的所有线程</li></ul><p><strong>子线程组的作用：</strong></p><ul><li><strong>资源隔离</strong>：子线程组可以限制父线程组的访问权限，确保父线程组无法访问子线程组的资源</li><li><strong>继承行为</strong>：子线程组可以继承父线程组的一些属性：例如优先级、守护状态等，这些使得子线程组可以继承父线程组的行为，并根据需要进行调整</li></ul><h3 id="3-2-Thread的构造方法"><a href="#3-2-Thread的构造方法" class="headerlink" title="3.2.Thread的构造方法"></a>3.2.Thread的构造方法</h3><ul><li><code>Thread()</code>：创建一个默认设置的线程对象实例，默认线程名为Thread-0，默认优先级为5，默认状态为NEW。</li><li><code>Thread(String name)</code>：创建一个线程对象，该线程对象的线程名为name，默认优先级为5，默认状态为NEW。</li><li><code>Thread(Runnable target)</code>：创建一个线程对象，该线程对象通过指定的Runnable对象来执行。</li><li><code>Thread(Runnable target, String name)</code>：创建一个线程对象，该线程对象通过指定的Runnable对象来执行，并且指定线程名为name。</li><li><code>Thread(ThreadGroup group，String name)</code>：创建一个指定的线程组group，并且指定线程名为name。</li><li><code>Thread(ThreadGroup group, Runnable target)</code>：创建一个指定的线程组group，该线程对象通过指定的Runnable对象来执行。</li><li><code>Thread(ThreadGroup group, Runnable target, String name)</code>：创建一个指定的线程组group，该线程对象通过指定的Runnable对象来执行，并且指定线程名为name。</li><li><code>Thread(ThreadGroup group, Runnable target, String name, long stackSize)</code>：创建一个指定的线程组group，该线程对象通过指定的Runnable对象来执行，并且指定线程名为name，并且指定线程的堆栈大小为stackSize。【如果不想指定堆栈大小，可以传递0，由虚拟机自行决定】</li></ul><blockquote><p><strong>说明</strong>：关于线程组（ThreadGroup），一个线程组代表一组线程。此外，一个线程组还可以包括其他线程组。线程组形成一棵树，其中除了初始线程组之外的每一个线程组都有一个父级。允许线程直接访问有关其自己的线程组的信息，但不能直接访问有关其线程组的父级线程组或其他线程组的信息。</p></blockquote><h3 id="3-3-Thread的常用方法"><a href="#3-3-Thread的常用方法" class="headerlink" title="3.3.Thread的常用方法"></a>3.3.Thread的常用方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>String getName()</code></td><td>返回线程的名称。</td></tr><tr><td><code>void setName(String name)</code></td><td>设置线程的名称。</td></tr><tr><td><code>static Thread currentThread()</code></td><td>返回当前正在执行的线程对象。</td></tr><tr><td><code>public final void start()</code></td><td>启动线程，使其进入就绪状态并开始执行 run () 方法。如果线程已经启动，再次调用 start () 方法会抛出 IllegalThreadStateException 异常。</td></tr><tr><td><code>public final void run()</code></td><td>线程的执行体，包含了线程需要执行的任务逻【直接调用 run () 方法，并不创建一个新线程，只是在当前线程中执行 run () 方法的内容】辑。</td></tr><tr><td><code>static void sleep(long millis)</code></td><td>使当前线程暂停执行指定的毫秒数。调用 sleep () 方法会使当前线程进入超时等待状态，不会释放持有的锁。如果在 sleep 期间被其他线程中断，则会抛出 InterruptedException 异常，并且清除当前线程的中断状态。</td></tr><tr><td><code>public static boolean interrupt()</code></td><td>中断线程。调用该方法会将线程的中断状态设置为true，如果当前线程正在sleep、wait、join等方法中阻塞，则会立即抛出InterruptedException异常并清除中断状态。</td></tr><tr><td><code>public boolean isInterrupt()</code></td><td>中断线程。调用该方法会将线程的中断状态设置为true，如果当前线程正在sleep、wait、join等方法中阻塞，则会立即抛出InterruptedException异常但不会清除中断状态。</td></tr><tr><td><code>void setPriority(int newPriority)</code></td><td>设置线程的优先级。优先级范围是 1~10，其中 1 为最低优先级，10 为最高优先级，默认优先级为 5。Java 线程优先级的设置只是一个建议，实际的调度由底层操作系统决定，不同操作系统对线程优先级的支持程度不同。</td></tr><tr><td><code>final int getPriority()</code></td><td>返回线程的优先级。</td></tr><tr><td><code>final void setDaemon(boolean on)</code></td><td>设置线程是否为守护线程。如果将线程设为守护线程，当所有的非守护线程结束时，守护线程会被自动终止。默认情况下，用户线程是非守护线程，而守护线程是为了辅助用户线程的运行而存在的。</td></tr><tr><td><code>public final boolean isAlive()</code></td><td>判断线程是否处于活动状态。如果线程已经启动且尚未终止，则返回 true；否则返回 false。</td></tr><tr><td><code>public static void yield()</code></td><td>提示线程调度器当前线程愿意放弃当前 CPU 资源。调用 yield () 方法会让出当前线程的 CPU 时间片，使得其他具有相同或更高优先级的线程有机会执行，但是并不能保证一定会立即让出 CPU，实际中使用 yield () 方法的效果可能受到操作系统和 JVM 的调度策略影响。</td></tr><tr><td><code>public static void join()</code></td><td>等待调用 join () 方法的线程执行完毕。调用 join () 方法会使当前线程进入等待状态，直到调用 join () 方法的线程执行完毕，当前线程才会继续执行。如果调用 join () 方法的线程被中断，则会抛出 InterruptedException 异常，并清除当前线程的中断状态。</td></tr></tbody></table><blockquote><p><strong>普及</strong><br>Java中线程采用内核线程模型来实现用户程序中的线程，因此一些常用方法依托于虚拟机原生实现，统称Native方法。<br>Native方法是指在Java中声明但实现是由其他语言（如C、C++）编写的方法。这些方法的实现由本地代码提供，通常是为了与底层系统交互或使用底层系统资源。在Java中，可以使用<code>native</code>关键字声明一个方法为本地方法，然后在另外的本地语言中实现它。Native方法通常用于与操作系统、硬件或其他非Java程序进行交互，或者执行一些Java无法直接完成的底层操作。</p></blockquote><h4 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h4><ul><li>yiedld方法是一个Native方法，由C++底层进行关于操作系统层面的逻辑处理。yield的字面意思是退让。调用该方法会向调度程序提示当前线程愿意放弃其当前对处理器的使用，但调度程序可以随意忽略此提示。【无法保证yield达到让步目的】</li><li>yield是一种启发式尝试，使用它可以改善线程之间的相对进展，否则会过度使用CPU。在使用yield方法时通常有以下两种使用场景：<ul><li>yield的使用应于详细的分析和基准测试相结合，以确保实际上具有预期的效果，但很少使用这种方法。对于调试或测试目的可能有用，它可能有助于重现由于竞争条件导致的问题错误。</li><li>在设计并发控制结构（例如 java.util.concurrent.locks包中的结构）时，它也可能会有所帮助。</li></ul></li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestYield</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">MyThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;thread-1&quot;</span>);</span><br><span class="line">      <span class="type">MyThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;thread-2&quot;</span>);</span><br><span class="line">      thread1.start();</span><br><span class="line">      thread2.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">          <span class="built_in">super</span>(name);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (i % <span class="number">2</span> ** <span class="number">0</span>) &#123;</span><br><span class="line">                  Thread.<span class="keyword">yield</span>(); <span class="comment">// 实际中无法保证yield()达到让步目的</span></span><br><span class="line">                  System.out.println(getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><ul><li>join方法让一个线程加入到另一个线程之前执行，在此线程执行期间，其他线程进入等待状态，当然也可以指定join方法的参数（指定执行等待的超时时间），最多等待几毫秒让该线程终止，若参数为0，意味着永远等待。</li><li>此实现使用以this.isAlive为条件的this.wait调用循环，当线程终止，将调用this.notifyAll方法。建议应用程序不要在Thread实例上使用wait、notify或notifyAll方法。如果任何线程中断了当前线程，则会抛出InterruptedException异常并清除当前线程的中断状态。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJoin</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">MyThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;thread-1&quot;</span>);</span><br><span class="line">      <span class="type">MyThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;thread-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">      thread1.start();</span><br><span class="line">      thread1.join();<span class="comment">// 阻塞当前线程main，直到thread1执行完</span></span><br><span class="line">      thread2.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">          <span class="built_in">super</span>(name);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">              System.out.println(getName());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h4><ul><li>当调用线程的sleep方法时，使当前执行的线程休眠（暂时停止执行）指定的毫秒数，取决于系统计时器和调度程序的精度和准确性。如果任何线程中断了当前线程，会抛出InterruptedException异常并清除当前线程的中断状态。</li></ul><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h4><ul><li>使用interrupt()方法来中断线程，除非当前线程正在中断自己，否则会调用该线程的checkAccess方法，这个方法可能会抛出SecurityException异常。主要有以下几种场景：<ul><li>如果一个线程被Object类的wait、Thread类的join、sleep、yield方法调用时，如果当前线程被中断，那么就会抛出InterruptedException异常。</li><li>如果该线程在InterruptibleChannel的IO操作中被中断，则通道关闭，线程的中断状态将被设置，线程抛出java.nio.channels.ClosedByInterruptException异常。</li><li>如果该线程在java.nio.channels.Selector的select操作中被中断，则该线程的中断状态将被设置，并且它将立即从选择操作中返回，可能带有非零值，就像调用了选择器的唤醒方法一样。如果前面的条件都不成立，则将设置该线程的中断状态。</li></ul></li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Native;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInterrupt</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">java.lang.InterruptedException: sleep interrupted</span></span><br><span class="line"><span class="comment">at java.base/java.lang.Thread.sleep0(Native Method)</span></span><br><span class="line"><span class="comment">at java.base/java.lang.Thread.sleep(Thread.java:509)</span></span><br><span class="line"><span class="comment">at TestInterrupt.lambda$main$0(TestInterrupt.java:6)</span></span><br><span class="line"><span class="comment">at java.base/java.lang.Thread.run(Thread.java:1583)*/</span></span><br></pre></td></tr></table></figure></div><h3 id="3-4-优先级"><a href="#3-4-优先级" class="headerlink" title="3.4.优先级"></a>3.4.优先级</h3><ul><li>Java中创建的线程，每个线程都有一个优先级，具有较高优先级的线程优先于具有较低优先级的线程执行。<br><strong>但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</strong></li><li>当在某个线程中运行的代码创建一个新的Thread对象时，新线程的优先级最初设置为等于创建线程的优先级。当然，也可以通过调用新线程的setPriority()方法来改变优先级。</li><li>Java线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</li><li>Thread类中定义了以下三个默认优先级：<ul><li><code>public final static int MIN_PRIORITY = 1;</code></li><li><code>public final static int NORM_PRIORITY = 5;</code>【创建线程的默认优先级】</li><li><code>public final static int MAX_PRIORITY = 10;</code></li></ul></li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">        t2.start(); <span class="comment">// 输出：MyThread2 run priority=5【没有设置优先级默认是5】</span></span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        t1.setPriority(<span class="number">6</span>);</span><br><span class="line">        t1.start(); <span class="comment">// 输出: MyThread1 run priority=6</span></span><br><span class="line">                    <span class="comment">//       MyThread2 run priority=6【这里的MyThread2在MyThread1的线程里面创建，没有调用方法默认继承父线程的优先级】</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread1 run priority=&quot;</span>+<span class="built_in">this</span>.getPriority());</span><br><span class="line">        MyThread2 thread2=<span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread2 run priority=&quot;</span>+<span class="built_in">this</span>.getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="4-线程的调度"><a href="#4-线程的调度" class="headerlink" title="4.线程的调度"></a>4.线程的调度</h2><h3 id="4-1-CPU的调度策略"><a href="#4-1-CPU的调度策略" class="headerlink" title="4.1.CPU的调度策略"></a>4.1.CPU的调度策略</h3><p>线程无论基于何种模型创建，都有其调度策略，线程的调度指的是操作系统为线程分配使用权的过程。通常调度方式包含两种：</p><ul><li><strong>协同式调度(Cooperative Threads Scheduling)：</strong><ul><li>使用协同式调度方式的线程调度由其本身来控制，线程在自身工作执行完成后，主动通知系统切换到另一个线程，这种方式实现简单，便于控制。但是过度依赖线程本身来控制调度，如果某个线程执行任务的程序存在问题就会一直阻塞，导致其他线程无法正常执行。</li></ul></li><li><strong>抢占式调度(Preemptive Threads Scheduling)：</strong><ul><li>使用抢占式调度方式的多线程系统，线程的调度由系统分配执行时间，线程的切换由系统决定。在这种调度方式下，线程的执行时间可控，不会因为单个线程问题导致应用程序阻塞。</li></ul></li></ul><blockquote><p><strong>什么是时间片：</strong><br>时间片（Time Slice）是指操作系统中用于调度进程或线程的一段固定长度的时间。在抢占式调度中，每个进程或线程被分配一个时间片，该时间片决定了它能够连续执行的最大时间。当一个进程或线程的时间片用完后，操作系统会中断其执行，并将CPU资源分配给下一个就绪状态的进程或线程。</p><p>时间片的长度通常是固定的，但在某些调度算法中也可以是可变的。时间片的大小会影响到系统的响应时间、吞吐量和公平性。较短的时间片能够提高系统的响应速度，但会增加上下文切换的开销；而较长的时间片能够减少上下文切换的频率，但可能导致某些进程或线程长时间占用CPU资源，影响其他任务的响应速度。</p></blockquote><h3 id="4-2-Java的调度算法"><a href="#4-2-Java的调度算法" class="headerlink" title="4.2.Java的调度算法"></a>4.2.Java的调度算法</h3><ul><li>同优先级线程组成FIFO队列（先来先服务），使用时间片策略。</li><li>堆高优先级，使用优先级抢占式策略。</li><li>线程优先级等级 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ），一共10档，默认优先级为5（NORM_PRIORITY）。</li><li>获取和设置当前线程的优先级<ul><li><code>getPriority()</code>：获取当前线程的优先级。</li><li><code>setPriority(int p)</code>：设置当前线程的优先级。<blockquote><p><strong>说明：</strong> 高优先级的线程要抢占低优先级的线程CPU的执行权。但这只是从概率上来讲，高优先级的线程的执行概率高，但是并不是绝对的。并不意味着只有高优先级的线程执行完成后，低优先级的线程才可以执行。</p></blockquote></li></ul></li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">        t2.setPriority(<span class="number">7</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        t1.setPriority(<span class="number">6</span>);</span><br><span class="line">        t1.start(); </span><br><span class="line">        <span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">        MyThread2 run priority=7</span></span><br><span class="line"><span class="comment">        MyThread2 run priority=7</span></span><br><span class="line"><span class="comment">        MyThread1 run priority=6</span></span><br><span class="line"><span class="comment">        MyThread1 run priority=6</span></span><br><span class="line"><span class="comment">        MyThread1 run priority=6</span></span><br><span class="line"><span class="comment">        MyThread2 run priority=7</span></span><br><span class="line"><span class="comment">        高优先级的也有可能比低优先级的晚结束*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread1 run priority=&quot;</span>+<span class="built_in">this</span>.getPriority());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread2 run priority=&quot;</span>+<span class="built_in">this</span>.getPriority());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="5-多线程的实现原理和创建"><a href="#5-多线程的实现原理和创建" class="headerlink" title="5.多线程的实现原理和创建"></a>5.多线程的实现原理和创建</h2><h3 id="5-1-多线程的实现原理"><a href="#5-1-多线程的实现原理" class="headerlink" title="5.1.多线程的实现原理"></a>5.1.多线程的实现原理</h3><ul><li>Java语言的JVM允许运行多个线程，多线程可以通过Java中的<strong>java.lang.Thread</strong>类来实现。</li><li>Thread类的特性<ul><li>每一个线程都是通过某个特定的Tread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体。</li><li>通过Thread方法的start()方法来启动一个线程，而非直接调用run()方法。【start()底层会调用start0()来创建一个新的线程，调用run()方法，而直接调用 run() 方法只是在当前线程中执行 run() 方法的内容，并不会创建新的线程】</li></ul></li></ul><h3 id="5-2-多线程的创建"><a href="#5-2-多线程的创建" class="headerlink" title="5.2.多线程的创建"></a>5.2.多线程的创建</h3><h4 id="5-2-1-继承Thread类-拓展性较差"><a href="#5-2-1-继承Thread类-拓展性较差" class="headerlink" title="5.2.1.继承Thread类[拓展性较差]"></a>5.2.1.继承Thread类[拓展性较差]</h4><ol><li>创建一个继承Thread类的子类</li><li>重写Thread类的run()方法，将此线程执行的操作声明在run()中</li><li>创建Thread类的子类对象</li><li>通过此对象调用start()方法来启动一个线程。</li></ol><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个Thread类的子类对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">// 通过调用此对象的start()启动一个线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="comment">// 注意：已启动过一次的线程无法再次启动【在Java中，一个线程对象只能被启用一次】</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再创建一个线程</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 另一种调用方法，此方法并没有给对象命名【链式编程】</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 线程体，启动线程时会运行run()方法中的代码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">主线程</span></span><br><span class="line"><span class="comment">Thread-1: 0</span></span><br><span class="line"><span class="comment">Thread-1: 1</span></span><br><span class="line"><span class="comment">Thread-2: 0</span></span><br><span class="line"><span class="comment">Thread-2: 1</span></span><br><span class="line"><span class="comment">Thread-0: 0</span></span><br><span class="line"><span class="comment">Thread-0: 1</span></span><br><span class="line"><span class="comment">Thread-0: 2</span></span><br><span class="line"><span class="comment">Thread-1: 2</span></span><br><span class="line"><span class="comment">Thread-2: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div><p>创建Thread匿名子类的方式：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousSubClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> ** <span class="number">0</span>) System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="5-2-2-实现Runnable接口-拓展性强"><a href="#5-2-2-实现Runnable接口-拓展性强" class="headerlink" title="5.2.2.实现Runnable接口[拓展性强]"></a>5.2.2.实现Runnable接口[拓展性强]</h4><ol><li>创建一个实现了Runnable接口的类</li><li>实现类中重写Runnable接口的run()方法，将此线程执行的操作声明在run()中</li><li>创建实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li><li>通过Thread类的对象调用start()方法来启动线程</li></ol><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">   <span class="comment">// 创建实现类的对象</span></span><br><span class="line">   <span class="type">RunnableThread</span> <span class="variable">runnableThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableThread</span>();</span><br><span class="line">   <span class="comment">// 创建Thread类的对象，并将实现类的对象当作参数传入构造器</span></span><br><span class="line">   <span class="type">Thread</span> <span class="variable">thread01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableThread);</span><br><span class="line">   <span class="comment">// 给该线程命名</span></span><br><span class="line">   thread01.setName(<span class="string">&quot;Thread 01&quot;</span>);</span><br><span class="line">   <span class="comment">// 使用Thread类的对象去调用Thread类中的start()方法：1.启动线程 2.Thread中的run()调用了Runnable中的run()</span></span><br><span class="line">   thread01.start();</span><br><span class="line">   <span class="comment">// 再创建一个线程时，可以直接再new一个Thread类即可，不需要再new实现类</span></span><br><span class="line">   <span class="comment">/*【但这种方式会共享同一个 runnableThread 对象中的状态，包括非 static 修饰的成员变量。</span></span><br><span class="line"><span class="comment">   因为 thread01 和 thread02 实际上都是使用同一个 runnableThread 对象作为参数传递给了 Thread 类的构造器】*/</span></span><br><span class="line">   <span class="type">Thread</span> <span class="variable">thread02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableThread);</span><br><span class="line">   thread02.setName(<span class="string">&quot;Thread 02&quot;</span>);</span><br><span class="line">   thread02.start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//RunnableThread 实现Runnable接口中的run()抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> ** <span class="number">0</span>) System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p><strong>继承Thread、实现Runnable的区别</strong></p><ul><li>Java只允许单继承，但可以实现多个接口。因此<strong>实现接口的方式没有类的单继承性的局限</strong>，用实现Runnable接口的方式来完成多线程更加实用。</li><li>实现Runnable接口的方式天然具有共享数据的特性（不需要static修饰）。因为继承Thread的实现方式，需要创建多个子类的对象来进行多线程，如果子类中有变量A，而不使用static修饰变量的话，每一个子类的对象都会有自己独立的变量A，只有static修饰A后，子类的对象才可以共享变量A。而实现Runnable接口的方式，如果只创建一个实现类的对象，并将这个对象传入Thread类，创建多个Thread类的对象来完成多线程，那么这多个Thread类对象实际就是调用一个实现类的对象而已，会共享到这个实现类的对象中的所有变量【需要注意线程安全问题】。<strong>实现接口的方式更适合用来处理多个线程要共享数据&#x2F;该类已有父类的情况。</strong></li><li>联系：Thread类中也实现了Runnable接口。</li><li>相同点：两者都需要重写run方法。线程的执行逻辑都在run()方法中。</li></ul></blockquote><h4 id="5-2-4-实现Callable接口-可有返回值"><a href="#5-2-4-实现Callable接口-可有返回值" class="headerlink" title="5.2.4.实现Callable接口[可有返回值]"></a>5.2.4.实现Callable接口[可有返回值]</h4><p>与Runnable相比，Callable接口中定义了一个额外的方法call()，该方法可以有返回值。</p><ol><li>创建实现Callable接口的实现类</li><li>重写call()方法，该方法将作为线程执行体，并且有返回值。【支持泛型的返回值、可以抛出异常】</li><li>创建实现类的对象【表示多线程要执行的任务】</li><li>创建FutureTask类对象，将Callable接口实现类的对象作为构造器参数传递。【管理多线程运行的结果】</li><li>创建Thread对象，将FutureTask对象作为Thread对象的构造器参数传递。【表示线程】</li><li>可以通过FutureTask对象调用get方法获取多线程运行结果。【获取多线程运行结果】</li></ol><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">CallableTest</span> <span class="variable">callableTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableTest</span>();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callableTest);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中Call方法的返回值</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(result); <span class="comment">// 输出：45</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallableTest</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="5-2-5-线程池"><a href="#5-2-5-线程池" class="headerlink" title="5.2.5.线程池"></a>5.2.5.线程池</h4><ul><li>线程池<ul><li>基本概念<ul><li>线程池是管理一堆就绪状态线程的池化技术</li><li>避免线程的重复创建和销毁带来的性能损耗，对线程统一管理</li></ul></li><li>实现原理<ul><li>接受到一个任务时，判断线程池中现有存活的线程，是否有空闲</li><li>如果已创建的核心线程都有任务，则将任务放到队列中</li><li>如果队列满了，就判断当前线程池的线程数量是否达到最大值，没有的话创建新的线程并执行该任务</li><li>如果达到了最大的线程数量，则按照设定的拒绝策略处理该任务</li></ul></li><li>创建方式<ul><li><strong>Executors.newFixedThreadPool(int n)</strong>：创建固定大小的线程池</li><li><strong>Executors.newCachedThreadPool()</strong>:无穷大的线程池【容量默认为 Integer.MAX_VALUE】</li><li><strong>Executors.newSingleThreadExecutor()</strong>：创建单线程的线程池</li><li><strong>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,</strong><br><strong>BlockingQueue<runnable>workQueue，ThreadFactory threadFactory，</runnable></strong><br><strong>RejectedExecutionHandler handler)</strong>：创建自定义线程池【7个参数，最常用】</li><li><strong>ThreadPoolTaskExecutor (Spring Framework)</strong>：是 Spring 框架提供的用于管理线程池的工具类</li></ul></li><li>自定义线程池的7个参数<ul><li>核心线程数：理论上不能被回收的线程数量 【默认为 Integer.MAX_VALUE，不能小于0】</li><li>最大线程数：最大能创建的线程数量【大于等于核心线程数】</li><li>存活时间数值：表示的是一个线程没有任务执行时最多保持多长时间会终止。【不能小于0】</li><li>存活时间单位：参数keepAliveTime的时间单位。【用TimeUnit指定】</li><li>阻塞队列：任务量超过核心线程数时，任务会依次进入队列【默认为 LinkedBlockingQueue】<ul><li><strong>ArrayBlockingQueue</strong>：数组类有界队列，IFIO（先进先出）【不是一个严格的FIFO队列，多线程下不保证公平性】</li><li><strong>LinkedBlockingQueue</strong>：链表类有界队列【默认为interger.max队列】，FIFO（先进先出）</li><li><strong>SynchronousQueue</strong>：同步队列，不存储任务</li><li><strong>PriorityBlockingQueue</strong>：优先级队列，实现Comparable接口的指定元素排列方式</li><li><strong>DelayQueue</strong>：延迟队列，只有在延迟期满时才可以取出元素</li><li><strong>LinkdTransferQueue</strong>：链表类无界队列，相比有界链表队列，多了两个方法</li><li><strong>LinkedBlockingDeque</strong>：头部尾部都可以添加和移除元素，降低锁竞争</li></ul></li><li>线程工厂：创建线程，去执行提交的任务【默认为<strong>Executors.defaultThreadFactory()</strong>】</li><li>拒绝策略<ul><li><strong>ThreadPoolExecutor.AbortPolicy</strong>: 丢弃任务并抛出 RejectedExecutionException 异常。【默认策略】</li><li><strong>ThreadPoolExecutor.DiscardPolicy</strong>: 丢弃任务，但是不抛出异常。【这是不推荐的做法】</li><li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>: 抛弃队列中等待最久的任务[排在最前面]，然后把当前任务加入队列中。</li><li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>: 调用任务的 run() 方法绕过线程池直接运行该任务。</li></ul></li></ul></li><li>提交任务<ul><li><strong>execute()</strong>：用于提交不需要返回值的任务</li><li><strong>submit()</strong>：用于提交需要返回值的任务</li></ul></li><li>关闭线程<ul><li><strong>shutdown()</strong>：关闭线程池，线程池不再接受新任务，但会继续执行任务</li><li><strong>shutdownNow()</strong>：关闭线程池，线程池不再接受新任务，并且尝试中断正在执行的任务</li><li><strong>isShutdown()</strong>：判断线程池是否关闭</li><li><strong>isTerminated()</strong>：判断线程池是否终止</li></ul></li><li>线程池的监控<ul><li><strong>ThreadPoolExecutor.getActiveCount()</strong>：获取当前线程池中正在执行的任务数量</li><li><strong>ThreadPoolExecutor.getTaskCount()</strong>：获取线程池中任务总数量</li><li><strong>ThreadPoolExecutor.getCompletedTaskCount()</strong>：获取线程池中已完成的任务数量</li><li><strong>ThreadPoolExecutor.getLargestPoolSize()</strong>：获取线程池中曾经创建过的最大线程数量</li></ul></li><li>合理配置线程池的参数</li></ul></li></ul><h5 id="5-2-5-1-线程池的体系结构"><a href="#5-2-5-1-线程池的体系结构" class="headerlink" title="5.2.5.1.线程池的体系结构"></a>5.2.5.1.线程池的体系结构</h5><ul><li>出现的原因：经常创建和销毁、使用量特别大的资源、比如并发情况下的线程、对性能影响很大。</li><li>设计思路：​ 提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</li><li>优点：<ul><li>提高相应速度【减少创建和销毁时间】</li><li>降低资源消耗【重复利用线程池中的线程，不需要每次都重新创建】</li><li>便于线程管理</li></ul></li><li>实现原理<ul><li>接受到一个任务时，判断线程池中现有存活的线程，是否有空闲</li><li>如果已创建的核心线程都有任务，则将任务放到队列中</li><li>如果队列满了，就判断当前线程池的线程数量是否达到最大值，没有的话创建新的线程并执行该任务</li><li>如果达到了最大的线程数量，则按照设定的拒绝策略处理该任务<br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240510192306.png"></li></ul></li></ul><h5 id="5-2-5-2-线程池的创建方式"><a href="#5-2-5-2-线程池的创建方式" class="headerlink" title="5.2.5.2.线程池的创建方式"></a>5.2.5.2.线程池的创建方式</h5><table><thead><tr><th>创建方式</th><th>描述</th></tr></thead><tbody><tr><td><code>Executors.newFixedThreadPool(int n)</code></td><td>创建一个固定大小的线程池，该线程池中的线程数量固定为指定的大小 <code>n</code>，当有任务提交时，如果线程池中的线程都在执行任务，新的任务会在任务队列中等待。</td></tr><tr><td><code>Executors.newCachedThreadPool()</code></td><td>创建一个缓存线程池，该线程池中的线程数量会根据任务的数量动态调整，当有任务提交时，如果线程池中有空闲线程，则立即使用；如果没有，则创建新的线程执行任务。空闲线程在一定时间内没有被使用会被回收。</td></tr><tr><td><code>Executors.newSingleThreadExecutor()</code></td><td>创建一个单线程的线程池，该线程池中只有一个核心线程，所有任务都在同一个线程中串行执行。适用于需要顺序执行任务的场景，例如事件触发器、定时任务等。</td></tr><tr><td><code>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue，ThreadFactory threadFactory，RejectedExecutionHandler handler)</code></td><td>使用 <code>ThreadPoolExecutor</code> 构造函数自定义配置线程池，可以指定核心线程数、最大线程数、线程空闲时间、任务队列等参数。可以根据实际需求灵活配置线程池。</td></tr><tr><td><code>ThreadPoolTaskExecutor (Spring Framework)</code></td><td>在 Spring Framework 中使用 <code>ThreadPoolTaskExecutor</code> 类创建线程池，该类是 Spring 框架提供的用于管理线程池的工具类，具有更多的扩展性和配置选项，可以通过 Spring 的配置文件或 Java 代码进行灵活配置。</td></tr></tbody></table><p><strong>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue，ThreadFactory threadFactory，RejectedExecutionHandler handler)的参数解释：</strong></p><ol><li><p>corePoolSize：核心线程数,表示线程池中始终存活的线程数。【不能小于0】</p></li><li><p>maximumPoolSize：最大线程数,线程池中允许的最大线程数。【最大数量&gt;&#x3D;核心线程数量】</p></li><li><p>keepAliveTime：存活时间数值,表示的是一个线程没有任务执行时最多保持多长时间会终止。【不能小于0】</p></li><li><p>unit：存活时间单位,参数keepAliveTime的时间单位。【用TimeUnit指定】</p><ul><li><strong>TimeUnit.DAYS</strong>: 天</li><li><strong>TimeUnit.HOURS</strong>：小时</li><li><strong>TimeUnit.MINUTES</strong>：分钟</li><li><strong>TimeUnit.SECONDS</strong>：秒</li><li><strong>TimeUnit.MILLISECONDS</strong>：毫秒</li><li><strong>TimeUnit.MICROSECONDS</strong>：微秒</li><li><strong>TimeUnit.NANOSECONDS</strong>：纳秒</li></ul></li><li><p>workQueue：阻塞队列，用于存放等待执行任务的队列，均为线程安全。【不能为null】</p><ul><li><strong>ArrayBlockingQueue</strong>：基于数组的有界阻塞队列，按照先进先出（FIFO）的顺序存储元素【不是一个严格的FIFO队列，多线程下不保证公平性】。当队列已满时，尝试插入元素会导致操作阻塞。</li><li><strong>LinkedBlockingQueue</strong>：基于链表的无界阻塞队列，按照先进先出（FIFO）的顺序存储元素。由于队列容量没有限制，因此不会导致插入操作阻塞但在队列为空时，尝试取出元素会导致操作阻塞。</li><li><strong>SynchronousQueue</strong>：同步队列，不存储元素，每个插入操作必须等待另一个线程的移除操作。这意味着插入操作和移除操作是同步的，如果没有消者线程等待取出元素，插入操作会一直阻塞。</li><li><strong>PriorityBlockingQueue</strong>：优先级的无界阻塞队列，元素按照优先级顺序存储，而非先进先出。它使用无锁的堆实现，保证了线程安全性和高效性。</li><li><strong>DelayQueue</strong>：基于优先级队列的无界阻塞队列，只有在延迟期满时才能从中提取元素。常用于定时任务调度场景，也是使用无锁的堆实现。</li><li><strong>LinkedTransferQueue</strong>：基于链表结构的无界阻塞队列，类似于 SynchronousQueue，但也包含非阻塞的 tryTransfer 方法，用于非阻塞地将元素转移给消费者线程。</li><li><strong>LinkedBlockingDeque</strong>：基于链表结构的双向阻塞队列，容量默认为 Integer.MAX_VALUE。它可以在队列的头部和尾部进行插入和移除操作，提供了更灵活的队列操作方式。</li></ul></li><li><p>threadFactory: 线程工厂，主要用来创建线程，<code>Executors.defaultThreadFactory()</code>-&gt;默认正常优先级、非守护线程。也可以自己创建线程工厂。【不能为null】</p></li><li><p>handler: 拒绝策略，当队列满时，线程池会拒绝新任务。默认使用 AbortPolicy 策略。</p><ul><li><strong>ThreadPoolExecutor.AbortPolicy</strong>: 丢弃任务并抛出 RejectedExecutionException 异常。【默认策略】</li><li><strong>ThreadPoolExecutor.DiscardPolicy</strong>: 丢弃任务，但是不抛出异常。【这是不推荐的做法】</li><li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>: 抛弃队列中等待最久的任务[排在最前面]，然后把当前任务加入队列中。</li><li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>: 调用任务的 run() 方法绕过线程池直接运行该任务。</li></ul></li></ol><h5 id="5-2-5-3-线程池提交任务的方式"><a href="#5-2-5-3-线程池提交任务的方式" class="headerlink" title="5.2.5.3.线程池提交任务的方式"></a>5.2.5.3.线程池提交任务的方式</h5><ul><li><strong>execute()</strong>: 用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。excute()方法输入的任务是一个Runnable类的实例</li><li><strong>submit()</strong>: 用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法获取到任务的返回值。get()方法会阻塞当前线程直到任务执行完毕。而使用get(long timeout,TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完成。<ul><li><code>Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>：接受一个Callable接口的实例，表示要执行的任务，并返回一个Future对象，可以通过对象的get()方法获取执行结果。</li><li><code>Future&lt;?&gt; submit(Runnable task)</code>：接受一个Runnable接口的实例，表示要执行的任务，并返回一个Future对象，但对象的get()方法返回值总是为null。</li><li><code>Future&lt;T&gt; submit(Runnable task, T result)</code>：与上一种类似，但可以提供一个结果作为参数，表示任务完成时的结果。</li></ul><blockquote><ul><li><strong>submit()方法的使用注意事项</strong>:<ul><li><code>submit()</code>方法返回一个<code>Future</code>对象，通过该对象可以获取任务执行的结果，但是要注意<code>Future</code>对象的<code>get()</code>方法会阻塞当前线程，直到任务执行完成并返回结果，这可能会导致当前线程被堵塞。</li><li>在多线程环境中，如果在循环中频繁调用<code>get()</code>方法，可能会降低程序的并发性能，甚至引发死锁等问题。因此，在使用<code>submit()</code>方法提交任务时，需要谨慎考虑是否需要等待任务执行完成。</li></ul></li></ul></blockquote></li></ul><h5 id="5-2-5-4-关闭线程池"><a href="#5-2-5-4-关闭线程池" class="headerlink" title="5.2.5.4.关闭线程池"></a>5.2.5.4.关闭线程池</h5><ul><li><p>调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池</p><ul><li><code>shutdown</code>：线程池的状态设置称SHUTDOWN，线程池会拒绝新的任务，关闭没有任务的那些空闲线程，并且等待已提交的任务执行完成。该方法用于需要等待线程都执行完成任务的场景。</li><li><code>shutdownNow</code>：线程池的状态设置称STOP，线程池会立即尝试停止所有正在执行的任务，并且不再等待任务执行完毕，正在执行的任务会被中断，未执行的任务会被取消。<blockquote><p>关闭原理：它们的原理是遍历线程池中的工作线程，然后逐个调用线程的<code>interrupt</code>方法来中断线程，所以无法响应中断的任务可能永远无法终止运行。</p></blockquote></li></ul></li><li><p>判断线程池状态：<code>isShutdown()</code>、<code>isTerminated()</code></p><ul><li><code>isShutdown()</code>：如果调用了上述的两个关闭之一，isShutdown()方法返回值为true</li><li><code>isTerminated()</code>：判断线程池是否已经完全终止。当所有任务都已关闭，即线程池关闭完成，isTerminated()方法返回值为true</li></ul></li></ul><h5 id="5-2-5-5-线程池的监控"><a href="#5-2-5-5-线程池的监控" class="headerlink" title="5.2.5.5.线程池的监控"></a>5.2.5.5.线程池的监控</h5><ul><li>目的：方便在出现问题时，可以根据线程池的使用状态快速定位问题</li><li>监控方法：<ul><li><code>ThreadPoolExecutor.getActiveCount()</code>：获取当前线程池中正在执行的任务数量</li><li><code>ThreadPoolExecutor.getTaskCount()</code>：获取线程池中任务总数量</li><li><code>ThreadPoolExecutor.getCompletedTaskCount()</code>：获取线程池中已完成的任务数量</li><li><code>ThreadPoolExecutor.getLargestPoolSize()</code>：获取线程池中曾经创建过的最大线程数量</li></ul></li><li>拓展线程池的监控方法：可以通过继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute方法和terminated方法，也可以在任务执行前、执行后和线程关闭前执行一些代码来进行监控。例如：监控任务的平均执行时间、最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。</li></ul><h5 id="5-2-5-6-如何合理配置线程池的参数"><a href="#5-2-5-6-如何合理配置线程池的参数" class="headerlink" title="5.2.5.6.如何合理配置线程池的参数"></a>5.2.5.6.如何合理配置线程池的参数</h5><ul><li>任务的性质<ul><li>CPU密集型任务：任务以内存中的计算为主。避免线程上下文切换的成本。一般CPU是N核，就开N+1个线程</li><li>IO密集型任务：尽量多开启一些线程并发做IO操作。因为在IO过程中，CPU几乎是闲置的。一般可能是2*CPU核数,当然根据下面的标准公式计算会好一些：<br>$ \text{最大并行数} \times \text{期望CPU利用率} \times \frac{\text{总时间} (\text{CPU计算时间} + \text{等待时间})}{\text{CPU计算时间}} $</li></ul></li><li>任务的优先级【高中低】：优先级不同的任务可以使用优先队列<code>PriorityBlockingQueue</code>来处理。它可以让优先级高的任务先执行。</li><li>任务的执行时间【长中短】：根据任务的执行时间、设置核心线程数、最大线程数、队列容量等参数，来确定线程池的配置。【当然，过大的线程池可能会导致系统资源过度占用，需要根据实际情况进行合理配置】</li><li>最好使用有界队列：有界队列能增强系统的稳定性和预警能力，可以根据需要设置大一点，比如几千。有一次，我们系统里后台任务线程池的队列和线程池的最大线程数量全满了，不断抛出抛弃任务的异常，通过排查发现是数据库出现了问题</li></ul><h5 id="5-2-5-7-代码演示"><a href="#5-2-5-7-代码演示" class="headerlink" title="5.2.5.7.代码演示"></a>5.2.5.7.代码演示</h5><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExectorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                <span class="number">6</span>,</span><br><span class="line">                <span class="number">60</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line">        <span class="type">runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">runnable</span>();</span><br><span class="line">        threadPoolExecutor.execute(runnable);</span><br><span class="line">        Future&lt;Integer&gt; submit = threadPoolExecutor.submit(<span class="keyword">new</span> <span class="title class_">callable</span>());</span><br><span class="line">        System.out.println(submit.get());</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">runnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">callable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>执行了</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></div><h2 id="6-线程的安全问题"><a href="#6-线程的安全问题" class="headerlink" title="6.线程的安全问题"></a>6.线程的安全问题</h2><h3 id="6-1-前置知识"><a href="#6-1-前置知识" class="headerlink" title="6.1.前置知识"></a>6.1.前置知识</h3><p><strong>在认识线程的安全问题之前，我们需要先了解一下多线程的三大特性、JMM（Java Memory Model，即Java内存模型）以及活跃性问题的相关知识</strong></p><ul><li><strong>线程的三大特性</strong>：<ul><li>原子性：<ul><li>即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li><li>对于复合操作而言，synchronized，Lock可以保证原子性，而volatile关键字不能</li></ul></li><li>可见性：<ul><li>当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li><li>synchronized、Lock和volatile关键字都能保证可见性</li></ul></li><li>有序性：<ul><li>程序代码执行的结果不受JVM指令重排序的影响。</li><li>synchronized、Lock和volatile关键字都能保证有序性</li></ul></li></ul></li></ul><blockquote><p><strong>总结</strong>：<br><strong>synchronized</strong>可以保证原子性、可见性和有序性。（这里的有序性是有限的）<br><strong>volatile关键字</strong>可以保证可见性、有序性，对于单独的volatile变量的读写操作，也能保证原子性。然而，volatile 不能保证复合操作的原子性，比如 volatile int a &#x3D; 0; a++; 这种情况并不是原子的。需要使用 AtomicInteger 等原子类来保证原子性。<br><strong>Lock锁机制</strong>可以同时保证以上三个特性，但需要手动管理锁的获取和释放。因此，在不需要Lock特定功能的情况下，一般推荐使用synchronized。</p></blockquote><ul><li><p><strong>JMM</strong>：</p><ul><li>关键概念<ul><li>共享内存：即主存，所有线程共享，【堆区与方法区】</li><li>本地内存（线程）：也称为”工作内存”。JVM给每一个线程都分配了一块内存区域（线程栈：有程序计数器、方法栈等），该块内存是线程独有的。</li></ul></li><li>JMM规定：线程不能直接操作主存，而是只能操作属于自己的那部分内存。如果多个线程间需要进行变量共享，必须经过主存进行同步。<ul><li>由于JMM的限制，线程操作变量都需要经过以下几个基本步骤：<br>1.线程从主存中读取变量值到工作内存中<br>2.在工作内存中对变量进行修改操作<br>3.将操作后的结果同步回主存</li></ul></li><li>重排序：为了提高持续执行性能，编译器和CPU会对指令进行重排序。但是在多线程环境下，重排序可能导致线程安全问题，因此必须遵循 happens-before 原则来保证正确的执行顺序。</li><li>hapens-before原则：这个原则描述了在多线程环境下，操作执行的先后顺序。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这个原则确保了正确的内存可见性和有序性。</li></ul></li><li><p><strong>活跃性问题</strong>：</p><ul><li>活跃性问题：活跃性是指某件正确的事情最终会发生，但当某个操作无法继续下去的时候，就会发生活跃性问题。<ul><li>死锁：多个线程相互等待对方持有的资源而无法继续执行，导致所有线程都无法完成任务。</li><li>活锁：线程不断重复相同的操作，但无法取得进展，因此任务无法完成，尽管线程在运行。</li><li>饥饿问题：一个或多个线程由于无法获取所需的资源而无法继续执行，尽管资源可用，但被其他线程占用，导致线程长时间无法完成任务。</li></ul></li></ul></li></ul><h3 id="6-2-基本概念"><a href="#6-2-基本概念" class="headerlink" title="6.2.基本概念"></a>6.2.基本概念</h3><ul><li>衡量标准：如果同一个程序在单线程环境下与在多线程下执行的结果一致，就说明线程安全，反之则是线程不安全</li><li>所谓的线程安全问题，其本质在于线程对共享变量操作的原子性、可见性、有序性不能同时满足或者存在活跃性问题，因此解决线程安全问题的关键就在于同时满足三大特性并避免活跃性问题出现。解决线程安全问题可能需要采取多种手段，包括使用锁机制、原子类、volatile 关键字、并发集合等，具体的方法取决于具体的场景和需求。</li></ul><h3 id="6-3-线程的不安全的原因"><a href="#6-3-线程的不安全的原因" class="headerlink" title="6.3.线程的不安全的原因"></a>6.3.线程的不安全的原因</h3><h4 id="6-3-1-原子性"><a href="#6-3-1-原子性" class="headerlink" title="6.3.1.原子性"></a>6.3.1.原子性</h4><blockquote><ul><li>原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li><li>原子操作：它是在单个步骤内执行完毕，不可中断的操作。这意味着原子操作的执行过程是连续的，不会被线程切换、中断或者其他因素打断。原子操作的执行要么全部完成，要么完全不执行，没有中间状态。</li></ul></blockquote><p>看这样一个例子，如下图<br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240513204704.png"><br>这最终导致的结果是一张票被售卖了两次，这样就具有很大的风险性。售票的过程被分成三个可分割的步骤执行，不具有原子性。</p><blockquote><p><strong>注意</strong>：我们在写一行Java代码可能不是原子性的，因为它编译成字节码，或者由JVM把字节码翻译成机器码后就可能不是一行，也就是多条执行操作。</p></blockquote><p>在并发编程中很多操作都不是原子操作，出个小题目：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 操作1</span></span><br><span class="line">i++;<span class="comment">// 操作2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;<span class="comment">// 操作3</span></span><br><span class="line">i = i + <span class="number">1</span>;<span class="comment">// 操作4</span></span><br></pre></td></tr></table></figure></div><ul><li>操作1：这是原子操作，因为它是一个单一的、不可分割的步骤。</li><li>操作2：这不是原子操作，这实际上是一个 “read-modify-write” 操作，它包括了读取 i 的值、修改 i 的值和写回 i 的值。</li><li>操作3：这是一个原子操作，因为它是一个单一的、不可分割的步骤。</li><li>操作4：这不是原子操作，和 i++ 一样，这也是一个 “read-modify-write” 操作。</li></ul><p>在单线程环境下上述是个操作都不会出现问题，但在多线程环境下，如果不加锁或者使用原子类的话，可能会出现意料之外的值。我们来测试一下，看看输出结果。</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YuanziDeo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">numThreads</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">numIncrementsPerThread</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">      Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[numThreads];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; numThreads; j++) &#123;</span><br><span class="line">          threads[j] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">              increase(numIncrementsPerThread);</span><br><span class="line">          &#125;);</span><br><span class="line">          threads[j].start();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">          thread.join();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Final value of i = &quot;</span> + i);</span><br><span class="line">      System.out.println(<span class="string">&quot;Expected value = &quot;</span> + (numThreads * numIncrementsPerThread));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">(<span class="type">int</span> numIncrementsPerThread)</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; numIncrementsPerThread; k++) &#123;</span><br><span class="line">          i++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>输出如下:</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Final value <span class="type">of</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">118667</span></span><br><span class="line"><span class="type">Expected</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">200000</span></span><br></pre></td></tr></table></figure></div><p>i 期望的值为 200000，但实际跑出来的是 118667，这证明 i++ 不是一个原子操作，</p><blockquote><p>i++,i- -操作被分成三步执行：</p><ul><li>从主存把数据读取到本地内存</li><li>对数据进行更新操作</li><li>再把更新后的操作写回主存</li></ul><p>在多线程中，这三个步骤再执行时，线程可以被中断，导致数据更新出现问题，eg：线程1拿了 i &#x3D; 100 ，执行 ++ 操作后，本地内存中i &#x3D; 101，还没来得及写回主存，被线程2抢到CPU执行权，线程2从主存中拿到的 i &#x3D; 100（还是100，还没有被线程1更新），假设后面的流程是线程2执行完了3个步骤后把主存中的i更新为101后，线程1又抢到CPU执行权，完成步骤3，更新完主存中的i还是等于101，这就相当于两次++操作最终i只加了1。</p></blockquote><h4 id="6-3-2-可见性"><a href="#6-3-2-可见性" class="headerlink" title="6.3.2.可见性"></a>6.3.2.可见性</h4><blockquote><p>可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值。</p></blockquote><p>来看这段代码</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo17</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1：开始执行 &quot;</span> + LocalDateTime.now());</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1：结束执行 &quot;</span> + LocalDateTime.now());</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line"> </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2：修改flag = false &quot;</span> + LocalDateTime.now());</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：<br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240514111412.png"><br>可以看到，线程2将flag修改为false，线程1始终未结束执行【线程1中的flag并没有得到更新，始终是true】，这就是内存可见性问题。</p><blockquote><p>多个线程工作的时候都是<strong>在自己的工作内存</strong>来执行操作的，<strong>线程之间是不可见</strong>的:</p><ol><li>线程之间的<code>共享变量存在主存中</code></li><li>每一个<code>线程</code>都有自己的<code>工作内存</code></li><li>线程读取共享变量时，先把变量从主内存拷贝到自己的工作内存（CPU寄存器），再从工作内存读取数据</li><li>线程修改共享变量时，先修改工作内存中的变量值，再同步到主内存【并不能及时将新值刷新到主内存中】</li></ol></blockquote><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240513215241.png" alt="" width="40%" height="auto"><h4 id="6-3-3-有序性"><a href="#6-3-3-有序性" class="headerlink" title="6.3.3.有序性"></a>6.3.3.有序性</h4><blockquote><p><strong>了解重排序</strong>：在计算机系统内部，程序中的指令并非严格按照源代码的顺序执行。当一个CPU核心通过流水线技术处理指令时，若前条指令未完成但不影响后续指令的执行，处理器可能会提前执行下一条或多条指令。同样地，编译器在生成机器代码的过程中也可能出于化目的重新安排源代码的执行顺序。这种现象就被称为指令重排序。（在java内存模型中，允许编译器和处理器对指令进行重排序，重排过程不会影响单线程程序的执行，但是会影响多线程并发执行的正确性）<br>比如有这样三步操作：（1）去前台取U盘 （2）去教室写作业 （3）去前台取快递<br>JVM会对指令优化，也就是重排序，新的顺序为（1）（3）（2），这样来提高效率</p><p>虽然重排序提高了CPU利用率和程序执行效率，但它也可能引入了潜在的多线程问题，尤其是在没有正确同步的情况下，可能导致不可预测的行为和数据竞争。为此，Java内存模型（JMM）通过happens-before规则来限制重排序，并确保在正确同步的多线程环境中，各线程能观察到一致且符合预期的内存状态。</p></blockquote><p>当程序没有进行正确的同步控制时，就可能出现数据竞争问题。数据竞争指的是在一个线程内写入变量的同时，另一个线程读取了同一个变量，且这两个操作之间没有通过任何同步机制来确保执行顺序。这种情况下，程序的行为可能变得不可预测，例如读取到未更新的数据或者状态混乱。<br>来看这段代码</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：数据竞争</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataRaceExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sharedValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">writerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        sharedValue = <span class="number">1</span>; <span class="comment">// 写操作</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">readerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">localCopy</span> <span class="operator">=</span> sharedValue; <span class="comment">// 读操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Reader sees: &quot;</span> + localCopy);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startThreads</span><span class="params">()</span> &#123;</span><br><span class="line">        writerThread.start();</span><br><span class="line">        readerThread.start(); <span class="comment">// 数据竞争，因为没有同步措施</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在这个示例中，读者线程可能会在写者线程完成赋值之前就读取sharedValue，从而导致结果不确定。</p><blockquote><p>有序性：即程序的执行顺序按照代码的先后顺序执行。（在java内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响单线程程序的执行，但是会影响多线程并发执行的正确性）</p></blockquote><h4 id="6-3-4-活跃性问题"><a href="#6-3-4-活跃性问题" class="headerlink" title="6.3.4.活跃性问题"></a>6.3.4.活跃性问题</h4><p>上面讲到的问题都可以采取加锁的方式来解决，但是如果加锁不当也容易引入其他问题，比如『死锁』。<br>在讲『死锁』之前，我们需要先引入另外一个概念：<code>活跃性问题</code>。</p><blockquote><p>活跃性是指某件正确的事情最终会发生，但当某个操作无法继续下去的时候，就会发生活跃性问题。</p></blockquote><p>活跃性问题一般有这样几类：<code>死锁</code>，<code>活锁</code>，<code>饥饿问题</code>。</p><ul><li><strong>死锁</strong>：<br>死锁是指多个线程因为环形等待锁的关系而永远地阻塞下去。<br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240513225747.png"></li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockExample</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1 acquired lock1&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1 waiting for lock2&quot;</span>);</span><br><span class="line">              <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;Thread 1 acquired lock2&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 2 acquired lock2&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 2 waiting for lock1&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 2 acquired lock1&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>输出结果：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span> acquired lock1</span><br><span class="line">Thread <span class="number">2</span> acquired lock2</span><br><span class="line">Thread <span class="number">2</span> waiting <span class="keyword">for</span> lock1</span><br><span class="line">Thread <span class="number">1</span> waiting <span class="keyword">for</span> lock2</span><br></pre></td></tr></table></figure></div><ul><li><strong>活锁</strong>：<br>死锁是两个线程都在等待对方释放锁而导致阻塞。而<code>活锁</code>的意思是线程没有阻塞，还活着呢。当多个线程都在运行并且修改各自的状态，而其他线程又依赖这个状态，就导致任何一个线程都无法继续执行，只能重复着自身的动作，于是就发生了活锁。<br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240513230139.png"><br>举一个生活中的例子，大家平时在走路的时候，迎面走来一个人，两个人互相让路，但是又同时走到了一个方向，如果一直这样重复着避让，这俩人就发生了活锁，学到了吧，嘿嘿。</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LivelockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">shouldTakeStep1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">shouldTakeStep2</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shouldTakeStep1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 1 takes step 1&quot;</span>);</span><br><span class="line">                    shouldTakeStep1 = <span class="literal">false</span>;</span><br><span class="line">                    shouldTakeStep2 = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 1 waits for Thread 2 to take step 2&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shouldTakeStep2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 2 takes step 2&quot;</span>);</span><br><span class="line">                    shouldTakeStep2 = <span class="literal">false</span>;</span><br><span class="line">                    shouldTakeStep1 = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 2 waits for Thread 1 to take step 1&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>输出结果：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span> takes step <span class="number">1</span></span><br><span class="line">Thread <span class="number">1</span> waits <span class="keyword">for</span> Thread <span class="number">2</span> to take step <span class="number">2</span></span><br><span class="line">Thread <span class="number">2</span> takes step <span class="number">2</span></span><br><span class="line">Thread <span class="number">2</span> waits <span class="keyword">for</span> Thread <span class="number">1</span> to take step <span class="number">1</span></span><br><span class="line">Thread <span class="number">1</span> takes step <span class="number">1</span></span><br><span class="line">Thread <span class="number">1</span> waits <span class="keyword">for</span> Thread <span class="number">2</span> to take step <span class="number">2</span></span><br><span class="line">Thread <span class="number">2</span> waits <span class="keyword">for</span> Thread <span class="number">1</span> to take step <span class="number">1</span></span><br><span class="line">Thread <span class="number">2</span> takes step <span class="number">2</span></span><br><span class="line">Thread <span class="number">2</span> waits <span class="keyword">for</span> Thread <span class="number">1</span> to take step <span class="number">1</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure></div><ul><li><strong>饥饿</strong>：<br>如果一个线程无其他异常却迟迟不能继续运行，那基本上是处于饥饿状态了<br>常见的有几种场景<ul><li>高优先级的线程一直在运行消耗CPU，所有低优先级线程一直处于等待</li><li>一些线程被永久堵塞在一个等待进入同步块的状态，而其他线程总是能在它之前持续地对该同步块进行访问</li></ul></li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StarvationExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (StarvationExample.class) &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟线程持续运行</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">highPriorityThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        highPriorityThread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">lowPriorityThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        lowPriorityThread.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line"></span><br><span class="line">        highPriorityThread.start();</span><br><span class="line">        lowPriorityThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="7-线程的同步"><a href="#7-线程的同步" class="headerlink" title="7.线程的同步"></a>7.线程的同步</h2><blockquote><p>上面我们提到了多线程造成的不安全问题，那么我们应该怎么解决呢？<br>解决多线程安全问题的关键就在于实现多线程的同步，即制某个资源在同一时刻只能被一个线程访问。</p></blockquote><h3 id="7-1-volatile关键字"><a href="#7-1-volatile关键字" class="headerlink" title="7.1.volatile关键字"></a>7.1.volatile关键字</h3><blockquote><p><code>volatile</code>是用来<code>修饰变量</code>的，它的作用是<code>保证可见性、有序性</code><br><strong>注意</strong>：<strong>不能保证原子性</strong>，对于n++,n--来说，用volatile修饰n也是线程不安全的</p></blockquote><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li>代码在写入volatile修饰的变量的时候，改变线程工作内存中volatile变量副本的值，改变后的值会立即写回到主存，并且会立即使其他线程的工作内存中对应的缓存无效。这确保了其他线程在下次读取该变量时能够看到最新的值。</li><li>代码在读取volatile修饰的变量的时候，会从主存中读取volatile变量的最新值到线程工作内存中，再从工作内存中读取volatile变量的副本</li></ul><h4 id="volatile解决可见性问题"><a href="#volatile解决可见性问题" class="headerlink" title="volatile解决可见性问题"></a>volatile解决可见性问题</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo17</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1：开始执行 &quot;</span> + LocalDateTime.now());</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1：结束执行 &quot;</span> + LocalDateTime.now());</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line"> </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2：修改flag = false &quot;</span> + LocalDateTime.now());</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：<br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240514113308.png"><br>给变量flag加上volatile修饰后，线程1能够接收到flag的改变，从而结束了执行，解决了内存的可见性问题。</p><h4 id="volatile关键字的缺点"><a href="#volatile关键字的缺点" class="headerlink" title="volatile关键字的缺点"></a>volatile关键字的缺点</h4><p>volatile关键字虽然可以解决内存的可见性和指令重排序的问题，但解决不了原子性问题，对于 ++ 和 -- 操作的线程非安全问题依然解决不了，比如以下代码：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemoVolatile</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">        <span class="comment">// 变量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 循环次数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> MAX_COUNT;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Counter</span><span class="params">(<span class="type">int</span> MAX_COUNT)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.MAX_COUNT = MAX_COUNT;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// ++ 方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_COUNT; i++) &#123;</span><br><span class="line">                number++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// -- 方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">desc</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_COUNT; i++) &#123;</span><br><span class="line">                number--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">100000</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(counter::increase);</span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(counter::desc);</span><br><span class="line">        thread2.start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 等待线程执行完成</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;最终结果：&quot;</span> + counter.getNumber()); <span class="comment">// 不一定等于0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="7-2-synchronized锁"><a href="#7-2-synchronized锁" class="headerlink" title="7.2.synchronized锁"></a>7.2.synchronized锁</h3><p>我们知道，在Java中，<code>每一个对象都有一把唯一的锁</code>，这也是synchronized实现线程同步的基础。【唯一的锁也就是对象的监视器锁，也称为内部锁或互斥锁】</p><blockquote><p><code>synchronized</code>是<code>基于对象头加锁</code>的，它的作用是<code>保证了原子性、可见性、有序性</code>（这里的有序性是有限的）<br>特别注意：<strong>不是对代码加锁，所说的加锁操作就是给这个对象的对象头里设置了一个标志位</strong>，一个对象在同一时间只能有一个线程获取到该对象的锁。如果锁已经被其他线程获取，那么当前线程就会进入到阻塞状态，直到它获取到了锁。</p></blockquote><h4 id="同步原理"><a href="#同步原理" class="headerlink" title="同步原理"></a>同步原理</h4><ul><li>当线程进入一个使用synchronized关键词修饰的方法或代码块时，它会尝试获取对象的锁。</li><li>如果对象的锁被其他线程持有，那么当前线程就会被阻塞，直到它获取到了锁。</li><li>当线程执行完了synchronized方法或代码块后，会释放对象锁，这样其他等待获取该锁的线程就有机会执行了。</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><p><strong>互斥性</strong></p><blockquote><p>synchronized 会起到互斥效果, 某个线程执行到某个对象的 synchronized 方法或代码块时, 其他线程如果也执行到同一个对象的 synchronized 方法或代码块，就会<strong>阻塞等待</strong><br>进入synchronized方法或代码块，相当于 加锁<br>退出synchronized方法或代码块，相当于 解锁</p></blockquote><p>看下图理解加锁过程：<br><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240514141516.jpeg"></p><blockquote><p><strong>阻塞等待：</strong><br>针对每一把锁（监视器锁），JVM内部都维护了一个等待队列，当这个锁被某个线程占有的时候，其他线程尝试获取这把锁，但由于锁已经被占用，这些线程就会进入阻塞状态，加入到该锁的等待队列中。直到持有锁的线程释放锁，JVM将从等待队列中唤醒一个或多个线 程，使其尝试再次获取锁。如果这些线程成功获取锁，它们将继续执行；否则，将继续阻塞等待。</p></blockquote></li><li><p><strong>刷新主存</strong></p><blockquote><p><strong>synchronized的工作过程：</strong><br>获得互斥锁<br>从主存拷贝最新的变量到工作内存<br>对变量执行操作<br>将修改后的共享变量的值刷新到主存<br>释放互斥锁</p></blockquote></li><li><p><strong>可重入性</strong></p><blockquote><p>synchronized是可重入锁<br>同一个线程可以多次获取同一个对象的锁，即允许线程对同一个锁进行嵌套调用【避免了死锁的发生】</p></blockquote><p>可重入锁内部会记录当前的锁被哪个线程占用，同时也会记录一个”加锁次数”，对于第一次加锁，记录当前获取锁的线程并且次数加一。但是后续该线程继续申请加锁的时候，并不会直接加锁，而是将记录的”加锁次数加1”，后续释放锁的时候，次数减1，直到次数为0才是真正的释放锁。</p><p>可重入锁的意义就是降低程序员负担（使用成本来提高开发效率），代价就是程序的开销增大（维护锁属于哪个线程，并且加减计数，降低了运行效率）</p></li><li><p><strong>内置了锁定和释放机制</strong></p><blockquote><p>synchronized关键字内置了锁定和释放机制，使用起来比较方便，不需要手动进行锁的管理</p></blockquote></li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><strong>性能问题</strong><br>虽然 synchronized 关键字能够保证线程安全，但是它的性能相对较差，因为在获取锁和释放锁的过程中会涉及到一定的系统开销。<br>如果是多个线程需要同时进行读操作，一个线程读操作时其他线程只有等待</li><li><strong>方法较少</strong><br>无法知道是否成功获取到锁，无法知道锁是否被其他线程持有。</li></ol><h4 id="synchronized实现线程同步的形式"><a href="#synchronized实现线程同步的形式" class="headerlink" title="synchronized实现线程同步的形式"></a>synchronized实现线程同步的形式</h4><table><thead><tr><th align="center">形式</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center"><code>实例同步方法</code></td><td align="center">锁的是<code>当前实例对象</code>，执行同步代码前必须获得<code>当前实例的锁</code>。这意味着，<strong>同一个类的不同实例对象之间不会互斥</strong>。</td></tr><tr><td align="center"><code>静态同步方法</code></td><td align="center">锁的是<code>当前类的Class对象</code>，执行同步代码前必须获得<code>当前类的Class对象的锁</code>。这意味着，<strong>无论有多少实例对象，它们共享同一把锁</strong>。</td></tr><tr><td align="center"><code>同步代码块</code></td><td align="center">锁的是<code>括号里的对象</code>，对给定对象加锁，执行同步代码块必须<code>获得给定对象的锁</code>。这提供了<strong>更灵活的锁定范围，允许更细粒度的控制</strong>。</td></tr></tbody></table><ul><li><strong>实例同步方法：</strong><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">  ...                                              <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">  ...                                     &lt;**&gt;              ... </span><br><span class="line">  &#125;                                                   &#125;</span><br><span class="line">&#125;                                                &#125;</span><br></pre></td></tr></table></figure></div></li><li><strong>静态同步方法：</strong><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;         <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">  ...                                                     <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">  ...                                            &lt;**&gt;                  ... </span><br><span class="line">  &#125;                                                         &#125;</span><br><span class="line">&#125;                                                        &#125;</span><br></pre></td></tr></table></figure></div></li><li><strong>同步代码块：</strong><br>需要显示指定对哪个对象加锁（Java中任意对象都可以作为锁对象）<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ul><p><strong>为什么要使用同步代码块？</strong></p><ul><li>在某些情况下，我们编写的方法体可能比较<strong>庞大</strong>，同时又有一些<strong>耗时的操作</strong>，如果对整个方法体进行同步，效率会大大降低。所以我们希望能够<strong>只同步必要的代码块</strong>，对于一些<strong>不需要同步的或者耗时较长的操作</strong>，放到同步代码块之外，比如：</li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Synchronized</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">running</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是耗时操作。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//需要同步的代码块写下面</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            running();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Synchronized</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Synchronized</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(sync).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(sync).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></div><p>运行结果：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这是耗时操作。</span><br><span class="line">这是耗时操作。</span><br><span class="line">这是耗时操作。</span><br><span class="line"><span class="number">1</span></span><br><span class="line">这是耗时操作。</span><br><span class="line">这是耗时操作。</span><br><span class="line">这是耗时操作。</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></div><p>结果表明，需要同步的代码块确实实现了<strong>同步</strong>。</p><h4 id="synchronized解决原子性问题"><a href="#synchronized解决原子性问题" class="headerlink" title="synchronized解决原子性问题"></a>synchronized解决原子性问题</h4><p>回到线程安全的原子性问题，为避免以上的问题发生，我们给 increase() 方法加上synchronized 关键字，使得<strong>两个线程无法同时调用increase() 方法</strong>，以保证++操作的三个步骤中的任何一步都不会被另外一个线程打断，这样，”i++”操作就永远不会因为线程切换而出错。<br>代码如下</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YuanziDeo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numThreads</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numIncrementsPerThread</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[numThreads];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; numThreads; j++) &#123;</span><br><span class="line">            threads[j] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                increase(numIncrementsPerThread);</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[j].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final value of i = &quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;Expected value = &quot;</span> + (numThreads * numIncrementsPerThread));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">(<span class="type">int</span> numIncrementsPerThread)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; numIncrementsPerThread; k++) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Final value <span class="type">of</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">200000</span></span><br><span class="line"><span class="type">Expected</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">200000</span></span><br></pre></td></tr></table></figure></div><blockquote><p>这里用到的是<strong>静态同步方法</strong>，线程1和线程2进入synchronized方法时，使用的是同一把锁。</p></blockquote><h4 id="synchronized需要注意的问题"><a href="#synchronized需要注意的问题" class="headerlink" title="synchronized需要注意的问题"></a>synchronized需要注意的问题</h4><p>请看以下代码</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Synchronized</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            running();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//用同一个类创建两个对象</span></span><br><span class="line">        <span class="type">Synchronized</span> <span class="variable">sync1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Synchronized</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(sync1).start();</span><br><span class="line">        <span class="type">Synchronized</span> <span class="variable">sync2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Synchronized</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(sync2).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">running</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入了synchronized修饰的实例同步方法 &quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 准备离开synchronized修饰的实例同步方法 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span> 进入了<span class="keyword">synchronized</span>修饰的实例同步方法 </span><br><span class="line">Thread-<span class="number">1</span> 进入了<span class="keyword">synchronized</span>修饰的实例同步方法 </span><br><span class="line">Thread-<span class="number">1</span> 准备离开<span class="keyword">synchronized</span>修饰的实例同步方法 </span><br><span class="line">Thread-<span class="number">0</span> 准备离开<span class="keyword">synchronized</span>修饰的实例同步方法 </span><br></pre></td></tr></table></figure></div><p><strong>为什么在Thread-0还没有离开synchronized修饰的实例同步方法时，Thread-1就进入synchronized修饰的实例同步方法呢？</strong></p><blockquote><p>这是因为synchronized修饰的<strong>实例同步方法</strong>锁的对象是<strong>this对象</strong>，而使用两个对象去访问，<strong>不是同一把锁</strong>。导致没有起到线程同步的效果。<br>如果我们用同一个对象访问：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只创建一个对象</span></span><br><span class="line"><span class="type">Synchronized</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Synchronized</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(sync).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(sync).start();</span><br></pre></td></tr></table></figure></div><p>结果就是<strong>同步</strong>的<br><strong>注：为了确保所有线程都能看到共享数据的最新值，因此所有执行读写操作的线程都必须在同一个锁上同步。</strong></p></blockquote><h3 id="7-3-Lock锁"><a href="#7-3-Lock锁" class="headerlink" title="7.3.Lock锁"></a>7.3.Lock锁</h3><p>前面使用的synchronized关键字可以实现多线程间的同步问题，其实，在JDK1.5后新增的<code>ReentrantLock</code>类同样可以实现这个功能，而且<strong>在用法上比synchronized关键字更灵活</strong>。</p><blockquote><p>ReentrantLock (重入锁)，是实现Lock接口的一个类。<br>ReentrantLock 支持两种锁：<strong>公平锁</strong>和<strong>非公平锁</strong>。【默认情况下（不传参），ReentrantLock 创建的是非公平锁】</p></blockquote><h4 id="ReentrantLock的源码分析"><a href="#ReentrantLock的源码分析" class="headerlink" title="ReentrantLock的源码分析"></a>ReentrantLock的源码分析</h4><h5 id="支持重入性"><a href="#支持重入性" class="headerlink" title="支持重入性"></a>支持重入性</h5><blockquote><p>要想支持重入性，就要解决两个问题：</p><ol><li>当一个线程尝试获取已经被它自己持有的锁时，应当允许它成功获取锁。这意味着锁的获取操作必须能够识别当前持有锁的线程，并允许该线程再次获取锁。</li><li>由于锁可能会被一个线程多次获取，因此锁的释放操作必须进行计数。只有当一个线程释放锁的次数与它获取锁的次数相等时，锁才算是真正被释放，从而允许其他线程获取该锁。</li></ol></blockquote><p>针对第一个问题，我们来看看 ReentrantLock 是怎样实现的，以非公平锁为例，判断当前线程能否获得锁为例，核心方法为内部类 Sync 的 nonfairTryAcquire 方法：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">//1. 如果该锁未被任何线程占有，该锁能被当前线程获取</span></span><br><span class="line">	<span class="keyword">if</span> (c ** <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//2.若被占有，检查占有线程是否是当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current ** getExclusiveOwnerThread()) &#123;</span><br><span class="line">		<span class="comment">// 3. 再次获取，计数加一</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这段代码的逻辑很简单，具体请看注释。为了支持重入性，在第二步增加了处理逻辑，如果该锁已经被线程占有了，会继续检查占有线程是否为当前线程，如果是的话，同步状态加 1 返回 true，表示可以再次获取成功。每次重新获取都会对同步状态进行加一的操作，那么释放的时候处理思路是怎样的呢？（依然还是以非公平锁为例）核心方法为 tryRelease：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">	<span class="comment">//1. 同步状态减1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c ** <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//2. 只有当同步状态为0时，锁成功被释放，返回true</span></span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 3. 锁未被完全释放，返回false</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>代码的逻辑请看注释，需要注意的是，重入锁的释放必须得等到同步状态为 0 时锁才算成功释放，否则锁仍未释放。如果锁被获取了 n 次，释放了 n-1 次，该锁未完全释放返回 false，只有被释放 n 次才算成功释放，返回 true。到现在我们可以理清 ReentrantLock 重入性的实现了，也就是理解了同步语义的第一条。</p><h5 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h5><blockquote><p>ReentrantLock 支持两种锁：<strong>公平锁</strong>和<strong>非公平锁</strong>。</p><ul><li><strong>公平锁</strong>：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</li><li><strong>非公平锁</strong>：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</li></ul></blockquote><ul><li>ReentrantLock 的构造方法<strong>无参</strong>时是构造非公平锁，源码为：<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li>ReentrantLock 的构造方法<strong>有参</strong>(boolean fair)时，true为公平锁，false为非公平锁，源码为：<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">  sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ul><p>在非公平锁获取时（nonfairTryAcquire 方法），只是简单的获取了一下当前状态然后做了一些逻辑处理，并没有考虑到当前同步队列中线程等待的情况。</p><p>我们来看看公平锁的处理逻辑是怎样的，核心方法为：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c ** <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current ** getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这段代码的逻辑与 nonfairTryAcquire 基本上一致，唯一的不同在于增加了 hasQueuedPredecessors 的逻辑判断，从方法名就可以知道该方法用来判断当前节点在同步队列中是否有前驱节点的，如果有前驱节点，说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败。如果当前节点没有前驱节点，才有做后面逻辑判断的必要性。</p><p><strong>公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁</strong></p><h4 id="ReentrantLock-的使用"><a href="#ReentrantLock-的使用" class="headerlink" title="ReentrantLock 的使用"></a>ReentrantLock 的使用</h4><p><strong>ReentrantLock基本用法：</strong></p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建锁对象</span></span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="comment">// 2.加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务代码</span></span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 3.释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p><strong>注意事项：</strong><br>在使用ReentrantLock时，必须手动加锁，手动释放锁。</p><ul><li>锁必须在try代码块开始之前获取，或者在try代码块的首行【加锁之前不能有异常抛出】。否则会导致以下两个问题：<ul><li>如果锁在try代码块里面，因为try代码中的异常导致加锁失败，还会执行finally释放锁的操作，进而引发 IllegalMonitorStateException 异常。</li><li>unlock 异常会覆盖 try 里面的业务异常，增加排查错误的难度。</li></ul></li><li>ReentrantLock 的锁必须在finally 中手动释放。【这确保了无论 try 块内的代码是否抛出异常，锁都会被释放，防止死锁】</li></ul></blockquote><p>错误❎示例：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxxLock</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 如果在此抛出异常，会直接执行 finally 块的代码，导致 lock.lock() 没有被执行</span></span><br><span class="line">    doSomething();</span><br><span class="line">    <span class="comment">// 不管锁是否成功，finally 块都会执行</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    doOthers();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div><p>正确✅示例：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxxLock</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">    doOthers();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="ReentrantLock解决原子性问题"><a href="#ReentrantLock解决原子性问题" class="headerlink" title="ReentrantLock解决原子性问题"></a>ReentrantLock解决原子性问题</h4><p>ReentrantLock 的使用方式与 synchronized 关键字类似，都是通过加锁和释放锁来实现同步的。我们来看看 ReentrantLock 的使用方式，以非公平锁为例：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20000</span></span><br></pre></td></tr></table></figure></div><p>可以看到，两个线程对 count 变量进行了 20000 次累加操作，说明 ReentrantLock 是支持原子性的。我们再来看看公平锁的使用方式，只需要将 ReentrantLock 的构造方法改为公平锁即可：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20000</span></span><br></pre></td></tr></table></figure></div><p>可以看到，公平锁的运行结果与非公平锁的运行结果一致，这是因为公平锁的实现方式与非公平锁的实现方式基本一致，只是在获取锁时增加了判断当前节点是否有前驱节点的逻辑判断。</p><h3 id="7-4-ReentrantLock-与-synchronized-的区别"><a href="#7-4-ReentrantLock-与-synchronized-的区别" class="headerlink" title="7.4.ReentrantLock 与 synchronized 的区别"></a>7.4.ReentrantLock 与 synchronized 的区别</h3><ol><li><p><strong>类 vs 关键字</strong>：</p><ul><li>ReentrantLock 是一个类，它提供了更多的灵活性和功能，如支持公平锁和非公平锁、可中断的获取锁、超时获取锁等。而 synchronized 是 Java 中的关键字，用于实现同步，其使用简单，但功能相对受限。</li></ul></li><li><p><strong>多路选择通知 vs 单路通知</strong>：</p><ul><li>ReentrantLock 可以与多个 Condition 对象一起使用，实现了多路选择通知，使得在某些情况下更灵活。而 synchronized 关键字只能通过 wait 和 notify&#x2F;notifyAll 方法唤醒一个线程或者全部线程，这是一种单路通知。</li></ul></li><li><p><strong>手动释放锁 vs 自动释放锁</strong>：</p><ul><li>在使用 ReentrantLock 时，需要手动调用 <code>unlock()</code> 方法来释放锁，通常在 <code>finally</code> 块中进行，以确保在发生异常时锁能够被正确释放。而 synchronized 关键字在同步块执行完毕后会自动释放锁，无需手动操作。</li></ul></li><li><p><strong>性能</strong>：</p><ul><li>在高并发的情况下，ReentrantLock 通常提供了更好的性能，特别是在竞争激烈的场景下。因为 ReentrantLock 具有更细粒度的控制能力，可以避免某些情况下的锁竞争和线程饥饿现象。但是，随着 JDK 版本的升级，synchronized 的性能已经得到了很大的改进，在某些情况下，性能差距已经不太明显。</li></ul></li></ol><p>总的来说，ReentrantLock 提供了更多的功能和灵活性，但也需要更多的注意和管理。而 synchronized 关键字虽然使用简单，但功能相对受限。在选择使用时，需要根据具体的需求和场景进行权衡和选择。</p><h3 id="7-5-原子类"><a href="#7-5-原子类" class="headerlink" title="7.5.原子类"></a>7.5.原子类</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>在Java的<code>java.util.concurrent</code>包中，除了提供底层锁，并发同步等工具类之外，还提供了一组原子操作类，大多以<code>Atomic</code>开头，它们位于<code>java.until.concurrent.atomic</code>包中。</p><blockquote><p>所谓原子操作类，就是这个操作要么全部执行成功，要么全部执行失败【<code>保证原子性</code>】，是保证并发编程安全的重要一环。<br>相比通过<code>synchronized</code>和<code>Lock</code>等方式实现的线程安全同步操作，原子类的实现机制则安全不同。它采用的是<strong>通过无锁（lock-free）的方式来实现线程安全访问，底层原理主要是基于<code>CAS</code>操作来实现</strong>。</p></blockquote><p>某些业务场景下，通过原子类来操作，即可实现线程安全的要求，又可以实现高效的并发性能，同时让编程方面更加简单。</p><h4 id="常用原子操作类"><a href="#常用原子操作类" class="headerlink" title="常用原子操作类"></a>常用原子操作类</h4><img lazyload src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240515192026.jpeg" alt="" width="100%" height="auto"> 虽然原子操作类很多，但是大体的用法基本类似，只是针对不同的数据类型进行了单独适配，这些原子类都可以保证多线程下数据的安全性，使用起来也比较简单。<h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><p>基本类型的原子类，也是最常用的原子操作类，分为以下三种基础类型：</p><ul><li><code>AtomicBoolean</code>：布尔类型的原子操作类</li><li><code>AtomicInteger</code>：整数类型的原子操作类</li><li><code>AtomicLong</code>：长整数类型的原子操作类</li></ul><p>以<code>AtomicInteger</code>为例，其基本用法如下：</p><table><thead><tr><th align="center">方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>int get()</code></td><td align="center">获取当前值</td></tr><tr><td align="center"><code>void set(int newValue)</code></td><td align="center">设置当前值为newValue</td></tr><tr><td align="center"><code>int getAndIncrement()</code></td><td align="center">获取当前值，并自增1（先获取再自增）</td></tr><tr><td align="center"><code>int getAndDecrement()</code></td><td align="center">获取当前值，并自减1（先获取再自减）</td></tr><tr><td align="center"><code>int incrementAndGet()</code></td><td align="center">自增1，并获取当前值（先自增再获取）</td></tr><tr><td align="center"><code>int decrementAndGet()</code></td><td align="center">自减1，并获取当前值（先自减再获取）</td></tr><tr><td align="center"><code>int getAndAdd(int delta)</code></td><td align="center">获取当前值，并增加delta（先获取再增加）</td></tr><tr><td align="center"><code>int addAndGet(int delta)</code></td><td align="center">增加delta，并获取当前值（先增加再获取）</td></tr><tr><td align="center"><code>int getAndSet(int newValue)</code></td><td align="center">获取当前值，并设置当前值为newValue</td></tr><tr><td align="center"><code>boolean compareAndSet(int expect, int update)</code></td><td align="center">如果当前值等于expect，则设置当前值为update，并返回true，否则返回false。 直接使用CAS方法【核心方法】</td></tr></tbody></table><p>代码示例：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">      <span class="comment">// 先获取值，再自增，默认初始值为0</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> atomicInteger.getAndIncrement();</span><br><span class="line">      System.out.println(<span class="string">&quot;v1：&quot;</span>+v1);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取自增后的ID值</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">v2</span> <span class="operator">=</span> atomicInteger.incrementAndGet();</span><br><span class="line">      System.out.println(<span class="string">&quot;v2：&quot;</span>+v2);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取自减后的ID值</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">v3</span> <span class="operator">=</span> atomicInteger.decrementAndGet();</span><br><span class="line">      System.out.println(<span class="string">&quot;v3：&quot;</span>+v3);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使用CAS方式，将就旧值更新成 10</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">v4</span> <span class="operator">=</span> atomicInteger.compareAndSet(v3, <span class="number">10</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;v4：&quot;</span>+v4);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使用CAS方式，更新失败的情况</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">v5</span> <span class="operator">=</span> atomicInteger.compareAndSet(v3, <span class="number">30</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;v5: &quot;</span>+v5);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 先增加再获取</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">v6</span> <span class="operator">=</span> atomicInteger.addAndGet(-<span class="number">5</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;v6: &quot;</span>+v6);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取最新值</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">v7</span> <span class="operator">=</span> atomicInteger.get();</span><br><span class="line">      System.out.println(<span class="string">&quot;v6：&quot;</span>+v7);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v1：<span class="number">0</span></span><br><span class="line">v2：<span class="number">2</span></span><br><span class="line">v3：<span class="number">1</span></span><br><span class="line">v4：<span class="literal">true</span></span><br><span class="line">v5: <span class="literal">false</span></span><br><span class="line">v6: <span class="number">5</span></span><br><span class="line">v6：<span class="number">5</span></span><br></pre></td></tr></table></figure></div><h6 id="原子操作解决原子性问题"><a href="#原子操作解决原子性问题" class="headerlink" title="原子操作解决原子性问题"></a>原子操作解决原子性问题</h6><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个原子操作类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threads</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threads);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    <span class="comment">// 采用原子性操作累加</span></span><br><span class="line">                    a.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞等待10个线程执行完毕</span></span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    <span class="comment">// 输出结果值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;结果值：&quot;</span> + a.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果值：<span class="number">10000</span></span><br></pre></td></tr></table></figure></div><p>从结果可见，原子操作类也可以实现线程安全。关于底层实现原理是CAS操作，这里不再赘述。</p><p>与<code>synchronized</code>和<code>Lock</code>等实现方式相比，原子操作类因为采用无锁的方式实现，因此在某些场景下可以带来更高的执行效率。</p><h5 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h5><p>数组类型的原子操作类，<strong>并不是指对数组本身的原子操作，而是对数组中的元素进行原子性操作</strong>，这一点需要特别注意，如果要针对整个数组进行更新，可以采用对象引入数据类型的原子操作类进行处理。JDK提供了以下三个数组类型的原子类：</p><ul><li><code>AtomicIntegerArray</code>：整型数组类型的原子操作类</li><li><code>AtomicLongArray</code>：长整型数组类型的原子操作类</li><li><code>AtomicReferenceArray &lt;T&gt;</code>：引用类型数组类型的原子操作类</li></ul><p>相比与基本类型中的<code>AtomicInteger</code>，方法大致相同，每个方法都增加了一个参数 <code>int i</code>【第一个参数】，表示操作的数组下标。<br>以<code>AmoticIntegerArray</code>为例，其基本用法如下：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span>[] value = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">AtomicIntegerArray</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(value);</span><br><span class="line">    <span class="comment">// 将下标为[0]的元素，原子性操作加1</span></span><br><span class="line">    array.getAndIncrement(<span class="number">0</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;下标为[0]的元素，更新后的值：&quot;</span> + array.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下标为[<span class="number">0</span>]的元素，更新后的值：<span class="number">1</span></span><br></pre></td></tr></table></figure></div><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>上文提到的基本类型只能更新一个变量，如果需要原子性更新多个变量，这个时候可以采用对象引用类型的原子操作类，将多个变量封装到一个对象中。JDK同样提供了以下三种引用类型原子类：</p><ul><li><code>AtomicReference &lt;T&gt;</code>：引用类型原子操作类</li><li><code>AtomicStampedReference &lt;T&gt;</code>：带有版本号的引用类型原子操作类,可以解决ABA问题（即变量从A变成B再变成A的问题，导致无法检测到中间的变化）</li><li><code>AtomicMarkableReference &lt;T&gt;</code>：带有标记位的引用类型原子操作类，可以用于标记对象的某种状态（如是否已处理）</li></ul><p>具体方法</p><ul><li>引用类型<ul><li>AtomicReference<t><ul><li>T get()：获取当前引用的值。</li><li>void set(T newValue)：设置当前引用的值为newValue。</li><li>T getAndSet(T newValue)：获取当前引用的值，并设置当前引用的值为newValue。</li><li>boolean compareAndSet(T expect, T update)：如果当前引用的值等于expect，则设置当前引用的值为update，并返回true，否则返回false。</li></ul></t></li><li>AtomicStampedReference<t><ul><li>T getReference()：获取当前引用的值。</li><li>int getStamp()：获取当前引用的版本号。</li><li>boolean compareAndSet(T expectReference, T updateReference, int expectStamp, int updateStamp)：如果当前引用的值等于expectReference，并且当前引用的版本号等于expectStamp，则设置当前引用的值为updateReference，版本号为updateStamp，并返回true，否则返回false。</li><li>void set(T newReference, int newStamp)：设置当前引用的值为newReference，版本号为newStamp。</li></ul></t></li><li>AtomicMarkableReference<t><ul><li>T getReference()：获取当前引用的值。</li><li>boolean isMarked()：获取当前引用的标记位的值。</li><li>boolean compareAndSet(T expectReference, T updateReference, boolean expectMark, boolean updateMark)：如果当前引用的值等于expectReference，并且当前引用的标记位的值等于expectMark，则设置当前引用的值为updateReference，标记位的值为updateMark，并返回true，否则返回false。</li><li>void set(T newReference, boolean newMark)：设置当前引用的值为newReference，标记位的值为newMark。</li></ul></t></li></ul></li></ul><p>以<code>AtomicReference</code>为例，其基本用法如下：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置初始值</span></span><br><span class="line">      AtomicReference&lt;User&gt; atomicUser = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">      <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>);</span><br><span class="line">      atomicUser.set(user1);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 采用CAS方式，将user1更新成user2</span></span><br><span class="line">      <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">24</span>);</span><br><span class="line">      atomicUser.compareAndSet(user1,user2);</span><br><span class="line">      System.out.println(<span class="string">&quot;更新后的对象：&quot;</span> + atomicUser.get().toString());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span>  <span class="title class_">User</span>&#123;</span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.name = name;</span><br><span class="line">         <span class="built_in">this</span>.age = age;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;User&#123;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">更新后的对象：User&#123;name = 李四, age = <span class="number">24</span>&#125;</span><br></pre></td></tr></table></figure></div><h5 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h5><p>某种场景下，可能你只想要原子性更新对象中的某个属性值，此时可以采用字段类型的原子操作类。JKD为我们提供了以下三种字段类型的原子类：</p><ul><li><code>AtomicIntegerFieldUpdater &lt;T&gt;</code>：原子更新整型字段</li><li><code>AtomicLongFieldUpdater &lt;T&gt;</code>：原子更新长整型字段</li><li><code>AtomicReferenceFieldUpdater &lt;T&gt;</code>：原子更新引用类型字段</li></ul><div class="note-large default"><div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center"><i class="notel-icon fa-solid fa-info"></i><p>字段类型</p></div><div class="notel-content"><ul><li>AtomicIntegerFieldUpdater<t><ul><li>AtomicIntegerFieldUpdater<v>newUpdater(Class<t>tclass, String fieldName)：创建并返回一个能够原子性更新指定类中指定 int 字段的更新器【静态方法】</t></v></li><li>int get(T obj)：获取指定对象中字段的当前值。</li><li>void set(T obj, int newValue)：将指定对象中字段的值设置为 newValue。</li><li>boolean compareAndSet(T obj, int expect, int update)：如果 obj 中字段的当前值等于 expect，则将其更新为 update，并返回 true，否则返回 false。</li></ul></t></li><li>AtomicLongFileUpdate<t><ul><li>AtomicLongFiledUpdate<t>newUpdate(Class<t>clazz, String fieldName):创建并返回一个能够原子性更新指定类中指定 long 字段的更新器【静态方法】</t></t></li><li>long get(T obj)：获取指定对象中的当前值</li><li>void set(T obj, long newValue)：将指定对象中字段的值设置为 newValue。</li><li>boolean compareAndSet(T obj, long expect, long update)：如果 obj 中字段的当前值等于 expect，则将其更新为 update，并返回 true，否则返回 false。</li></ul></t></li><li>AtomicReferenceFiledUpdater&lt;T, V&gt;<ul><li>AtomicReferenceFieldUpdater&lt;T, V&gt; newUpdater(Class<t>tclass, Class<v>vclass, String fieldName)：创建并返回一个能够原子性更新指定类中指定引用类型字段的更新器【静态方法】</v></t></li><li>V get(T obj)：获取指定对象中字段的当前值</li><li>void set(T obj, V newValue)：将指定对象中字段的值设置为 newValue</li><li>boolean compareAndSet(T obj, V expect, V update)：如果 obj 中字段的当前值等于 expect，则将其更新为 update，并返回 true，否则返回 false。</li></ul></li></ul></div></div><blockquote><p>需要注意的是：<strong>这些字段类型的原子类需要满足以下条件才可以使用</strong></p><ul><li>被操作的字段不能是 static 类型</li><li>被操作的字段不能是 final 类型</li><li>被操作的字段必须被声明为 volatile 类型</li><li>属性必须对于当前的 Updater 对象可见，简单的说就是尽量使用 public 修饰字段</li></ul></blockquote><p>以<code>AtomicIntegerFieldUpdater</code>为例，构造一个整数类型的属性引用，具体用法如下：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置初始值</span></span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>);</span><br><span class="line">      AtomicIntegerFieldUpdater&lt;User&gt; updater = AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">      <span class="comment">// 将 age 的年龄原子性操作加1</span></span><br><span class="line">      updater.getAndIncrement(user);</span><br><span class="line">      System.out.println(<span class="string">&quot;更新后的属性值：&quot;</span> + updater.get(user));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span>  <span class="title class_">User</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line">      <span class="comment">// age 要用 public、volatile 修饰</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.name = name;</span><br><span class="line">         <span class="built_in">this</span>.age = age;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果:</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">更新后的属性值：<span class="number">24</span></span><br></pre></td></tr></table></figure></div><h5 id="累加器类型"><a href="#累加器类型" class="headerlink" title="累加器类型"></a>累加器类型</h5><p>累加器类型的原子操作类，是从JDK1.8开始加入的，专门用来执行数值类型的数据累加操作，性能更好。</p><blockquote><p>它的实现原理与基本数据类型的原子类略有不同，当多线程竞争时采用分段累加的思路来实现目标值，在多线程环境中，它比基本数据类型的原子类性能要高出不少，特别是写多的场景。</p></blockquote><p>JDK为我们提供了以下四种累加器类型的原子类：</p><ul><li><code>LongAdder</code>：用于累加long类型数据</li><li><code>DoubleAdder</code>：用于累加double类型数据</li><li><code>LongAccumulator</code>：用于累加long类型数据，并且可以自定义函数操作</li><li><code>DoubleAccumulator</code>：用于累加double类型数据，并且可以自定义函数操作</li></ul><p>以<code>LongAdder</code>为例，具体用法如下：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">LongAdder</span> <span class="variable">adder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">  <span class="comment">// 自增加 1，默认初始值为0</span></span><br><span class="line">  adder.increment();</span><br><span class="line">  adder.increment();</span><br><span class="line">  adder.increment();</span><br><span class="line">  System.out.println(<span class="string">&quot;最新值：&quot;</span> +  adder.longValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最新值：<span class="number">3</span></span><br></pre></td></tr></table></figure></div><h4 id="原子操作的底层原理"><a href="#原子操作的底层原理" class="headerlink" title="原子操作的底层原理"></a>原子操作的底层原理</h4><p>这里不详细介绍其原理，如果你对ThreadLocal类的原理感兴趣，可以先参考：<a class="link" target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/101430930">CAS机制详解<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><h2 id="8-线程的通信"><a href="#8-线程的通信" class="headerlink" title="8.线程的通信"></a>8.线程的通信</h2><blockquote><p>线程通信是指多个线程之间共享信息或数据，以协调它们的执行。这在并发编程中非常重要，因为需要确保线程之间的正确协作，以避免竞态条件、死锁等问题。</p></blockquote><h3 id="8-1-volatile可见性"><a href="#8-1-volatile可见性" class="headerlink" title="8.1.volatile可见性"></a>8.1.volatile可见性</h3><p>同上，可以解决线程的可见性和有序性问题，但不能保证操作的原子性。</p><h3 id="8-2-锁与同步"><a href="#8-2-锁与同步" class="headerlink" title="8.2.锁与同步"></a>8.2.锁与同步</h3><p>同上，通过<code>synchronized</code>关键字和<code>Lock</code>锁保证多个线程正确访问共享数据。</p><h3 id="8-3-等待-通知机制"><a href="#8-3-等待-通知机制" class="headerlink" title="8.3.等待&#x2F;通知机制"></a>8.3.等待&#x2F;通知机制</h3><p>上面一种是基于”锁”的方式，线程需要不断地去尝试获得锁，如果失败了，再继续尝试。这可能会消耗服务器资源。<br>而基于对象的等待&#x2F;通知机制是一种更加轻量化的方式，它允许一个或多个线程在满足特定条件下进入等待状态，而在其他线程完成某个操作后通过发送通知的方式唤醒这些等待中的线程。这一机制主要依赖<code>java.lang.Object</code>类提供的<code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>方法来实现。</p><ul><li><code>wait()</code>：当前线程调用该方法时，会释放当前线程所持有的锁，并进入等待状态，直到其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法唤醒当前线程。</li><li><code>notify()</code>：随机唤醒一个正在等待该对象监视器的线程。</li><li><code>notifyAll()</code>：唤醒所有正在等待该对象监视器的线程。<blockquote><p><strong>注意</strong>：<br>在使用等待&#x2F;通知机制时，必须确保在<code>synchronized</code>修饰的方法或代码块内调用这些方法，因为只有持有对象锁的线程才可以执行它们，否则会抛出<code>IllegalMonitorStateException</code>异常。<br>此外，在调用<code>wait()</code>方法后，线程在被唤醒后需要重新获得锁才能继续执行。<br><strong>此外</strong>：<br>Lock接口的实现类<code>ReentrantLock</code>也提供了类似的机制。通过实现<code>Condition</code>接口，也可以实现等待&#x2F;唤醒机制，相比于synchronized使用Object类的三个方法来实现线程的阻塞和运行两个状态的切换，ReentrantLock使用Condition阻塞队列的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>三个方法来实现线程阻塞和运行两个状态的切换，进而实现线程间的通信。这些方法的使用和synchronized的使用类型，不再赘述。<br><strong>经典范式(生产者-消费者)</strong>：</p></blockquote></li></ul><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">available</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="type">int</span> value)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (available) &#123;</span><br><span class="line">            wait();  <span class="comment">// 如果数据可用，等待消费者消费</span></span><br><span class="line">        &#125;</span><br><span class="line">        data = value;</span><br><span class="line">        System.out.println(<span class="string">&quot;Produced: &quot;</span> + data);</span><br><span class="line">        available = <span class="literal">true</span>;</span><br><span class="line">        notify();  <span class="comment">// 通知消费者可以消费数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (!available) &#123;</span><br><span class="line">            wait();  <span class="comment">// 如果数据不可用，等待生产者生产</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumed: &quot;</span> + data);</span><br><span class="line">        available = <span class="literal">false</span>;</span><br><span class="line">        notify();  <span class="comment">// 通知生产者可以生产数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SharedResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedResource</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    resource.produce(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    resource.consume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Produced: <span class="number">1</span></span><br><span class="line">Consumed: <span class="number">1</span></span><br><span class="line">Produced: <span class="number">2</span></span><br><span class="line">Consumed: <span class="number">2</span></span><br><span class="line">Produced: <span class="number">3</span></span><br><span class="line">Consumed: <span class="number">3</span></span><br></pre></td></tr></table></figure></div><p>在这个示例中：</p><ul><li>生产者线程生成数据并调用produce()方法。produce()方法在数据可用时等待，并在生成新数据后通知消费者。</li><li>消费者线程消费数据并调用consume()方法。consume()方法在数据不可用时等待，并在消费数据后通知生产者。</li></ul><h3 id="8-4-join方法"><a href="#8-4-join方法" class="headerlink" title="8.4.join方法"></a>8.4.join方法</h3><p><code>join( )</code>方法是Java中<code>Thread</code>类的一个关键实例方法，用于同步线程执行。当一个线程调用另一个线程的<code>join( )</code>方法时，当前线程将进入等待状态，直到被调用<code>join( )</code>的线程完成其任务并结束。这在需要确保主线程等待子线程执行完毕之后再继续执行的场景中非常有用。【若在join方法中传入了参数，则是等待调用join()方法的线程执行完毕，或者直到指定的毫秒数之后】</p><p>例如，假设主线程创建了一个耗时计算的任务交给子线程执行，并且主线程希望在子线程完成计算后获取结果：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinExample</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LongRunningTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是子线程，开始执行耗时计算...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> performComputation(); <span class="comment">// 执行计算</span></span><br><span class="line">                System.out.println(<span class="string">&quot;我是子线程，计算完成，结果为: &quot;</span> + result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">performComputation</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span>; <span class="comment">// 示例计算结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">longRunning</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">LongRunningTask</span>());</span><br><span class="line">        longRunning.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程等待子线程完成</span></span><br><span class="line">        longRunning.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子线程结束后，主线程可以安全地访问子线程的结果（此处假设已通过共享变量或其他机制传递）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：子线程已完成，我可以继续执行后续操作了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="8-5-ThreadLocal类"><a href="#8-5-ThreadLocal类" class="headerlink" title="8.5.ThreadLocal类"></a>8.5.ThreadLocal类</h3><p><code>ThreadLocal</code>是一个用于创建线程本地变量的工具类。它通过维护一个内部弱引用的Map来管理每个线程的本地变量。这里不详细介绍其原理，如果你对<code>ThreadLocal</code>类的原理感兴趣，可以先参考：<a class="link" target="_blank" rel="noopener" href="https://yasinshaw.com/articles?keyword=threadlocal">ThreadLocal类原理<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p><p>一些朋友称<code>ThreadLocal</code>为线程本地变量或线程本地存储。严格来说，<code>ThreadLocal</code>类并不用于多线程间的通信，而是<strong>确保每个线程都有自己”独立”的变量，线程之间互不干扰</strong>。<code>ThreadLocal</code>为每个线程创建一个变量副本，每个线程可以访问自己内部的副本变量。</p><p><code>ThreadLocal</code>类最常用的方法是<code>set</code>方法和<code>get</code>方法。以下是一个示例代码：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个ThreadLocal变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocalValue = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并启动两个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    threadLocalValue.set(threadLocalValue.get() + <span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + threadLocalValue.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                threadLocalValue.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    threadLocalValue.set(threadLocalValue.get() + <span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + threadLocalValue.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                threadLocalValue.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">1</span>: <span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span>: <span class="number">4</span></span><br><span class="line">Thread-<span class="number">0</span>: <span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>: <span class="number">6</span></span><br><span class="line">Thread-<span class="number">1</span>: <span class="number">8</span></span><br><span class="line">Thread-<span class="number">1</span>: <span class="number">10</span></span><br><span class="line">Thread-<span class="number">0</span>: <span class="number">2</span></span><br><span class="line">Thread-<span class="number">0</span>: <span class="number">3</span></span><br><span class="line">Thread-<span class="number">0</span>: <span class="number">4</span></span><br><span class="line">Thread-<span class="number">0</span>: <span class="number">5</span></span><br></pre></td></tr></table></figure></div><blockquote><p><strong>注意事项</strong>:</p><ul><li><strong>独立副本</strong>：每个线程都有自己独立的副本变量，线程之间互不干扰。</li><li><strong>内存泄漏</strong>：由于<code>ThreadLocal</code>使用的是弱引用，未及时清理的线程副本变量可能会导致内存泄漏，因此在使用完<code>ThreadLocal</code>变量后，建议调用其<code>remove()</code>方法清理数据。</li></ul></blockquote><h3 id="8-6-管道通信"><a href="#8-6-管道通信" class="headerlink" title="8.6.管道通信"></a>8.6.管道通信</h3><p>Java中的管道通信是通过管道输入流和管道输出流来实现的。<strong>这种通信方式主要用于两个线程之间传递数据，管道的一端连接输入流，另一端连接输出流</strong>。JDK提供了<code>PipedInputStream</code>、<code>PipedOutputStream</code>、<code>PipedReader</code>、<code>PipedWriter</code>，前两者实现字节流的管道通信，后两者实现字符流的管道通信。</p><p>管道通信的输入流和输出流通过<code>connect()</code>进行连接，如果没有将输入流和输出流绑定起来，对于该流的访问将会抛出异常【输入流调用方法连接输出流 或者 输出流调用方法连接输入流 任选其一即可】<br><strong>一个输出流可以绑定到多个输入流，但是一个输入流不能绑定到多个输出流。</strong></p><p><strong>应用场景</strong>：<br>管道通信的使用多半和I&#x2F;O流有关，当我们一个线程需要先获取另一个线程发送的数据（字符串或文件等），就需要使用管道通信了。</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的示例代码使用的是基于字符的：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pipe</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReaderThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> PipedReader reader;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ReaderThread</span><span class="params">(PipedReader reader)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.reader = reader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;this is reader&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">receive</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((receive = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.print((<span class="type">char</span>)receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriterThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> PipedWriter writer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">WriterThread</span><span class="params">(PipedWriter writer)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.writer = writer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;this is writer&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">receive</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.write(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">PipedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedWriter</span>();</span><br><span class="line">        <span class="type">PipedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedReader</span>();</span><br><span class="line">        writer.connect(reader); <span class="comment">// 这里注意一定要连接，才能通信</span></span><br><span class="line">        <span class="comment">//reader.connect(writer);</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ReaderThread</span>(reader)).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">WriterThread</span>(writer)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span> is reader</span><br><span class="line"><span class="built_in">this</span> is writer</span><br><span class="line">test</span><br></pre></td></tr></table></figure></div></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>Title:</strong> Java 多线程</li><li><strong>Author:</strong> Lu</li><li><strong>Created at :</strong> 2024-05-30 09:36:01</li><li><strong>Updated at :</strong> 2025-03-10 13:30:10</li><li><strong>Link:</strong> https://lusy.ink/2024/05/30/多线程/</li><li><strong>License: </strong>This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">#学习总结</a>&nbsp;</li><li class="tag-item mx-0.5"><a href="/tags/Java/">#Java</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/2024/06/01/JavaWeb/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item">Java IO流</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/2024/05/21/MySQL%E5%9F%BA%E7%A1%80/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">MySQL基础</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div><div class="comment-container px-2 sm:px-6 md:px-8 pb-8"><div class="comments-container mt-10 w-full"><div id="comment-anchor" class="w-full h-2.5"></div><div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">Comments</div><div id="waline"></div><script type="module" data-swup-reload-script>import{init}from"/js/libs/waline.mjs";function loadWaline(){init({el:"#waline",serverURL:"https://comment.lusy.ink",lang:"zh-CN",dark:'body[class~="dark-mode"]',reaction:!1,requiredMeta:["nick","mail"],emoji:[]})}"undefined"!=typeof swup?loadWaline():window.addEventListener("DOMContentLoaded",loadWaline)</script></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">On this page</div><div class="page-title">Java 多线程</div><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">Java 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1. 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="nav-text">1.1.程序、进程、线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-text">1.2.并行与并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-CPU%E5%8D%95%E6%A0%B8%E5%92%8C%E5%A4%9A%E6%A0%B8%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">1.3.CPU单核和多核的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-text">1.4.用户线程与守护线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-text">1.5.多线程的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">1.6.应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">2. 线程的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%9B%BE"><span class="nav-text">2.1.线程的状态图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E"><span class="nav-text">2.2.线程状态详细说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%EF%BC%88New%EF%BC%89"><span class="nav-text">新建（New）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%BF%90%E8%A1%8C%EF%BC%88Runnable%EF%BC%89"><span class="nav-text">可运行（Runnable）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%EF%BC%88Blocked%EF%BC%89"><span class="nav-text">阻塞（Blocked）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%EF%BC%88Waiting%EF%BC%89"><span class="nav-text">等待（Waiting）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E7%AD%89%E5%BE%85%EF%BC%88TIME-WAITING%EF%BC%89"><span class="nav-text">超时等待（TIME_WAITING）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E4%BA%A1%EF%BC%88Dead%EF%BC%89"><span class="nav-text">死亡（Dead）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8F%8A%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-text">2.3.状态之间的转换及调用方法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-text">2.4.几个方法的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Thread%E7%B1%BB"><span class="nav-text">3.Thread类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">3.1.基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Thread%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">3.2.Thread的构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Thread%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">3.3.Thread的常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#yield"><span class="nav-text">yield()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#join"><span class="nav-text">join()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sleep"><span class="nav-text">sleep()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#interrupt"><span class="nav-text">interrupt()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">3.4.优先级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="nav-text">4.线程的调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-CPU%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="nav-text">4.1.CPU的调度策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Java%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">4.2.Java的调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%9B%E5%BB%BA"><span class="nav-text">5.多线程的实现原理和创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">5.1.多线程的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">5.2.多线程的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB-%E6%8B%93%E5%B1%95%E6%80%A7%E8%BE%83%E5%B7%AE"><span class="nav-text">5.2.1.继承Thread类[拓展性较差]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3-%E6%8B%93%E5%B1%95%E6%80%A7%E5%BC%BA"><span class="nav-text">5.2.2.实现Runnable接口[拓展性强]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-4-%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3-%E5%8F%AF%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">5.2.4.实现Callable接口[可有返回值]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-5-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">5.2.5.线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-5-1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">5.2.5.1.线程池的体系结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-5-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-text">5.2.5.2.线程池的创建方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-5-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">5.2.5.3.线程池提交任务的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-5-4-%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">5.2.5.4.关闭线程池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-5-5-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%9B%91%E6%8E%A7"><span class="nav-text">5.2.5.5.线程池的监控</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-5-6-%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-text">5.2.5.6.如何合理配置线程池的参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-5-7-%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="nav-text">5.2.5.7.代码演示</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-text">6.线程的安全问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-text">6.1.前置知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">6.2.基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-text">6.3.线程的不安全的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-text">6.3.1.原子性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2-%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-text">6.3.2.可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-3-%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="nav-text">6.3.3.有序性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-4-%E6%B4%BB%E8%B7%83%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-text">6.3.4.活跃性问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="nav-text">7.线程的同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">7.1.volatile关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-text">volatile解决可见性问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-text">volatile关键字的缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-synchronized%E9%94%81"><span class="nav-text">7.2.synchronized锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="nav-text">同步原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="nav-text">synchronized实现线程同步的形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-text">synchronized解决原子性问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">synchronized需要注意的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-Lock%E9%94%81"><span class="nav-text">7.3.Lock锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">ReentrantLock的源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E9%87%8D%E5%85%A5%E6%80%A7"><span class="nav-text">支持重入性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-text">公平锁和非公平锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">ReentrantLock 的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-text">ReentrantLock解决原子性问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-ReentrantLock-%E4%B8%8E-synchronized-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">7.4.ReentrantLock 与 synchronized 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-text">7.5.原子类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB"><span class="nav-text">常用原子操作类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-text">基本类型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-text">原子操作解决原子性问题</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">数组类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-text">引用类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="nav-text">字段类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%AF%E5%8A%A0%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="nav-text">累加器类型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">原子操作的底层原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-text">8.线程的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-volatile%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-text">8.1.volatile可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-%E9%94%81%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="nav-text">8.2.锁与同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="nav-text">8.3.等待&#x2F;通知机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-join%E6%96%B9%E6%B3%95"><span class="nav-text">8.4.join方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-ThreadLocal%E7%B1%BB"><span class="nav-text">8.5.ThreadLocal类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="nav-text">8.6.管道通信</span></a></li></ol></li></ol></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2024</span> - 2025&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">Lu</a><p class="post-count space-x-0.5"><span>25 posts in total </span><span>175.2k words in total</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">VISITOR COUNT</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">TOTAL PAGE VIEWS</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span> <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span></div><div>Blog up for <span class="odometer" id="runtime_days"></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Swup.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupSlideTheme.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScriptsPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupProgressPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupScrollPlugin.min.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/imageViewer.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/utils.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/main.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/navbarShrink.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/scrollTopBottom.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/lightDarkSwitch.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/categoryList.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/localSearch.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/codeBlock.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/lazyload.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/runtime.js"></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/odometer.min.js"></script><link rel="stylesheet" href="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/assets/odometer-theme-minimal.css"><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/Typed.min.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/typed.js"></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/plugins/tabs.js" data-swup-reload-script></script><script src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script><script type="module" src="https://registry.npmmirror.com/hexo-theme-redefine/2.8.2/files/source/js/build/layouts/essays.js" data-swup-reload-script></script></body></html>