<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java IO流</title>
    <url>/2024/05/01/Java-IO%E6%B5%81/</url>
    <content><![CDATA[<h2 id="Java-IO流"><a href="#Java-IO流" class="headerlink" title="Java IO流"></a>Java IO流</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><ul>
<li>IO 即 Input&#x2F;Output，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。</li>
<li>IO流在Java中分为<code>输入流</code>和<code>输出流</code>，而根据数据的处理方式又分为<code>字节流</code>和<code>字符流</code>。<br>Java IO流的40多个类都是从如下4个抽象类基类中派生出来的：<ul>
<li><code>InputStream/Reader</code>：所有输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li><code>OutputStream/Writer</code>：所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：</p>
<ul>
<li>字节流可以处理所有类型的数据，包括文本和二进制，而字符流更适合处理文本数据。</li>
<li>字节流在处理文本数据时需要考虑字符编码的问题，而字符流会根据指定的字符编码进行正确解析，因此更适合处理中文文本。</li>
</ul>
</blockquote>
<p><strong>关系类图</strong></p>
<ul>
<li><strong>InputStream</strong> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240505131542.png"
                     
                ></li>
<li><strong>OutputStream</strong> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240505131750.png"
                     
                ></li>
<li><strong>Reader</strong> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240505132056.png"
                     
                ></li>
<li><strong>Writer</strong> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240505132130.png"
                     
                ></li>
</ul>
<h3 id="2-字节流"><a href="#2-字节流" class="headerlink" title="2. 字节流"></a>2. 字节流</h3><h4 id="2-1-InputStream-字节输入流"><a href="#2-1-InputStream-字节输入流" class="headerlink" title="2.1 InputStream(字节输入流)"></a>2.1 InputStream(字节输入流)</h4><h5 id="2-1-1-概述"><a href="#2-1-1-概述" class="headerlink" title="2.1.1 概述"></a>2.1.1 概述</h5><p><code>InputStream</code> 用于从源头（通常是文件）读取数据（字节信息）到内存中，java.io.InputStream 抽象类是所有字节输入流的父类。</p>
<h5 id="2-1-2-常用方法"><a href="#2-1-2-常用方法" class="headerlink" title="2.1.2 常用方法"></a>2.1.2 常用方法</h5><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>read()</code></td>
<td>返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 -1 ，表示文件结束。</td>
</tr>
<tr>
<td><code>read(byte b[ ])</code></td>
<td>从输入流中读取一些字节存储到数组 b 中。如果数组 b 的长度为零，则不读取。如果没有可用字节读取，返回 -1。如果有可用字节读取，则最多读取的字节数最多等于 b.length ， 返回读取的字节数。这个方法等价于 read(b, 0, b.length)。</td>
</tr>
<tr>
<td><code>read(byte b[], int off, int len)</code></td>
<td>在read(byte b[ ]) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字节数）。</td>
</tr>
<tr>
<td><code>skip(long n)</code></td>
<td>忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</td>
</tr>
<tr>
<td><code>available()</code></td>
<td>返回输入流中可以读取的字节数</td>
</tr>
<tr>
<td><code>close()</code></td>
<td>关闭输入流释放相关的系统资源。</td>
</tr>
<tr>
<td>从 Java 9 开始，InputStream 新增加了多个实用的方法:</td>
<td></td>
</tr>
<tr>
<td><code>readAllBytes()</code></td>
<td>读取输入流中的所有字节，返回字节数组。</td>
</tr>
<tr>
<td><code>readNBytes(byte[] b, int off, int len)</code></td>
<td>阻塞直到读取 len 个字节。</td>
</tr>
<tr>
<td><code>transferTo(OutputStream out)</code></td>
<td>将所有字节从一个输入流传递到一个输出流。</td>
</tr>
</tbody></table>
<h5 id="2-1-3-实现类"><a href="#2-1-3-实现类" class="headerlink" title="2.1.3 实现类"></a>2.1.3 实现类</h5><ul>
<li><strong>FileInputStream</strong> <ul>
<li>FileInputStream 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Number of remaining bytes:&quot;</span>+fis.available());</span><br><span class="line">    <span class="type">int</span> content;</span><br><span class="line">    <span class="type">long</span> <span class="variable">skip</span> <span class="operator">=</span> fis.skip(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;The actual number of skipped bytes:&quot;</span>+skip);</span><br><span class="line">    System.out.println(<span class="string">&quot;The content read from file：&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((content = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) content);</span><br><span class="line">    &#125;</span><br><span class="line">    fis.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* input.txt文件内容：LLJavaGuide</span></span><br><span class="line"><span class="comment">* 输出：</span></span><br><span class="line"><span class="comment">* Number of remaining bytes:11</span></span><br><span class="line"><span class="comment">* The actual number of skipped bytes:2</span></span><br><span class="line"><span class="comment">* The content read from file：JavaGuide</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>使用技巧：一般我们是不会直接单独使用 FileInputStream ，通常会配合 BufferedInputStream（字节缓冲输入流，下面会讲到）来使用。</p>
</blockquote>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们可以通过readAllBytes()读取输入流中所有字节并将其直接赋值给一个String对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//创建一个BufferedInputStream 对象</span></span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line">    <span class="comment">//读取文件的内容并复制到String对象中</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bis.readAllBytes());</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>DataInputStream</strong>（数据流）<ul>
<li>DataInputStream 用于读取指定类型数据，不能单独使用，必须结合 FileInputStream</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//必须将fis作为构造参数才能使用</span></span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(fis);</span><br><span class="line">    <span class="comment">//可以读取任意具体的类型数据</span></span><br><span class="line">    dis.readBoolean();<span class="comment">//从文件中读取一个 boolean 类型的字节数据。</span></span><br><span class="line">    dis.readInt();<span class="comment">//从文件中读取一个 int 类型的字节数据。</span></span><br><span class="line">    dis.readUTF();<span class="comment">//从文件中读取一个 UTF 字符串数据。</span></span><br><span class="line">    dis.readByte();<span class="comment">//从文件中读取一个byte类型的字节数据</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>注意：DataOutputStream写的文件，只能使用DataInputStream去读。并且读的时候你需要提前知道写入的顺序。读的顺序需要和写的顺序一致。才可以正常取出数据。[无论是不是DataOutputStream写的文件，用DataInputStream去读，都需要保证读取顺序与写入顺序一致]</p>
</blockquote>
</li>
<li><strong>ObjectInputStream</strong>(序列化)<ul>
<li>ObjectInputStream 用于从输入流中读取 Java 对象（反序列化），ObjectOutputStream 用于将对象写入到输出流 (序列化)。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;users&quot;</span>));</span><br><span class="line">    <span class="comment">//Object obj = ois.readObject();</span></span><br><span class="line">    <span class="comment">//System.out.println(obj instanceof List);//true</span></span><br><span class="line">    List&lt;User&gt; userList = (List&lt;User&gt;)ois.readObject();</span><br><span class="line">    <span class="keyword">for</span>(User user : userList)&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    ois.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>注意：用于序列化和反序列化的类必须实现 Serializable 接口，生成序列化版本号。对象中如果有属性不想被序列化，使用 transient 修饰。</p>
</blockquote>
</li>
</ul>
<h4 id="2-2-OutputStream-字节输出流"><a href="#2-2-OutputStream-字节输出流" class="headerlink" title="2.2 OutputStream(字节输出流)"></a>2.2 OutputStream(字节输出流)</h4><h5 id="2-2-1-概述"><a href="#2-2-1-概述" class="headerlink" title="2.2.1 概述"></a>2.2.1 概述</h5><p><code>OutputStream</code> 用于将数据（字节信息）写入到目的地（通常是文件），java.io.OutputStream 抽象类是所有字节输出流的父类。</p>
<h5 id="2-1-2-常用方法-1"><a href="#2-1-2-常用方法-1" class="headerlink" title="2.1.2 常用方法"></a>2.1.2 常用方法</h5><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>write(int b)</code></td>
<td>将指定字节b写入到输出流中。</td>
</tr>
<tr>
<td><code>read(byte b[ ])</code></td>
<td>将数组b写入到输出流,等价于 read(b, 0, b.length)。</td>
</tr>
<tr>
<td><code>write(byte b[], int off, int len)</code></td>
<td>在write(byte b[])方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字节数）。</td>
</tr>
<tr>
<td><code>flush()</code></td>
<td>刷新此输出流并强制写出所有缓冲的字节[多用在带有缓冲流的实现类中]</td>
</tr>
<tr>
<td><code>close()</code></td>
<td>关闭输出流释放相关的系统资源。</td>
</tr>
</tbody></table>
<h5 id="2-2-3-实现类"><a href="#2-2-3-实现类" class="headerlink" title="2.2.3 实现类"></a>2.2.3 实现类</h5><ul>
<li><strong>FileOutputStream</strong> <ul>
<li>FileOutputStream 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>);<span class="comment">//若文件不存在，会自动创建。第二个参数(true/false)表示是否追加。[不填默认覆盖]</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="string">&quot;JavaGuide&quot;</span>.getBytes();</span><br><span class="line">    fis.write(bytes);</span><br><span class="line">    fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>使用技巧：类似于 FileInputStream，FileOutputStream 通常也会配合 BufferedOutputStream（字节缓冲输出流，下面会讲到）来使用</p>
</blockquote>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//方法一：</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fis);</span><br><span class="line">    <span class="comment">//方法二：</span></span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>DataOutputStream</strong>（数据流）<ul>
<li>DataOutputStream 用于写入指定类型数据，不能单独使用，必须结合 FileOutputStream</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//输出流</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(fos);</span><br><span class="line">    <span class="comment">//输出任意数据类型</span></span><br><span class="line">    dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">    dos.writeByte(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>注意：这个流可以将数据连同数据的类型一起写入文件。<mark>这个文件不是普通的文本文档，而是一个二进制文件。(记事本打不开)</mark></p>
</blockquote>
</li>
<li><strong>ObjectOutputStream</strong>（反序列化）<ul>
<li>ObjectInputStream 用于从输入流中读取 Java 对象（<strong>反序列化</strong>），ObjectOutputStream 用于将对象写入到输出流 (<strong>序列化</strong>)</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file.txt&quot;</span>));</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>);</span><br><span class="line">    oos.writeObject(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>注意：用于序列化的类必须实现 Serializable 接口，生成序列化版本号。对象中如果有属性不想被序列化，使用 transient 修饰。</p>
</blockquote>
</li>
</ul>
<h3 id="3-字符流"><a href="#3-字符流" class="headerlink" title="3. 字符流"></a>3. 字符流</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><h5 id="3-1-1-为什么要有字符流"><a href="#3-1-1-为什么要有字符流" class="headerlink" title="3.1.1 为什么要有字符流"></a>3.1.1 为什么要有字符流</h5><p><strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。那为什么I&#x2F;O流操作要分为字节流操作和字符流操作呢？</strong></p>
<ul>
<li>字符流是由Java虚拟机将字节转换得到的，这个过程还算是比较耗时的。</li>
<li>如果我们不知道编码类型就很容易出现乱码问题。</li>
</ul>
<p>因此，I&#x2F;O流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<h5 id="3-1-2-字符流采用编码"><a href="#3-1-2-字符流采用编码" class="headerlink" title="3.1.2 字符流采用编码"></a>3.1.2 字符流采用编码</h5><p>字符流默认采用的是<code>Unicode</code>编码，我们可以通过构造方法自定义编码。常用字符编码所占字节数：</p>
<ul>
<li>utf-8：英文占1字节，中文占3字节</li>
<li>unicode：任何字符都占2个字节</li>
<li>gbk：英文占1字节，中文占2字节</li>
</ul>
<h4 id="3-2-Reader-字符输入流"><a href="#3-2-Reader-字符输入流" class="headerlink" title="3.2 Reader(字符输入流)"></a>3.2 Reader(字符输入流)</h4><h5 id="3-2-1-概述"><a href="#3-2-1-概述" class="headerlink" title="3.2.1 概述"></a>3.2.1 概述</h5><p>Reader用于从源头（通常是文件）读取数据（字符信息）到内存中，java.io.Reader抽象类是所有字符输入流的父类。</p>
<blockquote>
<p>Reader 用于读取文本， InputStream 用于读取原始字节。</p>
</blockquote>
<h5 id="3-2-2-常用方法"><a href="#3-2-2-常用方法" class="headerlink" title="3.2.2 常用方法"></a>3.2.2 常用方法</h5><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>read()</code></td>
<td>从输入流中读取一个字符。</td>
</tr>
<tr>
<td><code>read(char cbuf[])</code></td>
<td>从输入流中读取一些字符，并将它们储存到字符数组 cbuf 中。等价于 read(cbuf, 0, cbuf.length)。</td>
</tr>
<tr>
<td><code>read(char cbuf[], int off, int len)</code></td>
<td>在read(char cbuf[])方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字符数）。</td>
</tr>
<tr>
<td><code>skip(long n)</code></td>
<td>忽略输入流中的n个字符，返回实际忽略的字符数。</td>
</tr>
<tr>
<td><code>close()</code></td>
<td>关闭输入流释放相关的系统资源。</td>
</tr>
</tbody></table>
<blockquote>
<p>空参的read方法和有参的read方法的区别：<br>空参的read方法：一次读取一个字节，遇到中文一次读取多个字节，把字节解码并转成十进制返回<br>有参的read方法：把读取字节，解码，强转三步合并了，强转之后的字符放到数组中，返回的是读取的字符数</p>
</blockquote>
<h5 id="3-2-3-实现类"><a href="#3-2-3-实现类" class="headerlink" title="3.2.3 实现类"></a>3.2.3 实现类</h5><ul>
<li><strong>InputStreamReader</strong>(转换流)<ul>
<li>InputStreamReader 是字节流转换为字符流的桥梁，其子类 FileReader 是基于该基础上的封装，可以直接操作字符文件</li>
<li>内部有长度为8192的缓冲区，可以提高读取效率。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字节流转换为字符流的桥梁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InpuStreamReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于读取字符文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader</span> <span class="keyword">extends</span> <span class="title class_">InputStreamReader</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>FileReader</strong><ul>
<li>用字符流读取文件，可以指定编码格式(不指定时，使用平台默认的字符编码-&gt;通常为utf-8)。[只能读取纯文本文件]</li>
<li>内部有长度为8192的缓冲区，可以提高读取效率。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fid</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">    <span class="type">int</span> content;</span><br><span class="line">    <span class="type">long</span> <span class="variable">skip</span> <span class="operator">=</span> fid.skip(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;The actual number of bytes skipped: &quot;</span> + skip);</span><br><span class="line">    System.out.print(<span class="string">&quot;The content of the file: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((content = fid.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) content);</span><br><span class="line">    &#125;</span><br><span class="line">    fid.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* inout.txt内容：LL,我是Guide</span></span><br><span class="line"><span class="comment">* 输出：</span></span><br><span class="line"><span class="comment">* The actual number of bytes skipped:3</span></span><br><span class="line"><span class="comment">* he content of the file:我是Guide</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="3-3-Writer-字符输出流"><a href="#3-3-Writer-字符输出流" class="headerlink" title="3.3 Writer(字符输出流)"></a>3.3 Writer(字符输出流)</h4><h5 id="3-3-1-概述"><a href="#3-3-1-概述" class="headerlink" title="3.3.1 概述"></a>3.3.1 概述</h5><p>Writer用于将数据（字符信息）写入到目的地（通常是文件），java.io.Writer抽象类是所有字节输出流的父类。</p>
<h5 id="3-3-2-常用方法"><a href="#3-3-2-常用方法" class="headerlink" title="3.3.2 常用方法"></a>3.3.2 常用方法</h5><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>write(int c)</code></td>
<td>写入单个字符</td>
</tr>
<tr>
<td><code>write(char cbuf[])</code></td>
<td>写入字符数组 cubf 中的所有字符。等价于 write(cbuf, 0, cbuf.length)。</td>
</tr>
<tr>
<td><code>write(char cbuf[], int off, int len)</code></td>
<td>在write(char cbuf[])方法的基础上增加了 off 参数（偏移量）和 len 参数（要写入的最大字符数）。</td>
</tr>
<tr>
<td><code>write(String str)</code></td>
<td>写入字符串 str 。等价于 write(str, 0, str.length)。</td>
</tr>
<tr>
<td><code>write(String str, int off, int len)</code></td>
<td>在write(String str)方法的基础上增加了 off 参数（偏移量）和 len 参数（要写入的最大字符数）。</td>
</tr>
<tr>
<td><code>append(CharSequence csq)</code></td>
<td>将指定的字符序列附加到指定的Writer对象并返回该Writer对象。[若要追加，在指定文件时第二个参数要传true]</td>
</tr>
<tr>
<td><code>append(char c)</code></td>
<td>将指定的字符附加到指定的Writer对象并返回该Writer对象。[若要追加，在指定文件时第二个参数要传true]</td>
</tr>
<tr>
<td><code>flush()</code></td>
<td>刷新输出流，将缓冲区中的数据写入目的地。</td>
</tr>
<tr>
<td><code>close()</code></td>
<td>关闭输出流，释放相关的系统资源。</td>
</tr>
</tbody></table>
<h5 id="3-3-3-实现类"><a href="#3-3-3-实现类" class="headerlink" title="3.3.3 实现类"></a>3.3.3 实现类</h5><ul>
<li><strong>OutputStreamWriter</strong>(转换流)<ul>
<li>OutputStreamWriter 是字符流转换为字节流的桥梁，其子类 FileWriter 是基于该基础上的封装，可以直接将字符写入到文件。</li>
<li>内部有长度为8192的缓冲区，可以提高读取效率。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字节流转换为字符流的桥梁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriter</span> <span class="keyword">extends</span> <span class="title class_">Writer</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于写入字符到文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriter</span> <span class="keyword">extends</span> <span class="title class_">OutputStreamWriter</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>FileWriter</strong><ul>
<li>不同系统的换行符号：<ul>
<li>linux：\n</li>
<li>windows：\r\n</li>
<li>mac：\r</li>
</ul>
</li>
<li>内部有长度为8192的缓冲区，可以提高读取效率。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">    fw.write(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    fw.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// input.txt: Hello World</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="4-缓冲流"><a href="#4-缓冲流" class="headerlink" title="4. 缓冲流"></a>4. 缓冲流</h3><h4 id="4-1-为什么要有缓冲流"><a href="#4-1-为什么要有缓冲流" class="headerlink" title="4.1 为什么要有缓冲流"></a>4.1 为什么要有缓冲流</h4><ul>
<li>IO操作是很消耗性能的，缓冲流可以将数据加载至缓冲区，一次性读取&#x2F;写入多个字节，从而避免频繁的IO操作，提高流的传输效率。</li>
</ul>
<h4 id="4-2-字节缓冲流"><a href="#4-2-字节缓冲流" class="headerlink" title="4.2 字节缓冲流"></a>4.2 字节缓冲流</h4><ul>
<li>字节缓冲流这里采用了修饰器模式来增强InputStream和OutputStream的功能，从而实现缓冲流。</li>
<li>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用write(int b) 和 read() 这两个一次只读一个字节的方法的时候。由于字节缓存流内部有缓冲区(一个长度为8192的字节数组)，因此，字节缓冲流会将读取到的字节放在缓存区中，大幅减少IO次数，提高读取效率</li>
<li>如果是调用read(byte[] b)和writer(byte[] b,int off,int len)这两个读取&#x2F;写入一个字节数组的方法的话，只要字节数组的大小合适，两者的性能差距其实不大，基本可以忽略。</li>
</ul>
<h5 id="4-2-1-BufferedInputStream-字节缓冲输入流"><a href="#4-2-1-BufferedInputStream-字节缓冲输入流" class="headerlink" title="4.2.1 BufferedInputStream(字节缓冲输入流)"></a>4.2.1 BufferedInputStream(字节缓冲输入流)</h5><ul>
<li>BufferedInputStream 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。</li>
<li>BufferedInputStream 内部维护了一个缓冲区，这个缓冲区实际就是一个长度为8192的字节(byte)数组，通过阅读 BufferedInputStream 源码即可得到这个结论。<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span> &#123;</span><br><span class="line">  <span class="comment">// 缓冲区的默认大小</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">8192</span>;</span><br><span class="line">  <span class="comment">// 内部缓冲区数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] EMPTY = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 使用默认的缓冲区大小</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>(in, DEFAULT_BUFFER_SIZE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 自定义缓冲区大小</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(in);</span><br><span class="line">      <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      initialSize = size;</span><br><span class="line">      <span class="keyword">if</span> (getClass() == BufferedInputStream.class) &#123;</span><br><span class="line">          <span class="comment">// use internal lock and lazily create buffer when not subclassed</span></span><br><span class="line">          lock = InternalLock.newLockOrNull();</span><br><span class="line">          buf = EMPTY;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// use monitors and eagerly create buffer when subclassed</span></span><br><span class="line">          lock = <span class="literal">null</span>;</span><br><span class="line">          buf = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>缓冲区的大小默认为 8192 字节，当然了，也可以通过 BufferedInputStream(InputStream in, int size) 这个构造方法来指定缓冲区的大小。</li>
</ul>
<h5 id="4-2-2-BufferedOutputStream-字节缓冲输出流"><a href="#4-2-2-BufferedOutputStream-字节缓冲输出流" class="headerlink" title="4.2.2 BufferedOutputStream(字节缓冲输出流)"></a>4.2.2 BufferedOutputStream(字节缓冲输出流)</h5><ul>
<li>BufferedOutputStream 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率。</li>
<li>示例：往 output.txt 文件写内容：<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>));</span><br><span class="line">     bos.write(<span class="string">&quot;Hello World&quot;</span>.getBytes());</span><br><span class="line">     bos.flush();</span><br><span class="line">     bos.close();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// output.txt: Hello World</span></span><br></pre></td></tr></table></figure></div></li>
<li>类似于 BufferedInputStream ，BufferedOutputStream 内部也维护了一个缓冲区，并且，这个缓存区的大小也是 8192 字节。</li>
</ul>
<h4 id="4-3-字符缓冲流"><a href="#4-3-字符缓冲流" class="headerlink" title="4.3 字符缓冲流"></a>4.3 字符缓冲流</h4><ul>
<li>BufferedReader （字符缓冲输入流）和 BufferedWriter（字符缓冲输出流）类似于 BufferedInputStream（字节缓冲输入流）和 BufferedOutputStream（字节缓冲输出流），内部都维护了一个长度为 8192 的字符(char)数组作为缓冲区。不过，前者主要是用来操作字符信息。</li>
</ul>
<h5 id="4-3-1-BufferedReader-字符缓冲输入流"><a href="#4-3-1-BufferedReader-字符缓冲输入流" class="headerlink" title="4.3.1 BufferedReader(字符缓冲输入流)"></a>4.3.1 BufferedReader(字符缓冲输入流)</h5><ul>
<li>特有方法：<ul>
<li><code>public String readLine() throws IOException</code> ：从输入流中读取一行文本，并返回一个字符串。当达到文件末尾时，返回 <code>null</code>。</li>
<li><code>public Stream&lt;String&gt; lines() throws IOException</code> ：返回一个Stream<String>流，该流包含从输入流中读取的所有行。</li>
<li><code>public boolean ready() throws IOException</code> ：检查是否可以从流中读取数据而不是阻塞。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>))) &#123;</span><br><span class="line">        String str;</span><br><span class="line">        <span class="keyword">while</span> ((str = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出：Hello World 1</span></span><br><span class="line"><span class="comment">        Hello World 2</span></span><br><span class="line"><span class="comment">        Hello World 3</span></span><br><span class="line"><span class="comment">        Hello World 4</span></span><br><span class="line"><span class="comment">        Hello World 5</span></span><br><span class="line"><span class="comment">        Hello World 6*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line">      br.lines().forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 输出：Hello World 1</span></span><br><span class="line"><span class="comment">        Hello World 2</span></span><br><span class="line"><span class="comment">        Hello World 3</span></span><br><span class="line"><span class="comment">        Hello World 4</span></span><br><span class="line"><span class="comment">        Hello World 5</span></span><br><span class="line"><span class="comment">        Hello World 6*/</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h5 id="4-3-2-BufferedWriter-字符缓冲输出流"><a href="#4-3-2-BufferedWriter-字符缓冲输出流" class="headerlink" title="4.3.2 BufferedWriter(字符缓冲输出流)"></a>4.3.2 BufferedWriter(字符缓冲输出流)</h5><ul>
<li>特有方法：<ul>
<li><code>public void newLine() throws IOException</code> ：写入一个换行符。[跨平台的换行]</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>));</span><br><span class="line">      bw.write(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">      bw.newLine();</span><br><span class="line">      bw.write(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">      bw.flush();</span><br><span class="line">      bw.close();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* output.txt:  Hello World</span></span><br><span class="line"><span class="comment">                  Java*/</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="5-打印流"><a href="#5-打印流" class="headerlink" title="5. 打印流"></a>5. 打印流</h3><ul>
<li>PrintStream 属于字节打印流，是OutputStream的子类，可以将数据输出到指定的目的地。[默认输出到控制台]</li>
<li>PrintWriter 属于字符打印流，是Writer的子类，可以将数据输出到指定的目的地。[默认输出到控制台]</li>
</ul>
<h4 id="5-1-常用方法"><a href="#5-1-常用方法" class="headerlink" title="5.1 常用方法"></a>5.1 常用方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>println(参数类型不定x)</code></td>
<td>输出x带换行</td>
</tr>
<tr>
<td><code>print(参数类型不定x)</code></td>
<td>输出x不带换行</td>
</tr>
<tr>
<td><code>flush()</code></td>
<td>刷新输出流，将缓冲区中的数据写入目的地。</td>
</tr>
<tr>
<td><code>close()</code></td>
<td>关闭输出流，释放相关的系统资源。</td>
</tr>
</tbody></table>
<blockquote>
<p>改变流的输出方向：<strong>System.setOut(new PrintStream(new FileOutputStream(文件名)))</strong></p>
</blockquote>
<h4 id="5-2-示例"><a href="#5-2-示例" class="headerlink" title="5.2 示例"></a>5.2 示例</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="comment">// 可以改变标准输出流的输出方向吗？ 可以// 标准输出流不再指向控制台，指向“log”文件。</span></span><br><span class="line">       <span class="type">PrintStream</span> <span class="variable">printStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;log&quot;</span>));</span><br><span class="line">       <span class="comment">// 修改输出方向，将输出方向修改到&quot;log&quot;文件。</span></span><br><span class="line">       System.setOut(printStream);<span class="comment">// 修改输出方向</span></span><br><span class="line">       <span class="comment">// 再输出</span></span><br><span class="line">       System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;hello kitty&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;hello zhangsan&quot;</span>);</span><br><span class="line">       printStream.flush();</span><br><span class="line">       printStream.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="6-随机访问流"><a href="#6-随机访问流" class="headerlink" title="6. 随机访问流"></a>6. 随机访问流</h3><h4 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h4><p>随机访问流指的是支持随意跳转到文件的任意位置进行读写的RandomAccessFile。</p>
<h4 id="6-2-构造方法"><a href="#6-2-构造方法" class="headerlink" title="6.2 构造方法"></a>6.2 构造方法</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// openAndDelete 参数默认为false 表示打开文件并且这个文件不会被删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file,String mode)</span>&#123;</span><br><span class="line">    <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="built_in">this</span>(file,mode,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 私有方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file,String mode,<span class="type">boolean</span> opeanAndDelete)</span>&#123;</span><br><span class="line">    <span class="keyword">throws</span> FileNotFoundException&#123;</span><br><span class="line">        <span class="comment">// 省略大部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>RandomAccessFile的构造方法如上，我们可以指定mode（读写模式）：</p>
<ul>
<li><code>r</code>：只读模式</li>
<li><code>rw</code>：读写模式</li>
<li><code>rws</code>：相对于rw，rws同步更新对 “文件的内容” 或 “元数据” 的修改到外部储存设备。</li>
<li><code>rwd</code>：相对于rw，rwd同步更新对 “文件的内容” 的修改到外部储存设备。<br>文件内容指的是文件中实际保存的数据，元数据则是用来描述文件属性如文件的大小信息、创建和修改时间。</li>
</ul>
<h4 id="6-3-常用方法"><a href="#6-3-常用方法" class="headerlink" title="6.3 常用方法"></a>6.3 常用方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>RandomAccessFile(File file,String mode)</code></td>
<td>mode取r(读)或rw(可读写)等，通过mode可以确定流对文件的访问权限</td>
</tr>
<tr>
<td><code>seek(long a)</code></td>
<td>将流的读写位置定位到距离文件开头 a 个字节处。</td>
</tr>
<tr>
<td><code>getFilePointer()</code></td>
<td>获取流的当前读写位置，返回的是一个 long 类型的值，表示距离文件开头的字节偏移量</td>
</tr>
<tr>
<td><code>read()</code></td>
<td>从文件中读取一个字节的数据，并返回读取到的字节。如果到达文件末尾，则返回 -1。这个方法每次只读取一个字节。</td>
</tr>
<tr>
<td><code>read(byte[] buffer)</code></td>
<td>从文件中读取一定数量的字节，并将它们存储到指定的字节数组 buffer 中。返回值为实际读取的字节数，如果到达文件末尾且没有更多的字节可供读取，则返回 -1；否则返回实际读取的字节数。</td>
</tr>
<tr>
<td><code>readFully(byte[] buffer)</code></td>
<td>从文件中读取指定数量的字节，并将它们存储到指定的字节数组 buffer 中。与 read() 方法不同的是，readFully() 方法更严格，如果文件中的数据不足以填满整个 buffer，则 readFully() 方法会抛出 EOFException 异常，而不是返回部分读取的数据。</td>
</tr>
<tr>
<td><code>write(int b)</code></td>
<td>向文件中写入一个字节的数据。参数 b 表示要写入的字节。</td>
</tr>
<tr>
<td><code>write(byte[] buffer)</code></td>
<td>向文件中写入指定字节数组 buffer 中的数据。写入的数据数量取决于 buffer 的长度。</td>
</tr>
<tr>
<td><code>writeBytes(String s)</code></td>
<td>向文件中写入指定的字符串 s。写入的数据是字符串 s 的字节表示形式。</td>
</tr>
<tr>
<td><code>writeUTF(String s)</code></td>
<td>向文件中写入指定的字符串 s，使用UTF-8编码。在写入时，会在字符串前面添加两个字节的长度信息，以便读取时能够正确地解析字符串。</td>
</tr>
<tr>
<td><code>length()</code></td>
<td>获取文件的长度，返回值为文件的字节数。</td>
</tr>
<tr>
<td><code>close()</code></td>
<td>关闭文件流，释放相关的系统资源。</td>
</tr>
<tr>
<td><code>getFD()</code></td>
<td>返回与此文件关联的文件描述符对象（FileDescriptor）[通常用于创建新的IO流，如FileInputStream、FileOutputStream、RandomAccessFile等]</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>在 RandomAccessFile 中，seek(long a) 和 getFilePointer() 方法是按字节定位的，这意味着它们不会意识到文件中的字符编码。因此，如果文件中包含多字节字符（例如中文），直接按字节定位可能会导致位置计算错误。</li>
<li>在使用 RandomAccessFile 写出数据时，数据以字节形式写出到文件中。</li>
</ul>
</blockquote>
<h4 id="6-4-使用场景"><a href="#6-4-使用场景" class="headerlink" title="6.4 使用场景"></a>6.4 使用场景</h4><p>RandomAccessFile 比较常见的一个应用就是实现大文件的 断点续传 。何谓断点续传？简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。</p>
<h4 id="6-5-示例"><a href="#6-5-示例" class="headerlink" title="6.5 示例"></a>6.5 示例</h4><p>RandomAccessFile 读写数据</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">       <span class="comment">//将若干数据写入到文件中</span></span><br><span class="line">       raf.write(<span class="string">&quot;\r\n忆高考&quot;</span>.getBytes());</span><br><span class="line">       raf.write(<span class="string">&quot;\r\n年年忆今朝，茫茫赶国考；&quot;</span>.getBytes());</span><br><span class="line">       raf.write(<span class="string">&quot;\r\n不成真秀才，只图自逍遥。&quot;</span>.getBytes());</span><br><span class="line">       raf.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">       raf.write(<span class="number">97</span>);</span><br><span class="line">       raf.seek(<span class="number">0</span>);</span><br><span class="line">       <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(raf.getFD()))); <span class="comment">//或者：BufferedReader br = new BufferedReader(new FileReader(raf.getFD()));</span></span><br><span class="line">       String str;</span><br><span class="line">       <span class="keyword">while</span> ((str = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">           System.out.println(str);</span><br><span class="line">       &#125;</span><br><span class="line">       br.close();</span><br><span class="line">       raf.close();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/* 输出： 忆高考</span></span><br><span class="line"><span class="comment">         年年忆今朝，茫茫赶国考；</span></span><br><span class="line"><span class="comment">         不成真秀才，只图自逍遥。</span></span><br><span class="line"><span class="comment">         a*/</span></span><br></pre></td></tr></table></figure></div>

<p>RandomAccessFile 可以帮助我们合并文件分片，示例代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">merge</span><span class="params">(String fileName)</span>&#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">RandomAccessFile</span> <span class="variable">oSaveFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(fileName,<span class="string">&quot;rw&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;DOWNLOAD_THREAD_NUM;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>(<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName + FILE_TEMP_SUFFIX + i)))&#123;</span><br><span class="line">                <span class="keyword">while</span> ((len= bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                    oSaveFile.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        logUtils.inof(<span class="string">&quot;文件合并完毕 &#123;&#125;&quot;</span>,fileName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>分片上传常常使用在大文件的上传问题中，《Java 面试指北》中详细介绍了大文件的上传问题</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2024/07/18/Docker/</url>
    <content><![CDATA[<h2 id="Docker快速通关"><a href="#Docker快速通关" class="headerlink" title="Docker快速通关"></a>Docker快速通关</h2><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><table>
<thead>
<tr>
<th align="left"><strong>命令</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">docker pull</td>
<td align="left">拉取镜像</td>
</tr>
<tr>
<td align="left">docker push</td>
<td align="left">推送镜像到DockerRegistry</td>
</tr>
<tr>
<td align="left">docker images</td>
<td align="left">查看本地镜像</td>
</tr>
<tr>
<td align="left">docker rmi</td>
<td align="left">删除本地镜像</td>
</tr>
<tr>
<td align="left">docker run</td>
<td align="left">创建并运行容器（不能重复创建）</td>
</tr>
<tr>
<td align="left">docker stop</td>
<td align="left">停止指定容器</td>
</tr>
<tr>
<td align="left">docker start</td>
<td align="left">启动指定容器</td>
</tr>
<tr>
<td align="left">docker restart</td>
<td align="left">重新启动容器</td>
</tr>
<tr>
<td align="left">docker rm</td>
<td align="left">删除指定容器</td>
</tr>
<tr>
<td align="left">docker ps</td>
<td align="left">查看容器</td>
</tr>
<tr>
<td align="left">docker logs</td>
<td align="left">查看容器运行日志</td>
</tr>
<tr>
<td align="left">docker exec</td>
<td align="left">进入容器</td>
</tr>
<tr>
<td align="left">docker save</td>
<td align="left">保存镜像到本地压缩文件</td>
</tr>
<tr>
<td align="left">docker load</td>
<td align="left">加载本地压缩文件到镜像</td>
</tr>
<tr>
<td align="left">docker inspect</td>
<td align="left">查看容器详细信息</td>
</tr>
</tbody></table>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202502262158271.png"
                      alt="image-20250226215805065"
                ></p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看运行中的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看所有容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">搜索镜像</span></span><br><span class="line">docker search nginx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载指定版本镜像</span></span><br><span class="line">docker pull nginx:1.26.0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看所有镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除指定<span class="built_in">id</span>的镜像</span></span><br><span class="line">docker rmi e784f4560448</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看所有容器<span class="built_in">id</span></span></span><br><span class="line">docker ps -aq</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除所有容器/镜像</span></span><br><span class="line">docker rm/rmi $&#123;docker ps -aq&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行一个新容器</span></span><br><span class="line">docker run nginx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止容器</span></span><br><span class="line">docker stop keen_blackwell</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动容器</span></span><br><span class="line">docker start 592</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart 592</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看容器资源占用情况</span></span><br><span class="line">docker stats 592</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看容器日志</span></span><br><span class="line">docker logs 592</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除指定容器</span></span><br><span class="line">docker rm 592</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">强制删除指定容器</span></span><br><span class="line">docker rm -f 592</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台启动容器</span></span><br><span class="line">docker run -d --name mynginx nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台启动并暴露端口</span></span><br><span class="line">docker run -d --name mynginx -p 80:80 nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器内部</span></span><br><span class="line">docker exec -it mynginx /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交容器变化打成一个新的镜像</span></span><br><span class="line">docker commit -m &quot;update index.html&quot; mynginx mynginx:v1.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存镜像为指定文件</span></span><br><span class="line">docker save -o mynginx.tar mynginx:v1.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除多个镜像</span></span><br><span class="line">docker rmi bde7d154a67f 94543a6c1aef e784f4560448</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载镜像</span></span><br><span class="line">docker load -i mynginx.tar </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登录 docker hub</span></span><br><span class="line">docker login</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新给镜像打标签</span></span><br><span class="line">docker tag mynginx:v1.0 leifengyang/mynginx:v1.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送镜像</span></span><br><span class="line">docker push leifengyang/mynginx:v1.0</span><br></pre></td></tr></table></figure></div>

<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>两种方式，注意区分：</p>
<ul>
<li>目录挂载： <code>-v /app/nghtml:/usr/share/nginx/html</code>（宿主机目录必须是存在的）</li>
<li>卷映射：<code>-v ngconf:/etc/nginx</code>（Docker 会自动管理卷的创建）</li>
</ul>
<blockquote>
<p>两种存储方式如果宿主机的目录、卷中有数据，都是以宿主机的数据为主，覆盖容器中原有的数据。</p>
</blockquote>
<p>数据卷的相关命令：</p>
<table>
<thead>
<tr>
<th align="left"><strong>命令</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">docker volume create</td>
<td align="left">创建数据卷</td>
</tr>
<tr>
<td align="left">docker volume ls</td>
<td align="left">查看所有数据卷</td>
</tr>
<tr>
<td align="left">docker volume rm</td>
<td align="left">删除指定数据卷</td>
</tr>
<tr>
<td align="left">docker volume inspect</td>
<td align="left">查看某个数据卷的详情</td>
</tr>
<tr>
<td align="left">docker volume prune</td>
<td align="left">清除数据卷</td>
</tr>
</tbody></table>
<p>注意：容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，<strong>是不能设置数据卷的</strong>。而且创建容器的过程中，数据卷会自动创建。</p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><table>
<thead>
<tr>
<th align="left"><strong>指令</strong></th>
<th align="left"><strong>说明</strong></th>
<th align="left"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>FROM</strong></td>
<td align="left">指定基础镜像</td>
<td align="left">FROM centos:6</td>
</tr>
<tr>
<td align="left"><strong>ENV</strong></td>
<td align="left">设置环境变量，可在后面指令使用</td>
<td align="left">ENV key value</td>
</tr>
<tr>
<td align="left"><strong>COPY</strong></td>
<td align="left">拷贝本地文件到镜像的指定目录</td>
<td align="left">COPY .&#x2F;xx.jar &#x2F;tmp&#x2F;app.jar</td>
</tr>
<tr>
<td align="left"><strong>RUN</strong></td>
<td align="left">执行Linux的shell命令，一般是安装过程的命令</td>
<td align="left">RUN yum install gcc</td>
</tr>
<tr>
<td align="left"><strong>EXPOSE</strong></td>
<td align="left">指定容器运行时监听的端口，是给镜像使用者看的</td>
<td align="left">EXPOSE 8080</td>
</tr>
<tr>
<td align="left"><strong>ENTRYPOINT</strong></td>
<td align="left">镜像中应用的启动命令，容器运行时调用</td>
<td align="left">ENTRYPOINT java -jar xx.jar</td>
</tr>
</tbody></table>
<p>简单示例：</p>
<ul>
<li>创建dockerfile文件</li>
</ul>
<div class="code-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>构建镜像</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202502262210433.png"
                      alt="image-20250226221050351"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入镜像目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/demo</span><br><span class="line"><span class="comment"># 开始构建</span></span><br><span class="line">docker build -t docker-demo:1.0 .</span><br></pre></td></tr></table></figure></div>

<p>命令说明：</p>
<ul>
<li><p><code>docker build </code>: 就是构建一个docker镜像</p>
</li>
<li><p><code>-t docker-demo:1.0</code> ：<code>-t</code>参数是指定镜像的名称（repository和tag）</p>
</li>
<li><p><code>.</code> : 最后的点是指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是<code>.</code>代表当前目录，也可以直接指定Dockerfile目录：</p>
<ul>
<li><pre><code class="language-Bash"># 直接指定Dockerfile目录
docker build -t docker-demo:1.0 /root/demo
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">![img](https://gitee.com/lusy37/typora/raw/master/202502262211623.png)</span><br><span class="line"></span><br><span class="line">### 网络</span><br><span class="line"></span><br><span class="line">| **命令**                  | **说明**                 |</span><br><span class="line">| :------------------------ | :----------------------- |</span><br><span class="line">| docker network create     | 创建一个网络             |</span><br><span class="line">| docker network ls         | 查看所有网络             |</span><br><span class="line">| docker network rm         | 删除指定网络             |</span><br><span class="line">| docker network prune      | 清除未使用的网络         |</span><br><span class="line">| docker network connect    | 使指定容器连接加入某网络 |</span><br><span class="line">| docker network disconnect | 使指定容器连接离开某网络 |</span><br><span class="line">| docker network inspect    | 查看网络详细信息         |</span><br><span class="line"></span><br><span class="line">docker中运行的容器IP是不固定的，所以需要搭建到同一个网络中，使用容器名来互相访问，实现互联。</span><br><span class="line"></span><br><span class="line">```Bash</span><br><span class="line"># 1.首先通过命令创建一个网络</span><br><span class="line">docker network create hmall</span><br><span class="line"></span><br><span class="line"># 2.然后查看网络</span><br><span class="line">docker network ls</span><br><span class="line"># 结果：</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">639bc44d0a87   bridge    bridge    local</span><br><span class="line">403f16ec62a2   hmall     bridge    local</span><br><span class="line">0dc0f72a0fbb   host      host      local</span><br><span class="line">cd8d3e8df47b   none      null      local</span><br><span class="line"># 其中，除了hmall以外，其它都是默认的网络</span><br><span class="line"></span><br><span class="line"># 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span><br><span class="line"># 这样该网络内的其它容器可以用别名互相访问！</span><br><span class="line"># 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名</span><br><span class="line">docker network connect hmall mysql --alias db</span><br><span class="line"># 3.2.db容器，也就是我们的java项目</span><br><span class="line">docker network connect hmall dd</span><br><span class="line"></span><br><span class="line"># 4.进入dd容器，尝试利用别名访问db</span><br><span class="line"># 4.1.进入容器</span><br><span class="line">docker exec -it dd bash</span><br><span class="line"># 4.2.用db别名访问</span><br><span class="line">ping db</span><br><span class="line"># 结果</span><br><span class="line">PING db (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms</span><br><span class="line"># 4.3.用容器名访问</span><br><span class="line">ping mysql</span><br><span class="line"># 结果：</span><br><span class="line">PING mysql (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure></div>
</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>在自定义网络中，可以给容器起多个别名，默认的别名是容器名本身</li>
<li>在同一个自定义网络中的容器，可以通过别名互相访问</li>
</ul>
<h3 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h3><p><code>docker-compose.yml</code> 文件是用来定义和配置多个 Docker 容器服务的一个文件，它是 Docker Compose 工具的核心部分。这个文件采用 YAML（YAML Ain’t Markup Language）语法，旨在提供一种清晰、简洁的方式来描述和管理容器服务。</p>
<p>下面我会通过一个基本的 <code>docker-compose.yml</code> 文件示例来讲解常见的语法和结构：</p>
<h4 id="1-版本号-version"><a href="#1-版本号-version" class="headerlink" title="1. 版本号 (version)"></a>1. <strong>版本号 (<code>version</code>)</strong></h4><p><code>docker-compose.yml</code> 文件的第一部分通常是指定 Compose 文件的版本。不同的版本支持不同的功能。常见的版本包括 <code>2.x</code> 和 <code>3.x</code> 系列，<code>3.x</code> 是最常用的版本。</p>
<p><strong>示例：</strong></p>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>version</code> 字段是必需的，确保你的文件可以正确解析和使用。</li>
</ul>
<h4 id="2-项目名-name"><a href="#2-项目名-name" class="headerlink" title="2. 项目名 (name)"></a>2. <strong>项目名 (<code>name</code>)</strong></h4><p><code>docker-compose.yml</code> 文件中的 <code>name</code> 属性是一个可选的顶级属性，用于指定 Docker Compose 项目的名称。这个项目名会作为生成的容器、网络和卷等资源的前缀，确保不同项目之间的资源不会发生冲突。</p>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">my_custom_project</span>  <span class="comment"># 自定义项目名称</span></span><br></pre></td></tr></table></figure></div>



<h4 id="3-服务-services"><a href="#3-服务-services" class="headerlink" title="3. 服务 (services)"></a>3. <strong>服务 (<code>services</code>)</strong></h4><p><code>services</code> 是 Compose 文件的核心部分。它定义了一个或多个容器服务，每个服务对应一个容器。你可以为每个服务配置具体的容器镜像、构建路径、端口映射、环境变量等。</p>
<p><strong>基本格式：</strong></p>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">service_name:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">image_name:tag</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./path/to/Dockerfile</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./host_path:/container_path</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">VAR_NAME=value</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">network_name</span></span><br></pre></td></tr></table></figure></div>

<h4 id="4-常见的配置选项"><a href="#4-常见的配置选项" class="headerlink" title="4. 常见的配置选项"></a>4. <strong>常见的配置选项</strong></h4><p>下面是一些常见的配置选项，可以用于每个服务的定义中：</p>
<h4 id="a-image-镜像"><a href="#a-image-镜像" class="headerlink" title="a. image (镜像)"></a>a. <strong>image</strong> (镜像)</h4><ul>
<li>使用指定的镜像来创建容器，通常可以指定版本（标签）。</li>
</ul>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br></pre></td></tr></table></figure></div>

<h4 id="b-build-构建"><a href="#b-build-构建" class="headerlink" title="b. build (构建)"></a>b. <strong>build</strong> (构建)</h4><ul>
<li>如果没有现成的镜像，您可以通过 Dockerfile 构建一个镜像。</li>
<li><code>context</code> 指定构建上下文（通常是包含 Dockerfile 的目录）。</li>
</ul>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./app</span></span><br></pre></td></tr></table></figure></div>

<h4 id="c-ports-端口映射"><a href="#c-ports-端口映射" class="headerlink" title="c. ports (端口映射)"></a>c. <strong>ports</strong> (端口映射)</h4><ul>
<li>将容器内的端口映射到宿主机的端口。格式是 <code>宿主机端口:容器端口</code>。</li>
</ul>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>这将容器的 80 端口映射到宿主机的 8080 端口。</p>
<h4 id="d-volumes-卷挂载"><a href="#d-volumes-卷挂载" class="headerlink" title="d. volumes (卷挂载)"></a>d. <strong>volumes</strong> (卷挂载)</h4><ul>
<li>将宿主机的目录或文件挂载到容器中。</li>
</ul>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/var/lib/postgresql/data</span></span><br></pre></td></tr></table></figure></div>

<p>这将宿主机的 <code>./data</code> 目录挂载到容器的 <code>/var/lib/postgresql/data</code>。</p>
<h4 id="e-environment-环境变量"><a href="#e-environment-环境变量" class="headerlink" title="e. environment (环境变量)"></a>e. <strong>environment</strong> (环境变量)</h4><ul>
<li>设置环境变量，用于容器内的配置。</li>
</ul>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-app</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DATABASE_URL=postgres://db:5432</span></span><br></pre></td></tr></table></figure></div>

<h4 id="f-depends-on-依赖服务"><a href="#f-depends-on-依赖服务" class="headerlink" title="f. depends_on (依赖服务)"></a>f. <strong>depends_on</strong> (依赖服务)</h4><ul>
<li>指定服务启动顺序，确保某些服务在其他服务启动之前被启动。</li>
</ul>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure></div>

<h4 id="g-restart-自动重启策略"><a href="#g-restart-自动重启策略" class="headerlink" title="g. restart (自动重启策略)"></a>g. <strong>restart</strong> (自动重启策略)</h4><ul>
<li>设置容器的重启策略。</li>
</ul>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure></div>

<p><code>restart</code> 的值可以是：</p>
<ul>
<li><code>no</code>（默认）：容器停止后不自动重启。</li>
<li><code>always</code>：容器停止时总是重启。</li>
<li><code>on-failure</code>：仅在容器非正常退出时才重启。</li>
<li><code>unless-stopped</code>：除非容器被手动停止，否则总是重启。</li>
</ul>
<h4 id="h-networks-网络"><a href="#h-networks-网络" class="headerlink" title="h. networks (网络)"></a>h. <strong>networks</strong> (网络)</h4><ul>
<li>定义容器使用的自定义网络。可以使容器之间的通信更加灵活。</li>
</ul>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">frontend</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">frontend</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">frontend:</span></span><br><span class="line">  	<span class="attr">name:</span> <span class="string">hmall</span> <span class="comment"># 可选, 如果不指定网络名, 默认是: 项目名_网络名</span></span><br></pre></td></tr></table></figure></div>

<h4 id="i-command-命令"><a href="#i-command-命令" class="headerlink" title="i. command (命令)"></a>i. <strong>command</strong> (命令)</h4><ul>
<li>覆盖容器的默认启动命令。</li>
</ul>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-app</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span>]</span><br></pre></td></tr></table></figure></div>

<hr>
<h4 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a><strong>完整示例</strong></h4><p>下面是一个较为完整的 <code>docker-compose.yml</code> 文件，展示了如何使用这些配置选项来定义一个 Web 应用和数据库服务：</p>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx.conf:/etc/nginx/nginx.conf</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">frontend</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:latest</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">POSTGRES_DB:</span> <span class="string">mydatabase</span></span><br><span class="line">      <span class="attr">POSTGRES_USER:</span> <span class="string">user</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">password</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db_data:/var/lib/postgresql/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">frontend:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db_data:</span></span><br></pre></td></tr></table></figure></div>

<h4 id="5-其他常用功能"><a href="#5-其他常用功能" class="headerlink" title="5. 其他常用功能"></a>5. <strong>其他常用功能</strong></h4><h4 id="a-多个服务定义"><a href="#a-多个服务定义" class="headerlink" title="a. 多个服务定义"></a>a. <strong>多个服务定义</strong></h4><p>你可以在 <code>docker-compose.yml</code> 文件中定义多个服务。例如，你可以在同一个 Compose 文件中运行 Web 服务、数据库服务、缓存服务等。</p>
<h4 id="b-使用-extends"><a href="#b-使用-extends" class="headerlink" title="b. 使用 extends"></a>b. <strong>使用 <code>extends</code></strong></h4><p><code>extends</code> 可以帮助你重用现有的服务配置，继承或覆盖某些设置（这个功能在某些版本的 Docker Compose 中已不推荐使用）。</p>
<h4 id="c-配置多个-Compose-文件"><a href="#c-配置多个-Compose-文件" class="headerlink" title="c. 配置多个 Compose 文件"></a>c. <strong>配置多个 Compose 文件</strong></h4><p>Docker Compose 支持使用多个文件来定义服务配置，可以通过 <code>-f</code> 选项指定多个 <code>yml</code> 文件来覆盖或扩展某些配置。</p>
<hr>
<h4 id="6-特性"><a href="#6-特性" class="headerlink" title="6. 特性"></a>6. <strong>特性</strong></h4><ul>
<li><p>增量更新：修改 Docker Compose 文件。重新启动应用。只会触发修改项的重新启动。</p>
</li>
<li><p>数据不删：默认就算down了容器，所有挂载的卷不会被移除。比较安全</p>
</li>
</ul>
<h4 id="7-基本语法"><a href="#7-基本语法" class="headerlink" title="7. 基本语法"></a>7. <strong>基本语法</strong></h4><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">docker compose [OPTIONS] [COMMAND]</span><br></pre></td></tr></table></figure></div>

<p>其中，OPTIONS和COMMAND都是可选参数，比较常见的有：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202502262330123.png"
                      alt="image-20250226233015750"
                ></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache POI</title>
    <url>/2024/07/17/Apache%20POI/</url>
    <content><![CDATA[<h1 id="Apache-POI-库"><a href="#Apache-POI-库" class="headerlink" title="Apache POI 库"></a>Apache POI 库</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Apache POI 是 Apache 软件基金会的开源项目，提供了Java操作Microsoft Office格式文件（如Word、Excel、PowerPoint）的功能。其中，POI对于Excel 文件的处理尤为突出，提供了丰富的API**用于、创建和修改Excel文件。本文将深入探讨Java中POI库的使用方法，包括基本概念、API详解、常见应用场景和案例演示。</p>
<h2 id="第一部分：POI库介绍与安装"><a href="#第一部分：POI库介绍与安装" class="headerlink" title="第一部分：POI库介绍与安装"></a>第一部分：POI库介绍与安装</h2><p>Apache POI是Java处理Microsoft Office文档的一种解决方案。它允许Java程序员读取和写入Excel、Word和PowerPoint等格式的文件。首先，我们来了解如何引入POI库到您的Java项目中。</p>
<h3 id="1-安装POI库"><a href="#1-安装POI库" class="headerlink" title="1. 安装POI库"></a>1. 安装POI库</h3><p>首先，您需要下载Apache POI的最新版本。访问Apache POI官网（<a class="link"   href="https://poi.apache.org/" >https://poi.apache.org<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>）可以找到最新的发布版本。下载后，将相关的JAR文件导入您的项目的依赖中。</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-POI库的结构与功能"><a href="#2-POI库的结构与功能" class="headerlink" title="2. POI库的结构与功能"></a>2. POI库的结构与功能</h3><p>POI主要分为以下几个模块：</p>
<ul>
<li>poi: 主要提供了对OLE2文件格式（例如Excel 97-2003）的支持。</li>
<li>poi-ooxml: 提供了对OOXML格式（例如xlsx）的支持。</li>
<li>poi-scratchpad: 提供了一些不成熟或者实验性质的代码，如对一些早期Office版本的支持。</li>
<li>poi-ooxml-schemas: 包含了所有OOXML架构文件。</li>
</ul>
<h2 id="第二部分：POI库的基本操作"><a href="#第二部分：POI库的基本操作" class="headerlink" title="第二部分：POI库的基本操作"></a>第二部分：POI库的基本操作</h2><p>在本部分中，我们将深入探讨POI库的基本操作，包括创建Excel文件、读取Excel文件、修改Excel文件和操作单元格等内容。</p>
<h3 id="1-创建Excel文件"><a href="#1-创建Excel文件" class="headerlink" title="1. 创建Excel文件"></a>1. 创建Excel文件</h3><p>使用POI库创建一个新的Excel文件非常简单。以下是一个简单的示例代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateExcelFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的工作簿</span></span><br><span class="line">        <span class="type">Workbook</span> <span class="variable">workbook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XSSFWorkbook</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 创建一个工作表</span></span><br><span class="line">        <span class="type">Sheet</span> <span class="variable">sheet</span> <span class="operator">=</span> workbook.createSheet(<span class="string">&quot;新建表格&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 创建一个行，并在其中创建一个单元格</span></span><br><span class="line">        <span class="type">Row</span> <span class="variable">row</span> <span class="operator">=</span> sheet.createRow(<span class="number">0</span>);</span><br><span class="line">        <span class="type">Cell</span> <span class="variable">cell</span> <span class="operator">=</span> row.createCell(<span class="number">0</span>);</span><br><span class="line">        cell.setCellValue(<span class="string">&quot;Hello, POI!&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 写出到文件</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;workbook.xlsx&quot;</span>)) &#123;</span><br><span class="line">            workbook.write(fileOut);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 关闭工作簿</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            workbook.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-读取和修改Excel文件"><a href="#2-读取和修改Excel文件" class="headerlink" title="2. 读取和修改Excel文件"></a>2. 读取和修改Excel文件</h3><p>读取和修改Excel文件也是POI库的常见应用。以下是一个读取Excel文件并修改内容的简单示例：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadModifyExcel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加载Excel文件</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;workbook.xlsx&quot;</span>));</span><br><span class="line">            <span class="type">Workbook</span> <span class="variable">workbook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XSSFWorkbook</span>(file);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 获取第一个工作表</span></span><br><span class="line">            <span class="type">Sheet</span> <span class="variable">sheet</span> <span class="operator">=</span> workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 获取第一行，并更新其中的单元格内容</span></span><br><span class="line">            <span class="type">Row</span> <span class="variable">row</span> <span class="operator">=</span> sheet.getRow(<span class="number">0</span>);</span><br><span class="line">            <span class="type">Cell</span> <span class="variable">cell</span> <span class="operator">=</span> row.getCell(<span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;第一行第一个单元格的内容是：&quot;</span>+cell.getStringCellValue());</span><br><span class="line">            cell.setCellValue(<span class="string">&quot;Hello, POI! Updated&quot;</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 写回到文件</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;workbook.xlsx&quot;</span>);</span><br><span class="line">            workbook.write(fileOut);</span><br><span class="line">            fileOut.close();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 关闭工作簿</span></span><br><span class="line">            workbook.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>工具集</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2024/05/21/JDBC/</url>
    <content><![CDATA[<h1 id="8-x数据库-JDK21版JDBC数据库连接技术"><a href="#8-x数据库-JDK21版JDBC数据库连接技术" class="headerlink" title="8.x数据库+JDK21版JDBC数据库连接技术"></a>8.x数据库+JDK21版JDBC数据库连接技术</h1><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><h4 id="1-1-数据的存储"><a href="#1-1-数据的存储" class="headerlink" title="1.1 数据的存储"></a>1.1 数据的存储</h4><blockquote>
<p>我们在开发Java程序时，数据都是存储在内存中，属于临时存储，当程序停止或重启时，内存中的数据就丢失了！我们为了解决数据的长期存储问题，有如下解决方案：</p>
<ol>
<li>数据通过I&#x2F;O流技术，存储在本地磁盘中，解决了持久化问题，但是没有结构和逻辑，不方便管理和维护。</li>
<li>通过关系型数据库，将数据按照特定的格式交由数据库管理系统维护。关系型数据库是通过库和表分隔不同的数据，表中数据存储的方式是行和列，区分相同格式不同值的数据。</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th align="center">数据库存储数据</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/202503101227795.png"
                     
                ></td>
</tr>
</tbody></table>
<h4 id="1-2-数据的操作"><a href="#1-2-数据的操作" class="headerlink" title="1.2 数据的操作"></a>1.2 数据的操作</h4><blockquote>
<p>数据存储在数据库，仅仅解决了我们数据存储的问题，但当我们程序运行时，需要读取数据，以及对数据做增删改的操作，那么我们如何通过Java程序对数据库中的数据做增删改查呢？</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">Java程序读取数据库</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202409141005173.png"
                      alt="image-20240221133525927"
                ></td>
</tr>
</tbody></table>
<h3 id="二、JDBC"><a href="#二、JDBC" class="headerlink" title="二、JDBC"></a>二、JDBC</h3><h4 id="2-1-JDBC的概念"><a href="#2-1-JDBC的概念" class="headerlink" title="2.1 JDBC的概念"></a>2.1 JDBC的概念</h4><blockquote>
<ul>
<li>JDBC：Java Database Connectivity，意为Java数据库连接。</li>
<li>JDBC是Java提供的一组独立于任何数据库管理系统的API。</li>
<li>Java提供接口规范，由各个数据库厂商提供接口的实现，厂商提供的实现类封装成jar文件，也就是我们俗称的数据库驱动jar包。</li>
<li>学习JDBC，充分体现了面向接口编程的好处，程序员只关心标准和规范，而无需关注实现过程。</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="center">JDBC简单执行过程</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202409141005595.png"
                      alt="image-20240221134431944"
                ></td>
</tr>
</tbody></table>
<h4 id="2-2-JDBC的核心组成"><a href="#2-2-JDBC的核心组成" class="headerlink" title="2.2 JDBC的核心组成"></a>2.2 JDBC的核心组成</h4><ul>
<li>接口规范：<ul>
<li>为了项目代码的可移植性，可维护性，SUN公司从最初就制定了Java程序连接各种数据库的统一接口规范。这样的话，不管是连接哪一种DBMS软件，Java代码可以保持一致性。</li>
<li>接口存储在java.sql和javax.sql包下。</li>
</ul>
</li>
<li>实现规范：<ul>
<li>因为各个数据库厂商的DBMS软件各有不同，那么各自的内部如何通过SQL实现增、删、改、查等操作管理数据，只有这个数据库厂商自己更清楚，因此把接口规范的实现交给各个数据库厂商自己实现。</li>
<li>厂商将实现内容和过程封装成jar文件，我们程序员只需要将jar文件引入到项目中集成即可，就可以开发调用实现过程操作数据库了。</li>
</ul>
</li>
</ul>
<h3 id="三、JDBC快速入门"><a href="#三、JDBC快速入门" class="headerlink" title="三、JDBC快速入门"></a>三、JDBC快速入门</h3><h4 id="3-1-JDBC搭建步骤"><a href="#3-1-JDBC搭建步骤" class="headerlink" title="3.1 JDBC搭建步骤"></a>3.1 JDBC搭建步骤</h4><ol>
<li>准备数据库。</li>
<li>官网下载数据库连接驱动jar包。<a href="">https://downloads.mysql.com/archives/c-j/</a></li>
<li>创建Java项目，在项目下创建lib文件夹，将下载的驱动jar包复制到文件夹里。</li>
<li>选中lib文件夹右键-&gt;Add as Library，与项目集成。</li>
<li>编写代码</li>
</ol>
<h4 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h4><h5 id="3-2-1-数据库"><a href="#3-2-1-数据库" class="headerlink" title="3.2.1 数据库"></a>3.2.1 数据库</h5><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE atguigu;</span><br><span class="line"></span><br><span class="line">use atguigu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create table</span> t_emp</span><br><span class="line">(</span><br><span class="line">    emp_id     <span class="type">int</span> auto_increment comment <span class="string">&#x27;员工编号&#x27;</span> <span class="keyword">primary key</span>,</span><br><span class="line">    emp_name   <span class="type">varchar</span>(<span class="number">100</span>)  <span class="keyword">not null</span> comment <span class="string">&#x27;员工姓名&#x27;</span>,</span><br><span class="line">    emp_salary <span class="keyword">double</span>(<span class="number">10</span>, <span class="number">5</span>) <span class="keyword">not null</span> comment <span class="string">&#x27;员工薪资&#x27;</span>,</span><br><span class="line">    emp_age    <span class="type">int</span>           <span class="keyword">not null</span> comment <span class="string">&#x27;员工年龄&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert into</span> t_emp (emp_name,emp_salary,emp_age)</span><br><span class="line"><span class="keyword">values</span>  (<span class="string">&#x27;andy&#x27;</span>, <span class="number">777.77</span>, <span class="number">32</span>),</span><br><span class="line">        (<span class="string">&#x27;大风哥&#x27;</span>, <span class="number">666.66</span>, <span class="number">41</span>),</span><br><span class="line">        (<span class="string">&#x27;康师傅&#x27;</span>,<span class="number">111</span>, <span class="number">23</span>),</span><br><span class="line">        (<span class="string">&#x27;Gavin&#x27;</span>,<span class="number">123</span>, <span class="number">26</span>),</span><br><span class="line">        (<span class="string">&#x27;小鱼儿&#x27;</span>, <span class="number">123</span>, <span class="number">28</span>);</span><br></pre></td></tr></table></figure></div>



<h5 id="3-2-2-Java代码"><a href="#3-2-2-Java代码" class="headerlink" title="3.2.2 Java代码"></a>3.2.2 Java代码</h5><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcQuick</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException， SQLException &#123;</span><br><span class="line">        <span class="comment">//1.注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//2.获取数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(</span><br><span class="line">        <span class="string">&quot;jdbc:mysql://localhost:3306/atguigu&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.创建Statement对象</span></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(</span><br><span class="line">        <span class="string">&quot;select emp_id,emp_name,emp_salary,emp_age from t_emp&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.编写SQL语句并执行，获取结果</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.处理结果</span></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">empId</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;emp_id&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">empName</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;emp_name&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">empSalary</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;emp_salary&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">empAge</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;emp_age&quot;</span>);</span><br><span class="line">            System.out.println(empId + <span class="string">&quot;\t&quot;</span> + empName + <span class="string">&quot;\t&quot;</span> + empSalary + <span class="string">&quot;\t&quot;</span> + empAge);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.释放资源(先开后关原则)</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        preparedStatement.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h4 id="3-3-步骤总结"><a href="#3-3-步骤总结" class="headerlink" title="3.3 步骤总结"></a>3.3 步骤总结</h4><ol>
<li>注册驱动【依赖的驱动类，进行安装】</li>
<li>获取连接【Connection建立连接】</li>
<li>创建发送SQL语句对象【Connection创建发送SQL语句的Statement】</li>
<li>发送SQL语句，并获取返回结果【Statement 发送sql语句到数据库并且取得返回结果】</li>
<li>结果集解析【结果集解析，将查询结果解析出来】</li>
<li>资源关闭【释放ResultSet、Statement 、Connection】</li>
</ol>
<h3 id="四、核心API理解"><a href="#四、核心API理解" class="headerlink" title="四、核心API理解"></a>四、核心API理解</h3><h4 id="4-1-注册驱动"><a href="#4-1-注册驱动" class="headerlink" title="4.1 注册驱动"></a>4.1 注册驱动</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>在 Java 中，当使用 JDBC（Java Database Connectivity）连接数据库时，需要加载数据库特定的驱动程序，以便与数据库进行通信。加载驱动程序的目的是为了注册驱动程序，使得 JDBC API 能够识别并与特定的数据库进行交互。</p>
</li>
<li><p>从JDK6开始，不再需要显式地调用 <code>Class.forName()</code> 来加载 JDBC 驱动程序，只要在类路径中集成了对应的jar文件，会自动在初始化时注册驱动程序。</p>
</li>
</ul>
<h4 id="4-2-Connection"><a href="#4-2-Connection" class="headerlink" title="4.2 Connection"></a>4.2 Connection</h4><ul>
<li>Connection接口是JDBC API的重要接口，用于建立与数据库的通信通道。换而言之，Connection对象不为空，则代表一次数据库连接。</li>
<li>在建立连接时，需要指定数据库URL、用户名、密码参数。<ul>
<li>URL：jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu<ul>
<li>jdbc:mysql:&#x2F;&#x2F;IP地址:端口号&#x2F;数据库名称?参数键值对1&amp;参数键值对2</li>
</ul>
</li>
</ul>
</li>
<li><code>Connection</code> 接口还负责管理事务，<code>Connection</code> 接口提供了 <code>commit</code> 和 <code>rollback</code> 方法，用于提交事务和回滚事务。</li>
<li>可以创建 <code>Statement</code> 对象，用于执行 SQL 语句并与数据库进行交互。</li>
<li>在使用JDBC技术时，必须要先获取Connection对象，在使用完毕后，要释放资源，避免资源占用浪费及泄漏。</li>
</ul>
<h4 id="4-3-Statement"><a href="#4-3-Statement" class="headerlink" title="4.3 Statement"></a>4.3 Statement</h4><ul>
<li><code>Statement</code> 接口用于执行 SQL 语句并与数据库进行交互。它是 JDBC API 中的一个重要接口。通过 <code>Statement</code> 对象，可以向数据库发送 SQL 语句并获取执行结果。</li>
<li>结果可以是一个或多个结果。<ul>
<li>增删改：受影响行数单个结果。</li>
<li>查询：单行单列、多行多列、单行多列等结果。</li>
</ul>
</li>
<li>但是<code>Statement</code> 接口在执行SQL语句时，会产生<code>SQL注入攻击问题</code>:<ul>
<li>当使用 <code>Statement</code> 执行动态构建的 SQL 查询时，往往需要将查询条件与 SQL 语句拼接在一起，直接将参数和SQL语句一并生成，让SQL的查询条件始终为true得到结果。</li>
</ul>
</li>
</ul>
<h4 id="4-4-PreparedStatement"><a href="#4-4-PreparedStatement" class="headerlink" title="4.4 PreparedStatement"></a>4.4 PreparedStatement</h4><ul>
<li><code>PreparedStatement</code>是 <code>Statement</code> 接口的子接口，用于执行<code>预编译</code>的 SQL 查询，作用如下：<ul>
<li>预编译SQL语句：在创建PreparedStatement时，就会预编译SQL语句，也就是SQL语句已经固定。</li>
<li>防止SQL注入：<code>PreparedStatement</code> 支持参数化查询，将数据作为参数传递到SQL语句中，采用?占位符的方式，将传入的参数用一对单引号包裹起来’’，无论传递什么都作为值。有效防止传入关键字或值导致SQL注入问题。</li>
<li>性能提升：PreparedStatement是预编译SQL语句，同一SQL语句多次执行的情况下，可以复用，不必每次重新编译和解析。</li>
</ul>
</li>
<li>后续的学习我们都是基于PreparedStatement进行实现，更安全、效率更高！</li>
</ul>
<h4 id="4-5-ResultSet"><a href="#4-5-ResultSet" class="headerlink" title="4.5 ResultSet"></a>4.5 ResultSet</h4><ul>
<li><code>ResultSet</code>是 JDBC API 中的一个接口，用于表示从数据库中<code>执行查询语句所返回的结果集</code>。它提供了一种用于遍历和访问查询结果的方式。</li>
<li>遍历结果：ResultSet可以使用 <code>next()</code> 方法将游标移动到结果集的下一行，逐行遍历数据库查询的结果，返回值为boolean类型，true代表有下一行结果，false则代表没有。</li>
<li>获取单列结果：可以通过getXxx的方法获取单列的数据，该方法为重载方法，支持索引和列名进行获取。</li>
</ul>
<h3 id="五、基于PreparedStatement实现CRUD"><a href="#五、基于PreparedStatement实现CRUD" class="headerlink" title="五、基于PreparedStatement实现CRUD"></a>五、基于PreparedStatement实现CRUD</h3><h4 id="5-1-查询单行单列"><a href="#5-1-查询单行单列" class="headerlink" title="5.1 查询单行单列"></a>5.1 查询单行单列</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">querySingleRowAndColumn</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">       <span class="comment">//1.注册驱动</span></span><br><span class="line">	<span class="comment">//Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//2.获取数据库连接</span></span><br><span class="line">       <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/atguigu&quot;</span>, <span class="string">&quot;root&quot;</span>,<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3.创建PreparedStatement对象，并预编译SQL语句</span></span><br><span class="line">       <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;select count(*) as count from t_emp&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//4.执行SQL语句，获取结果</span></span><br><span class="line">       <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//5.处理结果</span></span><br><span class="line">       <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;count&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//6.释放资源(先开后关原则)</span></span><br><span class="line">       resultSet.close();</span><br><span class="line">       preparedStatement.close();</span><br><span class="line">       connection.close();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="5-2-查询单行多列"><a href="#5-2-查询单行多列" class="headerlink" title="5.2 查询单行多列"></a>5.2 查询单行多列</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">querySingleRow</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">       <span class="comment">//1.注册驱动</span></span><br><span class="line">	<span class="comment">//Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//2.获取数据库连接</span></span><br><span class="line">       <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/atguigu&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3.创建PreparedStatement对象，并预编译SQL语句，使用?占位符</span></span><br><span class="line">       <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;select emp_id,emp_name,emp_salary,emp_age from t_emp where emp_id = ?&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//4.为占位符赋值，索引从1开始，执行SQL语句，获取结果</span></span><br><span class="line">       preparedStatement.setInt(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">       <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//5.处理结果</span></span><br><span class="line">       <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">empId</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;emp_id&quot;</span>);</span><br><span class="line">           <span class="type">String</span> <span class="variable">empName</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;emp_name&quot;</span>);</span><br><span class="line">           <span class="type">String</span> <span class="variable">empSalary</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;emp_salary&quot;</span>);</span><br><span class="line">           <span class="type">int</span> <span class="variable">empAge</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;emp_age&quot;</span>);</span><br><span class="line">           System.out.println(empId+<span class="string">&quot;\t&quot;</span>+empName+<span class="string">&quot;\t&quot;</span>+empSalary+<span class="string">&quot;\t&quot;</span>+empAge);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//6.释放资源(先开后关原则)</span></span><br><span class="line">       resultSet.close();</span><br><span class="line">       preparedStatement.close();</span><br><span class="line">       connection.close();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="5-3-查询多行多列"><a href="#5-3-查询多行多列" class="headerlink" title="5.3 查询多行多列"></a>5.3 查询多行多列</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryMoreRow</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">       <span class="comment">//1.注册驱动</span></span><br><span class="line">	<span class="comment">//Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//2.获取数据库连接</span></span><br><span class="line">       <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/atguigu&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3.创建Statement对象</span></span><br><span class="line">       <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;select emp_id,emp_name,emp_salary,emp_age from t_emp&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//4.编写SQL语句并执行，获取结果</span></span><br><span class="line">       <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//5.处理结果</span></span><br><span class="line">       <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">empId</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;emp_id&quot;</span>);</span><br><span class="line">           <span class="type">String</span> <span class="variable">empName</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;emp_name&quot;</span>);</span><br><span class="line">           <span class="type">String</span> <span class="variable">empSalary</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;emp_salary&quot;</span>);</span><br><span class="line">           <span class="type">int</span> <span class="variable">empAge</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;emp_age&quot;</span>);</span><br><span class="line">           System.out.println(empId+<span class="string">&quot;\t&quot;</span>+empName+<span class="string">&quot;\t&quot;</span>+empSalary+<span class="string">&quot;\t&quot;</span>+empAge);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//6.释放资源(先开后关原则)</span></span><br><span class="line">       resultSet.close();</span><br><span class="line">       preparedStatement.close();</span><br><span class="line">       connection.close();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="5-4-新增"><a href="#5-4-新增" class="headerlink" title="5.4 新增"></a>5.4 新增</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//1.注册驱动</span></span><br><span class="line"><span class="comment">//        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/atguigu&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.创建Statement对象</span></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;insert into t_emp (emp_name,emp_salary,emp_age)values  (?, ?,?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.为占位符赋值，索引从1开始，编写SQL语句并执行，获取结果</span></span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>,<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">        preparedStatement.setDouble(<span class="number">2</span>,<span class="number">666.66</span>);</span><br><span class="line">        preparedStatement.setDouble(<span class="number">3</span>,<span class="number">28</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> preparedStatement.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.处理结果</span></span><br><span class="line">        <span class="keyword">if</span>(result&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.释放资源(先开后关原则)</span></span><br><span class="line">        preparedStatement.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="5-5-修改"><a href="#5-5-修改" class="headerlink" title="5.5 修改"></a>5.5 修改</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//1.注册驱动</span></span><br><span class="line"><span class="comment">//        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/atguigu&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.创建Statement对象</span></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;update t_emp set emp_salary = ? where emp_id = ?&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.为占位符赋值，索引从1开始，编写SQL语句并执行，获取结果</span></span><br><span class="line">        preparedStatement.setDouble(<span class="number">1</span>,<span class="number">888.88</span>);</span><br><span class="line">        preparedStatement.setDouble(<span class="number">2</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> preparedStatement.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.处理结果</span></span><br><span class="line">        <span class="keyword">if</span>(result&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;修改成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;修改失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.释放资源(先开后关原则)</span></span><br><span class="line">        preparedStatement.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="5-6-删除"><a href="#5-6-删除" class="headerlink" title="5.6 删除"></a>5.6 删除</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//1.注册驱动</span></span><br><span class="line"><span class="comment">//        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/atguigu&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.创建Statement对象</span></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;delete from t_emp where emp_id = ?&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.为占位符赋值，索引从1开始，编写SQL语句并执行，获取结果</span></span><br><span class="line">        preparedStatement.setInt(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> preparedStatement.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.处理结果</span></span><br><span class="line">        <span class="keyword">if</span>(result&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.释放资源(先开后关原则)</span></span><br><span class="line">        preparedStatement.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h3><h4 id="6-1-资源的管理"><a href="#6-1-资源的管理" class="headerlink" title="6.1 资源的管理"></a>6.1 资源的管理</h4><blockquote>
<p>在使用JDBC的相关资源时，比如Connection、PreparedStatement、ResultSet，使用完毕后，要及时关闭这些资源以释放数据库服务器资源和避免内存泄漏是很重要的。</p>
</blockquote>
<h4 id="6-2-SQL语句问题"><a href="#6-2-SQL语句问题" class="headerlink" title="6.2 SQL语句问题"></a>6.2 SQL语句问题</h4><blockquote>
<p>java.sql.SQLSyntaxErrorException：SQL语句错误异常，一般有几种可能：</p>
<ol>
<li>SQL语句有错误，检查SQL语句！建议SQL语句在SQL工具中测试后再复制到Java程序中！</li>
<li>连接数据库的URL中，数据库名称编写错误，也会报该异常！</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202409141006352.png"
                      alt="image-20240223143826507"
                ></p>
</blockquote>
<h4 id="6-3-SQL语句未设置参数问题"><a href="#6-3-SQL语句未设置参数问题" class="headerlink" title="6.3 SQL语句未设置参数问题"></a>6.3 SQL语句未设置参数问题</h4><blockquote>
<p>java.sql.SQLException：No value specified for parameter 1</p>
<p>在使用预编译SQL语句时，如果有?占位符，要为每一个占位符赋值，否则报该错误！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202409141006966.png"
                      alt="image-20240223143947558"
                ></p>
</blockquote>
<h4 id="6-4-用户名或密码错误问题"><a href="#6-4-用户名或密码错误问题" class="headerlink" title="6.4 用户名或密码错误问题"></a>6.4 用户名或密码错误问题</h4><blockquote>
<p>连接数据库时，如果用户名或密码输入错误，也会报SQLException，容易混淆！所以一定要看清楚异常后面的原因描述</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202409141006121.png"
                      alt="image-20240223144345939"
                ></p>
</blockquote>
<h4 id="6-5-通信异常"><a href="#6-5-通信异常" class="headerlink" title="6.5 通信异常"></a>6.5 通信异常</h4><blockquote>
<p>在连接数据库的URL中，如果IP或端口写错了，会报如下异常：</p>
<p>com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202409141006389.png"
                      alt="image-20240227234754309"
                ></p>
</blockquote>
<h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><h3 id="七、JDBC扩展"><a href="#七、JDBC扩展" class="headerlink" title="七、JDBC扩展"></a>七、JDBC扩展</h3><h4 id="7-1-实体类和ORM"><a href="#7-1-实体类和ORM" class="headerlink" title="7.1 实体类和ORM"></a>7.1 实体类和ORM</h4><blockquote>
<ul>
<li>在使用JDBC操作数据库时，我们会发现数据都是零散的，明明在数据库中是一行完整的数据，到了Java中变成了一个一个的变量，不利于维护和管理。而我们Java是面向对象的，一个表对应的是一个类，一行数据就对应的是Java中的一个对象，一个列对应的是对象的属性，所以我们要把数据存储在一个载体里，这个载体就是实体类！</li>
<li>ORM（Object Relational Mapping）思想，<strong>对象到关系数据库的映射</strong>，作用是在编程中，把面向对象的概念跟数据库中表的概念对应起来，以面向对象的角度操作数据库中的数据，即一张表对应一个类，一行数据对应一个对象，一个列对应一个属性！</li>
<li>当下JDBC中这种过程我们称其为手动ORM。后续我们也会学习ORM框架，比如MyBatis、JPA等。</li>
</ul>
</blockquote>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.pojo;</span><br><span class="line"><span class="comment">//类名和数据库名对应，但是表名一般缩写，类名要全写！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer empId;<span class="comment">//emp_id = empId 数据库中列名用下划线分隔，属性名用驼峰！</span></span><br><span class="line">    <span class="keyword">private</span> String empName;<span class="comment">//emp_name = empName</span></span><br><span class="line">    <span class="keyword">private</span> Double empSalary;<span class="comment">//emp_salary = empSalary</span></span><br><span class="line">    <span class="keyword">private</span> Integer empAge;<span class="comment">//emp_age = empAge</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略get、set、无参、有参、toString方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>封装代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">querySingleRow</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;  </span><br><span class="line">    <span class="comment">//1.注册驱动  </span></span><br><span class="line">    <span class="comment">// Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//2.获取数据库连接  </span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(  </span><br><span class="line">            <span class="string">&quot;jdbc:mysql://localhost:3306/atguigu&quot;</span>, <span class="string">&quot;root&quot;</span>,<span class="string">&quot;atguigu&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//3.创建PreparedStatement对象，并预编译SQL语句，使用?占位符  </span></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(  </span><br><span class="line">            <span class="string">&quot;select emp_id,emp_name,emp_salary,emp_age from t_emp where emp_id = ?&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//4.为占位符赋值，索引从1开始，执行SQL语句，获取结果  </span></span><br><span class="line">    preparedStatement.setInt(<span class="number">1</span>, <span class="number">1</span>);  </span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();  </span><br><span class="line">    <span class="comment">//预先创建实体类变量  </span></span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="comment">//5.处理结果  </span></span><br><span class="line">    <span class="keyword">while</span> (resultSet.next()) &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">empId</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;emp_id&quot;</span>);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">empName</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;emp_name&quot;</span>);  </span><br><span class="line">        <span class="type">Double</span> <span class="variable">empSalary</span> <span class="operator">=</span> Double.valueOf(resultSet.getString(<span class="string">&quot;emp_salary&quot;</span>));  </span><br><span class="line">        <span class="type">int</span> <span class="variable">empAge</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;emp_age&quot;</span>);  </span><br><span class="line">        <span class="comment">//当结果集中有数据，再进行对象的创建  </span></span><br><span class="line">        employee = <span class="keyword">new</span> <span class="title class_">Employee</span>(empId,empName,empSalary,empAge);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(<span class="string">&quot;employee = &quot;</span> + employee);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//6.释放资源(先开后关原则)  </span></span><br><span class="line">    resultSet.close();  </span><br><span class="line">    preparedStatement.close();  </span><br><span class="line">    connection.close();  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="7-2-主键回显"><a href="#7-2-主键回显" class="headerlink" title="7.2 主键回显"></a>7.2 主键回显</h4><ul>
<li><p>在数据中，执行新增操作时，主键列为自动增长，可以在表中直观的看到，但是在Java程序中，我们执行完新增后，只能得到受影响行数，无法得知当前新增数据的主键值。在Java程序中获取数据库中插入新数据后的主键值，并赋值给Java对象，此操作为主键回显。</p>
</li>
<li><p>代码实现：</p>
</li>
</ul>
 <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testReturnPK</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;  </span><br><span class="line">    <span class="comment">//1.注册驱动  </span></span><br><span class="line">    <span class="comment">//Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//2.获取数据库连接  </span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(</span><br><span class="line">    <span class="string">&quot;jdbc:mysql://localhost:3306/atguigu&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;atguigu&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//3.创建preparedStatement对象，传入需要主键回显参数Statement.RETURN_GENERATED_KEYS  </span></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(</span><br><span class="line">    <span class="string">&quot;insert into t_emp (emp_name, emp_salary, emp_age)values  (?, ?,?)&quot;</span>,</span><br><span class="line">    Statement.RETURN_GENERATED_KEYS);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//4.编写SQL语句并执行，获取结果  </span></span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="literal">null</span>,<span class="string">&quot;rose&quot;</span>,<span class="number">666.66</span>,<span class="number">28</span>);  </span><br><span class="line">    preparedStatement.setString(<span class="number">1</span>,employee.getEmpName());  </span><br><span class="line">    preparedStatement.setDouble(<span class="number">2</span>,employee.getEmpSalary());  </span><br><span class="line">    preparedStatement.setDouble(<span class="number">3</span>,employee.getEmpAge());  </span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> preparedStatement.executeUpdate();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//5.处理结果  </span></span><br><span class="line">    <span class="keyword">if</span>(result&gt;<span class="number">0</span>)&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;添加成功&quot;</span>);  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;添加失败&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//6.获取生成的主键列值，返回的是resultSet，在结果集中获取主键列值  </span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.getGeneratedKeys();  </span><br><span class="line">    <span class="keyword">if</span> (resultSet.next())&#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">empId</span> <span class="operator">=</span> resultSet.getInt(<span class="number">1</span>);  </span><br><span class="line">        <span class="comment">//或者把1替换成GENERATED_KEY，</span></span><br><span class="line">        <span class="comment">//注意这里的表格是数据库驱动返回的生成键的列名`GENERATED_KEY`，而不是你在表中定义的`emp_id`</span></span><br><span class="line">        employee.setEmpId(empId);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(employee.toString());  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//7.释放资源(先开后关原则)  </span></span><br><span class="line">    resultSet.close();  </span><br><span class="line">    preparedStatement.close();  </span><br><span class="line">    connection.close();  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="7-3-批量操作"><a href="#7-3-批量操作" class="headerlink" title="7.3 批量操作"></a>7.3 批量操作</h4><ul>
<li><p>插入多条数据时，一条一条发送给数据库执行，效率低下！</p>
</li>
<li><p>通过批量操作，可以提升多次操作效率！</p>
</li>
<li><p>代码实现：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="comment">//1.注册驱动  </span></span><br><span class="line">    <span class="comment">//        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//2.获取连接  </span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(</span><br><span class="line">    <span class="string">&quot;jdbc:mysql:///atguigu?rewriteBatchedStatements=true&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;atguigu&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//3.编写SQL语句  </span></span><br><span class="line">      <span class="comment">/*  </span></span><br><span class="line"><span class="comment">          注意：1、必须在连接数据库的URL后面追加?rewriteBatchedStatements=true，允许批量操作  </span></span><br><span class="line"><span class="comment">              2、新增SQL必须用values。且语句最后不要追加;结束  </span></span><br><span class="line"><span class="comment">              3、调用addBatch()方法，将SQL语句进行批量添加操作  </span></span><br><span class="line"><span class="comment">              4、统一执行批量操作，调用executeBatch()  </span></span><br><span class="line"><span class="comment">       */</span>    </span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_emp (emp_name,emp_salary,emp_age) values (?,?,?)&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//4.创建预编译的PreparedStatement，传入SQL语句  </span></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//获取当前行代码执行的时间。毫秒值  </span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;  </span><br><span class="line">        <span class="comment">//5.为占位符赋值  </span></span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;marry&quot;</span>+i);  </span><br><span class="line">        preparedStatement.setDouble(<span class="number">2</span>, <span class="number">100.0</span>+i);  </span><br><span class="line">        preparedStatement.setInt(<span class="number">3</span>, <span class="number">20</span>+i);  </span><br><span class="line">  </span><br><span class="line">        preparedStatement.addBatch();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//执行批量操作  </span></span><br><span class="line">    preparedStatement.executeBatch();  </span><br><span class="line">  </span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();  </span><br><span class="line">  </span><br><span class="line">    System.out.println(<span class="string">&quot;消耗时间：&quot;</span>+(end - start));  </span><br><span class="line">  </span><br><span class="line">    preparedStatement.close();  </span><br><span class="line">    connection.close();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="八、连接池"><a href="#八、连接池" class="headerlink" title="八、连接池"></a>八、连接池</h3><h4 id="8-1-现有问题"><a href="#8-1-现有问题" class="headerlink" title="8.1 现有问题"></a>8.1 现有问题</h4><blockquote>
<ul>
<li>每次操作数据库都要获取新连接，使用完毕后就close释放，频繁的创建和销毁造成资源浪费。</li>
<li>连接的数量无法把控，对服务器来说压力巨大。</li>
</ul>
</blockquote>
<h4 id="8-2-连接池"><a href="#8-2-连接池" class="headerlink" title="8.2 连接池"></a>8.2 连接池</h4><blockquote>
<p>连接池就是数据库连接对象的缓冲区，通过配置，由连接池负责创建连接、管理连接、释放连接等操作。</p>
<p>预先创建数据库连接放入连接池，用户在请求时，通过池直接获取连接，使用完毕后，将连接放回池中，避免了频繁的创建和销毁，同时解决了创建的效率。</p>
<p>当池中无连接可用，且未达到上限时，连接池会新建连接。</p>
<p>池中连接达到上限，用户请求会等待，可以设置超时时间。</p>
</blockquote>
<h4 id="8-3-常见连接池"><a href="#8-3-常见连接池" class="headerlink" title="8.3 常见连接池"></a>8.3 常见连接池</h4><p>JDBC 的数据库连接池使用 javax.sql.DataSource接口进行规范，所有的第三方连接池都实现此接口，自行添加具体实现！也就是说，所有连接池获取连接的和回收连接方法都一样，不同的只有性能和扩展功能!</p>
<ul>
<li>DBCP 是Apache提供的数据库连接池，速度相对C3P0较快，但自身存在一些BUG。</li>
<li>C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。</li>
<li>Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能， 稳定性较c3p0差一点</li>
<li><strong>Druid 是阿里提供的数据库连接池，是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，性能、扩展性、易用性都更好，功能丰富</strong>。</li>
<li><strong>Hikari（ひかり[shi ga li]） 取自日语，是光的意思，是SpringBoot2.x之后内置的一款连接池，基于 BoneCP （已经放弃维护，推荐该连接池）做了不少的改进和优化，口号是快速、简单、可靠。</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">主流连接池的功能对比</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202409141006585.png"
                      alt="image-20240228090209040"
                ></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">mock性能数据（单位：ms）</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202409141007938.png"
                      alt="image-20240228205157212"
                ></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">mysql性能数据 (单位：ms)</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202409141007670.png"
                      alt="image-20240228205242420"
                ></td>
</tr>
</tbody></table>
<h4 id="8-4-Druid连接池使用"><a href="#8-4-Druid连接池使用" class="headerlink" title="8.4 Druid连接池使用"></a>8.4 Druid连接池使用</h4><ul>
<li><p>使用步骤：</p>
<ul>
<li>引入jar包。</li>
<li>编码。</li>
</ul>
</li>
<li><p>代码实现：</p>
<ul>
<li><p>硬编码方式（了解）：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHardCodeDruid</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        硬编码：将连接池的配置信息和Java代码耦合在一起。</span></span><br><span class="line"><span class="comment">        1、创建DruidDataSource连接池对象。</span></span><br><span class="line"><span class="comment">        2、设置连接池的配置信息【必须 | 非必须】</span></span><br><span class="line"><span class="comment">        3、通过连接池获取连接对象</span></span><br><span class="line"><span class="comment">        4、回收连接【不是释放连接，而是将连接归还给连接池，给其他线程进行复用】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建DruidDataSource连接池对象。</span></span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">druidDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.设置连接池的配置信息【必须 | 非必须】</span></span><br><span class="line">    <span class="comment">//2.1 必须设置的配置</span></span><br><span class="line">    druidDataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">    druidDataSource.setUrl(<span class="string">&quot;jdbc:mysql:///atguigu&quot;</span>);</span><br><span class="line">    druidDataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    druidDataSource.setPassword(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 非必须设置的配置</span></span><br><span class="line">    druidDataSource.setInitialSize(<span class="number">10</span>);</span><br><span class="line">    druidDataSource.setMaxActive(<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.通过连接池获取连接对象</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> druidDataSource.getConnection();</span><br><span class="line">    System.out.println(connection);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基于connection进行CRUD</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.回收连接</span></span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>软编码方式（推荐）：</p>
<ul>
<li>在项目目录下创建resources文件夹，标识该文件夹为资源目录，创建db.properties配置文件，将连接信息定义在该文件中。</li>
</ul>
 <div class="code-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># druid连接池需要的配置参数，key固定命名</span></span><br><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql:///atguigu</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">atguigu</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">20</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>Java代码：</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResourcesDruid</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="comment">//1.创建Properties集合，用于存储外部配置文件的key和value值。  </span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//2.读取外部配置文件，获取输入流，加载到Properties集合里。  </span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> DruidTest.class  </span><br><span class="line">            .getClassLoader()  </span><br><span class="line">            .getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    properties.load(inputStream);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//3.基于Properties集合构建DruidDataSource连接池  </span></span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(properties);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//4.通过连接池获取连接对象  </span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();  </span><br><span class="line">    System.out.println(connection);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//5.开发CRUD  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//6.回收连接  </span></span><br><span class="line">    connection.close();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<h4 id="8-5-Druid其他配置【了解】"><a href="#8-5-Druid其他配置【了解】" class="headerlink" title="8.5 Druid其他配置【了解】"></a>8.5 Druid其他配置【了解】</h4><table>
<thead>
<tr>
<th>配置</th>
<th><strong>缺省</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td></td>
<td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-” + System.identityHashCode(this)</td>
</tr>
<tr>
<td>jdbcUrl</td>
<td></td>
<td>连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql:&#x2F;&#x2F;10.20.153.104:3306&#x2F;druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td>
</tr>
<tr>
<td>username</td>
<td></td>
<td>连接数据库的用户名</td>
</tr>
<tr>
<td>password</td>
<td></td>
<td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a class="link"   href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter" >https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>driverClassName</td>
<td></td>
<td>根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td>
</tr>
<tr>
<td>initialSize</td>
<td>0</td>
<td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>最大连接池数量</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>已经不再使用，配置了也没效果</td>
</tr>
<tr>
<td>minIdle</td>
<td></td>
<td>最小连接池数量</td>
</tr>
<tr>
<td>maxWait</td>
<td></td>
<td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>-1</td>
<td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td>
</tr>
<tr>
<td>validationQuery</td>
<td></td>
<td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td>
</tr>
<tr>
<td>testOnBorrow</td>
<td>true</td>
<td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td>
</tr>
<tr>
<td>testOnReturn</td>
<td>false</td>
<td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td>
</tr>
<tr>
<td>testWhileIdle</td>
<td>false</td>
<td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td></td>
<td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td>
</tr>
<tr>
<td>numTestsPerEvictionRun</td>
<td></td>
<td>不再使用，一个DruidDataSource只支持一个EvictionRun</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td></td>
</tr>
<tr>
<td>connectionInitSqls</td>
<td></td>
<td>物理连接初始化的时候执行的sql</td>
</tr>
<tr>
<td>exceptionSorter</td>
<td></td>
<td>根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接</td>
</tr>
<tr>
<td>filters</td>
<td></td>
<td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td>
</tr>
<tr>
<td>proxyFilters</td>
<td></td>
<td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td>
</tr>
</tbody></table>
<h4 id="8-6-HikariCP连接池使用"><a href="#8-6-HikariCP连接池使用" class="headerlink" title="8.6 HikariCP连接池使用"></a>8.6 HikariCP连接池使用</h4><ul>
<li><p>使用步骤：</p>
<ul>
<li><p>引入jar包</p>
</li>
<li><p>硬编码方式：</p>
 <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHardCodeHikari</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     硬编码：将连接池的配置信息和Java代码耦合在一起。</span></span><br><span class="line"><span class="comment">     1、创建HikariDataSource连接池对象</span></span><br><span class="line"><span class="comment">     2、设置连接池的配置信息【必须 ｜ 非必须】</span></span><br><span class="line"><span class="comment">     3、通过连接池获取连接对象</span></span><br><span class="line"><span class="comment">     4、回收连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//1.创建HikariDataSource连接池对象</span></span><br><span class="line">    <span class="type">HikariDataSource</span> <span class="variable">hikariDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.设置连接池的配置信息【必须 ｜ 非必须】</span></span><br><span class="line">    <span class="comment">//2.1必须设置的配置</span></span><br><span class="line">    hikariDataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">    hikariDataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql:///atguigu&quot;</span>);</span><br><span class="line">    hikariDataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    hikariDataSource.setPassword(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 非必须设置的配置</span></span><br><span class="line">    hikariDataSource.setMinimumIdle(<span class="number">10</span>);</span><br><span class="line">    hikariDataSource.setMaximumPoolSize(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通过连接池获取连接对象</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> hikariDataSource.getConnection();</span><br><span class="line"></span><br><span class="line">    System.out.println(connection);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回收连接</span></span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>软编码方式：</p>
<ul>
<li><p>在项目下创建resources&#x2F;hikari.properties配置文件</p>
<div class="code-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbcUrl</span>=<span class="string">jdbc:mysql:///atguigu</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">atguigu</span></span><br><span class="line"><span class="attr">minimumIdle</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maximumPoolSize</span>=<span class="string">20</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>编写代码：<br>  <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResourcesHikari</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">         <span class="comment">//1.创建Properties集合，用于存储外部配置文件的key和value值。</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.读取外部配置文件，获取输入流，加载到Properties集合里。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> HikariTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">        properties.load(inputStream);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.创建Hikari连接池配置对象，将Properties集合传进去</span></span><br><span class="line">        <span class="type">HikariConfig</span> <span class="variable">hikariConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>(properties);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 基于Hikari配置对象，构建连接池</span></span><br><span class="line">        <span class="type">HikariDataSource</span> <span class="variable">hikariDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(hikariConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> hikariDataSource.getConnection();</span><br><span class="line">        System.out.println(<span class="string">&quot;connection = &quot;</span> + connection);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.回收连接</span></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="8-7-HikariCP其他配置【了解】"><a href="#8-7-HikariCP其他配置【了解】" class="headerlink" title="8.7 HikariCP其他配置【了解】"></a>8.7 HikariCP其他配置【了解】</h4><table>
<thead>
<tr>
<th>属性</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>isAutoCommit</td>
<td>true</td>
<td>自动提交从池中返回的连接</td>
</tr>
<tr>
<td>connectionTimeout</td>
<td>30000</td>
<td>等待来自池的连接的最大毫秒数</td>
</tr>
<tr>
<td>maxLifetime</td>
<td>1800000</td>
<td>池中连接最长生命周期如果不等于0且小于30秒则会被重置回30分钟</td>
</tr>
<tr>
<td>minimumIdle</td>
<td>10</td>
<td>池中维护的最小空闲连接数 minIdle&lt;0或者minIdle&gt;maxPoolSize，则被重置为maxPoolSize</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>10</td>
<td>池中最大连接数，包括闲置和使用中的连接</td>
</tr>
<tr>
<td>metricRegistry</td>
<td>null</td>
<td>连接池的用户定义名称，主要出现在日志记录和JMX管理控制台中以识别池和池配置</td>
</tr>
<tr>
<td>healthCheckRegistry</td>
<td>null</td>
<td>报告当前健康信息</td>
</tr>
<tr>
<td>poolName</td>
<td>HikariPool-1</td>
<td>连接池的用户定义名称，主要出现在日志记录和JMX管理控制台中以识别池和池配置</td>
</tr>
<tr>
<td>idleTimeout</td>
<td></td>
<td>是允许连接在连接池中空闲的最长时间</td>
</tr>
</tbody></table>
<h2 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h2><h3 id="九、JDBC优化及工具类封装"><a href="#九、JDBC优化及工具类封装" class="headerlink" title="九、JDBC优化及工具类封装"></a>九、JDBC优化及工具类封装</h3><h4 id="9-1-现有问题"><a href="#9-1-现有问题" class="headerlink" title="9.1 现有问题"></a>9.1 现有问题</h4><blockquote>
<p>我们在使用JDBC的过程中，发现部分代码存在冗余的问题：</p>
<ul>
<li>创建连接池。</li>
<li>获取连接。</li>
<li>连接的回收。</li>
</ul>
</blockquote>
<h4 id="9-2-JDBC工具类封装V1-0"><a href="#9-2-JDBC工具类封装V1-0" class="headerlink" title="9.2 JDBC工具类封装V1.0"></a>9.2 JDBC工具类封装V1.0</h4><ul>
<li><p>resources&#x2F;db.properties配置文件：</p>
<div class="code-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># druid连接池需要的配置参数，key固定命名</span></span><br><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">atguigu</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql:///atguigu</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>工具类代码：</p>
 <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	JDBC工具类（V1.0）：</span></span><br><span class="line"><span class="comment">*		1、维护一个连接池对象。</span></span><br><span class="line"><span class="comment">*		2、对外提供在连接池中获取连接的方法</span></span><br><span class="line"><span class="comment">*		3、对外提供回收连接的方法</span></span><br><span class="line"><span class="comment">*	注意：工具类仅对外提供共性的功能代码，所以方法均为静态方法！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCTools</span> &#123;</span><br><span class="line">    <span class="comment">//创建连接池引用，因为要提供给当前项目全局使用，所以创建为静态的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line">    <span class="comment">//在项目启动时，即创建连接池对象，赋值给dataSource</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span>  JDBCTools.getClass()</span><br><span class="line">            .getClassLoader()</span><br><span class="line">            .getSystemResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">            properties.load(inputStream);</span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//对外提供获取连接的静态方法！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//对外提供回收连接的静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        conn.close();<span class="comment">//还给连接池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>注意：此种封装方式，无法保证单个请求连接的线程，多次操作数据库时，连接是同一个，无法保证事务！</p>
</li>
</ul>
<h4 id="9-3-ThreadLocal"><a href="#9-3-ThreadLocal" class="headerlink" title="9.3 ThreadLocal"></a>9.3 ThreadLocal</h4><blockquote>
<p>JDK 1.2的版本中就提供java.lang.ThreadLocal，为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。通常用来在在多线程中管理共享数据库连接、Session等。</p>
<p>ThreadLocal用于保存某个线程共享变量，原因是在Java中，每一个线程对象中都有一个ThreadLocalMap&lt;ThreadLocal， Object&gt;，其key就是一个ThreadLocal，而Object即为该线程的共享变量。</p>
<p>而这个map是通过ThreadLocal的set和get方法操作的。对于同一个static ThreadLocal，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。</p>
<ul>
<li>在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</li>
<li>线程间数据隔离。</li>
<li>进行事务操作，用于存储线程事务信息。</li>
<li>数据库连接，<code>Session</code>会话管理。</li>
</ul>
<p>1、ThreadLocal对象.get: 获取ThreadLocal中当前线程共享变量的值。</p>
<p>2、ThreadLocal对象.set: 设置ThreadLocal中当前线程共享变量的值。</p>
<p>3、ThreadLocal对象.remove: 移除ThreadLocal中当前线程共享变量的值。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202409141007179.png"
                      alt="image-20240223104919548"
                ></p>
<h4 id="9-4-JDBC工具类封装V2-0"><a href="#9-4-JDBC工具类封装V2-0" class="headerlink" title="9.4 JDBC工具类封装V2.0"></a>9.4 JDBC工具类封装V2.0</h4><blockquote>
<p>在V1.0的版本基础上，我们将连接对象放在每个线程的ThreadLocal中，保证从头到尾当前线程操作的是同一连接对象。</p>
</blockquote>
<p>代码实现：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.senior.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  JDBC工具类（V2.0）：</span></span><br><span class="line"><span class="comment"> *      1、维护一个连接池对象、维护了一个线程绑定变量的ThreadLocal对象</span></span><br><span class="line"><span class="comment"> *      2、对外提供在ThreadLocal中获取连接的方法</span></span><br><span class="line"><span class="comment"> *      3、对外提供回收连接的方法，回收过程中，将要回收的连接从ThreadLocal中移除！</span></span><br><span class="line"><span class="comment"> *  注意：工具类仅对外提供共性的功能代码，所以方法均为静态方法！</span></span><br><span class="line"><span class="comment"> *  注意：使用ThreadLocal就是为了一个线程在多次数据库操作过程中，使用的是同一个连接！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtilV2</span> &#123;</span><br><span class="line">    <span class="comment">//创建连接池引用，因为要提供给当前项目的全局使用，所以创建为静态的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在项目启动时，即创建连接池对象，赋值给dataSource</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> JDBCUtil.class.getClassLoader().getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">            properties.load(inputStream);</span><br><span class="line"></span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对外提供在连接池中获取连接的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//在ThreadLocal中获取Connection、</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">            <span class="comment">//threadLocal里没有存储Connection，也就是第一次获取</span></span><br><span class="line">            <span class="keyword">if</span> (connection == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//在连接池中获取一个连接，存储在threadLocal里。</span></span><br><span class="line">                connection = dataSource.getConnection();</span><br><span class="line">                threadLocal.set(connection);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> connection;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对外提供回收连接的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">            <span class="keyword">if</span>(connection!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//从threadLocal中移除当前已经存储的Connection对象</span></span><br><span class="line">                threadLocal.remove();</span><br><span class="line">                <span class="comment">//如果开启了事务的手动提交，操作完毕后，归还给连接池之前，要将事务的自动提交改为true</span></span><br><span class="line">                connection.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">                <span class="comment">//将Connection对象归还给连接池</span></span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>





<h3 id="十、DAO封装及BaseDAO工具类"><a href="#十、DAO封装及BaseDAO工具类" class="headerlink" title="十、DAO封装及BaseDAO工具类"></a>十、DAO封装及BaseDAO工具类</h3><h4 id="10-1-DAO概念"><a href="#10-1-DAO概念" class="headerlink" title="10.1 DAO概念"></a>10.1 DAO概念</h4><blockquote>
<p>DAO：Data Access Object，数据访问对象。</p>
<p>Java是面向对象语言，数据在Java中通常以对象的形式存在。一张表对应一个实体类，一张表的操作对应一个DAO对象！</p>
<p>在Java操作数据库时，我们会将对同一张表的增删改查操作统一维护起来，维护的这个类就是DAO层。</p>
<p>DAO层只关注对数据库的操作，供业务层Service调用，将职责划分清楚！</p>
</blockquote>
<h4 id="10-1-BaseDAO概念"><a href="#10-1-BaseDAO概念" class="headerlink" title="10.1 BaseDAO概念"></a>10.1 BaseDAO概念</h4><blockquote>
<p>基本上每一个数据表都应该有一个对应的DAO接口及其实现类，发现对所有表的操作（增、删、改、查）代码重复度很高，所以可以抽取公共代码，给这些DAO的实现类可以抽取一个公共的父类，复用增删改查的基本操作，我们称为BaseDAO。</p>
</blockquote>
<h4 id="10-2-BaseDAO搭建"><a href="#10-2-BaseDAO搭建" class="headerlink" title="10.2 BaseDAO搭建"></a>10.2 BaseDAO搭建</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseDAO</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    通用的增、删、改的方法</span></span><br><span class="line"><span class="comment">    String sql：sql</span></span><br><span class="line"><span class="comment">    Object... args：给sql中的?设置的值列表，可以是0~n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(String sql,Object... args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">		<span class="comment">//创建PreparedStatement对象，对sql预编译</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCTools.getConnection();</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">        <span class="comment">//设置?占位符的值</span></span><br><span class="line">        <span class="keyword">if</span>(args != <span class="literal">null</span> &amp;&amp; args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i+<span class="number">1</span>,args[i]);<span class="comment">//?的编号从1开始，不是从0开始，数组的下标是从0开始</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行sql</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line">        ps.close();</span><br><span class="line">        <span class="comment">//这里检查下是否开启事务，开启不关闭连接，业务方法关闭!</span></span><br><span class="line">        <span class="comment">//connection.getAutoCommit()为false，不要在这里回收connection，由开启事务的地方回收</span></span><br><span class="line">        <span class="comment">//connection.getAutoCommit()为true，正常回收连接</span></span><br><span class="line">        <span class="comment">//没有开启事务的话，直接回收关闭即可!</span></span><br><span class="line">        <span class="keyword">if</span> (connection.getAutoCommit()) &#123;</span><br><span class="line">            <span class="comment">//回收</span></span><br><span class="line">            JDBCTools.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    通用的查询多个Javabean对象的方法，例如：多个员工对象，多个部门对象等</span></span><br><span class="line"><span class="comment">    这里的clazz接收的是T类型的Class对象，</span></span><br><span class="line"><span class="comment">    如果查询员工信息，clazz代表Employee.class，</span></span><br><span class="line"><span class="comment">    如果查询部门信息，clazz代表Department.class，</span></span><br><span class="line"><span class="comment">    返回List&lt;T&gt; list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; ArrayList&lt;T&gt; <span class="title function_">query</span><span class="params">(Class&lt;T&gt; clazz,String sql,Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//        创建PreparedStatement对象，对sql预编译</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCTools.getConnection();</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">        <span class="comment">//设置?的值</span></span><br><span class="line">        <span class="keyword">if</span>(args != <span class="literal">null</span> &amp;&amp; args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i+<span class="number">1</span>, args[i]);<span class="comment">//?的编号从1开始，不是从0开始，数组的下标是从0开始</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">res</span> <span class="operator">=</span> ps.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        获取结果集的元数据对象。</span></span><br><span class="line"><span class="comment">        元数据对象中有该结果集一共有几列、列名称是什么等信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ResultSetMetaData</span> <span class="variable">metaData</span> <span class="operator">=</span> res.getMetaData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> metaData.getColumnCount();<span class="comment">//获取结果集列数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历结果集ResultSet，把查询结果中的一条一条记录，变成一个一个T 对象，放到list中。</span></span><br><span class="line">        <span class="keyword">while</span>(res.next())&#123;</span><br><span class="line">            <span class="comment">//循环一次代表有一行，代表有一个T对象</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();<span class="comment">//要求这个类型必须有公共的无参构造</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//把这条记录的每一个单元格的值取出来，设置到t对象对应的属性中。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=columnCount; i++)&#123;</span><br><span class="line">                <span class="comment">//for循环一次，代表取某一行的1个单元格的值</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> res.getObject(i);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//这个值应该是t对象的某个属性值</span></span><br><span class="line">                <span class="comment">//获取该属性对应的Field对象</span></span><br><span class="line">                <span class="comment">//String columnName = metaData.getColumnName(i);//获取第i列的字段名</span></span><br><span class="line">                <span class="comment">//这里再取别名可能没办法对应上</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">columnName</span> <span class="operator">=</span> metaData.getColumnLabel(i);<span class="comment">//获取第i列的字段名或字段的别名</span></span><br><span class="line">                <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(columnName);</span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);<span class="comment">//这么做可以操作private的属性</span></span><br><span class="line"></span><br><span class="line">                field.set(t,value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.add(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res.close();</span><br><span class="line">        ps.close();</span><br><span class="line">        <span class="comment">//这里检查下是否开启事务，开启不关闭连接，业务方法关闭!</span></span><br><span class="line">        <span class="comment">//没有开启事务的话，直接回收关闭即可!</span></span><br><span class="line">        <span class="keyword">if</span> (connection.getAutoCommit()) &#123;</span><br><span class="line">            <span class="comment">//回收</span></span><br><span class="line">            JDBCTools.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">queryBean</span><span class="params">(Class&lt;T&gt; clazz,String sql, Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ArrayList&lt;T&gt; list = query(clazz, sql,args);</span><br><span class="line">        <span class="keyword">if</span>(list &lt;mark&gt; <span class="literal">null</span> || list.size() &lt;/mark&gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="10-3-BaseDAO的应用"><a href="#10-3-BaseDAO的应用" class="headerlink" title="10.3 BaseDAO的应用"></a>10.3 BaseDAO的应用</h4><h5 id="10-3-1-创建员工DAO接口"><a href="#10-3-1-创建员工DAO接口" class="headerlink" title="10.3.1 创建员工DAO接口"></a>10.3.1 创建员工DAO接口</h5><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.senior.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.senior.pojo.Employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EmployeeDao这个类对应的是t_emp这张表的增删改查的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmployeeDao</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库对应的查询所有的操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 表中所有的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Employee&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库对应的根据empId查询单个员工数据操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> empId 主键列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个员工对象（一行数据）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Employee <span class="title function_">selectByEmpId</span><span class="params">(Integer empId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库对应的新增一条员工数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> employee ORM思想中的一个员工对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 受影响的行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(Employee employee)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库对应的修改一条员工数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> employee ORM思想中的一个员工对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 受影响的行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(Employee employee)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库对应的根据empId删除一条员工数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> empId 主键列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 受影响的行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(Integer empId)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h5 id="10-3-2-创建员工DAO接口实现类"><a href="#10-3-2-创建员工DAO接口实现类" class="headerlink" title="10.3.2 创建员工DAO接口实现类"></a>10.3.2 创建员工DAO接口实现类</h5><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.senior.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.senior.dao.BaseDAO;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.senior.dao.EmployeeDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.senior.pojo.Employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeDaoImpl</span> <span class="keyword">extends</span> <span class="title class_">BaseDAO</span> <span class="keyword">implements</span> <span class="title class_">EmployeeDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">selectAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT emp_id empId,emp_name empName,emp_salary empSalary,emp_age empAge FROM t_emp&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> executeQuery(Employee.class,sql,<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">selectByEmpId</span><span class="params">(Integer empId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT emp_id empId,emp_name empName,emp_salary empSalary,emp_age empAge FROM t_emp where emp_id = ?&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> executeQueryBean(Employee.class,sql,empId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO t_emp(emp_name,emp_salary,emp_age) VALUES (?,?,?)&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> executeUpdate(sql,employee.getEmpName(),employee.getEmpSalary(),employee.getEmpAge());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE t_emp SET emp_salary = ? WHERE emp_id = ?&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> executeUpdate(sql,employee.getEmpSalary(),employee.getEmpId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(Integer empId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from t_emp where emp_id = ?&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> executeUpdate(sql,empId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h3 id="十一、事务-SQL基本命令-mk-20240915000941-link"><a href="#十一、事务-SQL基本命令-mk-20240915000941-link" class="headerlink" title="十一、事务 [[SQL基本命令#^mk-20240915000941|link]]"></a>十一、事务 [[SQL基本命令#^mk-20240915000941|link]]</h3><h4 id="11-1-事务回顾"><a href="#11-1-事务回顾" class="headerlink" title="11.1 事务回顾"></a>11.1 事务回顾</h4><ul>
<li>数据库事务就是一种SQL语句执行的缓存机制，不会单条执行完毕就更新数据库数据，最终根据缓存内的多条语句执行结果统一判定!   一个事务内所有语句都成功及事务成功，我们可以触发commit提交事务来结束事务，更新数据!   一个事务内任意一条语句失败，即为事务失败，我们可以触发rollback回滚结束事务，数据回到事务之前状态!</li>
<li>一个业务涉及多条修改数据库语句!   例如:<ul>
<li>经典的转账案例，转账业务(A账户减钱和B账户加钱，要一起成功)   </li>
<li>批量删除(涉及多个删除)       </li>
<li>批量添加(涉及多个插入)</li>
</ul>
</li>
<li>事务的特性：<ol>
<li>原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，  要么都不发生。 </li>
<li>一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</li>
<li>隔离性（Isolation）事务的隔离性是指一个事务的执行不能被其他事务干扰，  即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
<li>持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，  接下来的其他操作和数据库故障不应该对其有任何影响</li>
</ol>
</li>
<li>事务的提交方式：<ul>
<li>自动提交：每条语句自动存储一个事务中，执行成功自动提交，执行失败自动回滚! </li>
<li>手动提交:  手动开启事务，添加语句，手动提交或者手动回滚即可!</li>
</ul>
</li>
</ul>
<h4 id="11-2-JDBC中事务实现"><a href="#11-2-JDBC中事务实现" class="headerlink" title="11.2 JDBC中事务实现"></a>11.2 JDBC中事务实现</h4><ul>
<li><p>关键代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    connection.setAutoCommit(<span class="literal">false</span>); <span class="comment">//关闭自动提交了</span></span><br><span class="line">    <span class="comment">//connection.setAutoCommit(false)也就类型于SET autocommit = off</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意，只要当前connection对象，进行数据库操作，都不会自动提交事务</span></span><br><span class="line">    <span class="comment">//数据库动作!</span></span><br><span class="line">    <span class="comment">//prepareStatement - 单一的数据库动作 c r u d </span></span><br><span class="line">    <span class="comment">//connection - 操作事务 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//所有操作执行正确，提交事务！</span></span><br><span class="line">    connection.commit();</span><br><span class="line">  &#125;<span class="keyword">catch</span>(Execption e)&#123;</span><br><span class="line">    <span class="comment">//出现异常，则回滚事务！</span></span><br><span class="line">    connection.rollback();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="11-3-JDBC事务代码实现"><a href="#11-3-JDBC事务代码实现" class="headerlink" title="11.3  JDBC事务代码实现"></a>11.3  JDBC事务代码实现</h4><ul>
<li><p>准备数据库表：</p>
 <div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 继续在atguigu的库中创建银行表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> t_bank(</span><br><span class="line">   id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;账号主键&#x27;</span>,</span><br><span class="line">   account <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;账号&#x27;</span>,</span><br><span class="line">   money  <span class="type">INT</span> UNSIGNED COMMENT <span class="string">&#x27;金额，不能为负值&#x27;</span>) ;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">INSERT INTO</span> t_bank(account,money) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">1000</span>),(<span class="string">&#x27;lisi&#x27;</span>,<span class="number">1000</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>DAO接口代码：</p>
   <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BankDao</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">addMoney</span><span class="params">(Integer id,Integer money)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">subMoney</span><span class="params">(Integer id,Integer money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>DAO实现类代码：</p>
   <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankDaoImpl</span>  <span class="keyword">extends</span> <span class="title class_">BaseDao</span> <span class="keyword">implements</span> <span class="title class_">BankDao</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addMoney</span><span class="params">(Integer id,Integer money)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_bank set money = money + ? where id = ? &quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> executeUpdate(sql,money,id);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subMoney</span><span class="params">(Integer id,Integer money)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_bank set money = money - ? where id = ? &quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> executeUpdate(sql,money,id);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>测试代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">BankDao</span> <span class="variable">bankDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BankDaoImpl</span>();</span><br><span class="line">       Connection connection=<span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.获取连接，将连接的事务提交改为手动提交</span></span><br><span class="line">           connection = JDBCUtilV2.getConnection();</span><br><span class="line">           connection.setAutoCommit(<span class="literal">false</span>);<span class="comment">//开启事务，当前连接的自动提交关闭。改为手动提交！</span></span><br><span class="line"> </span><br><span class="line">           <span class="comment">//2.操作减钱</span></span><br><span class="line">           bankDao.subMoney(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line"> </span><br><span class="line">           <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">           <span class="comment">//3.操作加钱</span></span><br><span class="line">           bankDao.addMoney(<span class="number">2</span>,<span class="number">100</span>);</span><br><span class="line"> </span><br><span class="line">           <span class="comment">//4.前置的多次dao操作，没有异常，提交事务！</span></span><br><span class="line">           connection.commit();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               connection.rollback();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           JDBCUtilV2.release();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>注意：</strong></p>
<blockquote>
<p>当开启事务后，切记一定要根据代码执行结果来决定是否提交或回滚！否则数据库看不到数据的操作结果！</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HttpClient</title>
    <url>/2024/07/18/HttpClient/</url>
    <content><![CDATA[<h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>HttpClient 是Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包，并且它支持HTTP协议最新版本。我们可以使用HttpClient发送各种HTP方法。</p>
<h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><ol>
<li><strong>支持HTTP和HTTPS</strong>：实现HTTP1.0&#x2F;1.1，并支持加密的HTTPS协议（SSL）。</li>
<li><strong>认证方案</strong>：支持多种认证方式（如Basic, Digest, NTLM）及自定义插件认证。</li>
<li><strong>连接管理</strong>：支持多线程应用，最大连接数设置和过期连接自动关闭。</li>
<li><strong>自动处理Cookies</strong>：自动管理Set-Cookie头并支持自定义Cookie策略。</li>
<li><strong>流优化和持久连接</strong>：优化请求&#x2F;响应流，支持HTTP的持久连接（Keep-Alive）。</li>
</ol>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><h4 id="HttpGet请求响应的一般步骤："><a href="#HttpGet请求响应的一般步骤：" class="headerlink" title="HttpGet请求响应的一般步骤："></a>HttpGet请求响应的一般步骤：</h4><ul>
<li><p>创建<code>HttpClient</code>对象，可以使用 <code>HttpClients.createDefault();</code></p>
</li>
<li><p>创建Http请求对象：</p>
<ul>
<li>如果是无参数的GET请求，则直接使用构造方法 <code>HttpGet(String url)</code> 创建 <code>HttpGet</code> 对象即可。</li>
<li>如果是带参数的GET请求，则可以先使用 <code>URIBuilder(String url)</code> 创建对象，再调用 <code>addParameter(String param, String value)</code> ，或 <code>setParameter(String param, String value)</code> 来设置请求参数，并调用 <code>build()</code> 方法构建一个URI 对象。只有构造方法 <code>HttpGet(URI uri)</code> 来构建 HttpGet 对象。</li>
</ul>
</li>
<li><p>创建 <code>HttpResponse</code>，调用 <code>HttpClient</code> 对象的 <code>execute(HttpUriRequest request)</code> 发送请求，该方法返回一个 HttpResponse。调用 HttpResponse 的 <code>getAllHeaders()、getHeaders(String name)</code> 等方法可获取服务器的响应头；调用 HttpResponse 的 <code>getEntity()</code> 方法可以获取 HttpEntity 对象，该对象包装了服务器的响应内容；调用 HttpResponse 的 <code>getStatusLine().getStatusCode()</code>获取响应状态码。</p>
</li>
<li><p>释放连接，包括 HttpResponse、HttpClient</p>
</li>
</ul>
<h4 id="HttpPost请求响应的一般步骤："><a href="#HttpPost请求响应的一般步骤：" class="headerlink" title="HttpPost请求响应的一般步骤："></a>HttpPost请求响应的一般步骤：</h4><ul>
<li>创建<code>HttpClient</code>对象，可以使用 <code>HttpClients.createDefault();</code></li>
<li>创建Http请求对象：<ul>
<li>如果是无参数的POST请求，则直接通过构造方法 <code>HttpPost(String uri)</code> 创建 <code>HttpPost</code> 对象即可。</li>
<li>如果是带参数的POST请求，在创建出 <code>HttpPost</code>对象之后，还需要构建一个 <code>HttpEntity</code> 对象（如 StringEntity, UrlEncodedFormEntity ……<strong>entity接口的实现类</strong>）设置请求参数，然后调用 <code>HttpPost.setEntity(HttpEntity entity)</code> 将 <code>HttpEntity</code> 对象添加到请求中。</li>
</ul>
</li>
<li>创建<code>HttpResponse</code> ，调用 <code>HttpClient</code> 对象的 <code>execute(HttpUriRequest request)</code> 发送请求，该方法返回一个 HttpResponse。调用 HttpResponse 的 <code>getAllHeaders()、getHeaders(String name)</code> 等方法可获取服务器的响应头；调用 HttpResponse 的 <code>getEntity()</code> 方法可以获取 HttpEntity 对象，该对象包装了服务器的响应内容；调用 HttpResponse 的 <code>getStatusLine().getStatusCode()</code>获取响应状态码。</li>
<li>释放连接，包括 HttpResponse、HttpClient</li>
</ul>
<h4 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h4><ol>
<li><strong>引入Maven依赖</strong></li>
</ol>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpasyncclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 请使用最新的稳定版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Jackson 依赖，用于 JSON 处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><strong>Java代码示例</strong></li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpClientExamples</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 无参数 GET 请求</span></span><br><span class="line">        sendGetRequestNoParams();</span><br><span class="line">        <span class="comment">// 带参数 GET 请求</span></span><br><span class="line">        sendGetRequestWithParams();</span><br><span class="line">        <span class="comment">// 无参数 POST 请求</span></span><br><span class="line">        sendPostRequestNoParams();</span><br><span class="line">        <span class="comment">// 带参数 POST 请求，使用 User 对象</span></span><br><span class="line">        sendPostRequestWithUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数 GET 请求示例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendGetRequestNoParams</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClients.createDefault()) &#123;</span><br><span class="line">            <span class="type">HttpGet</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;http://localhost:8080/posts/1&quot;</span>);</span><br><span class="line">            <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpClient.execute(request);</span><br><span class="line">            System.out.println(<span class="string">&quot;GET No Params Response Status: &quot;</span> </span><br><span class="line">                    + response.getStatusLine().getStatusCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;Response Content: &quot;</span> + EntityUtils.toString(response.getEntity()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数 GET 请求示例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendGetRequestWithParams</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClients.createDefault()) &#123;</span><br><span class="line">            <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URIBuilder</span>(<span class="string">&quot;http://localhost:8080/posts&quot;</span>)</span><br><span class="line">                    .addParameter(<span class="string">&quot;userId&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="type">HttpGet</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(uri);</span><br><span class="line">            <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpClient.execute(request);</span><br><span class="line">            System.out.println(<span class="string">&quot;GET With Params Response Status: &quot;</span> </span><br><span class="line">                    + response.getStatusLine().getStatusCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;Response Content: &quot;</span> + EntityUtils.toString(response.getEntity()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数 POST 请求示例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendPostRequestNoParams</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClients.createDefault()) &#123;</span><br><span class="line">            <span class="type">HttpPost</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;http://localhost:8080/posts&quot;</span>);</span><br><span class="line">            <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpClient.execute(request);</span><br><span class="line">            System.out.println(<span class="string">&quot;POST No Params Response Status: &quot;</span> </span><br><span class="line">                    + response.getStatusLine().getStatusCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;Response Content: &quot;</span> + EntityUtils.toString(response.getEntity()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带 User 对象参数的 POST 请求示例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendPostRequestWithUser</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClients.createDefault()) &#123;</span><br><span class="line">            <span class="type">HttpPost</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;http://localhost:8080/posts&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 User 对象</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 User 对象转换为 JSON 字符串</span></span><br><span class="line">            <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">            <span class="type">String</span> <span class="variable">jsonPayload</span> <span class="operator">=</span> objectMapper.writeValueAsString(user);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置 JSON 请求体</span></span><br><span class="line">            <span class="type">StringEntity</span> <span class="variable">entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringEntity</span>(jsonPayload);</span><br><span class="line">            entity.setContentType(<span class="string">&quot;application/json&quot;</span>); <span class="comment">// 标记格式为application/json，http才知道它是json</span></span><br><span class="line">            request.setEntity(entity);</span><br><span class="line"></span><br><span class="line">            <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpClient.execute(request);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;POST With User Object Response Status: &quot;</span> </span><br><span class="line">                    + response.getStatusLine().getStatusCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;Response Content: &quot;</span> + EntityUtils.toString(response.getEntity()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 User 类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Spring 提供了一个 RestTemplate 模板工具类，对基于 Http 的客户端进行了封装，并且实现了对象与 JSON 的序列化与反序列化，非常方便（上面的HttpClient返回的相应是 JSON 格式的）。RestTemplate 并没有限定 Http 客户端类型，而是进行了抽象，目前常用的三种都支持：</p>
<ul>
<li>HttpClient</li>
<li>OKHttp</li>
<li>JDK原生的URLConnection（默认的）</li>
</ul>
<blockquote>
<p>RestTemplate是阻塞式的，性能没有响应式式的 WebClient 优秀</p>
</blockquote>
<h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><ol>
<li><strong>引入Maven依赖</strong></li>
</ol>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Web 依赖，包含 RestTemplate 和其他 Web 相关功能 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><strong>创建配置类</strong></li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span> &#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">(RestTemplateBuilder builder)</span> &#123;</span><br><span class="line">    	<span class="type">HttpComponentsClientHttpRequestFactory</span> <span class="variable">requestFactory</span> <span class="operator">=</span> <span class="keyword">new</span> 			<span class="title class_">HttpComponentsClientHttpRequestFactory</span>(HttpClients.createDefault());</span><br><span class="line">    	requestFactory.setConnectTimeout(<span class="number">5000</span>);  <span class="comment">// 设置连接超时时间，单位为毫秒</span></span><br><span class="line">    	requestFactory.setReadTimeout(<span class="number">10000</span>);   <span class="comment">// 设置读取超时时间，单位为毫秒</span></span><br><span class="line"></span><br><span class="line">    	<span class="keyword">return</span> builder</span><br><span class="line">            .requestFactory(() -&gt; requestFactory)</span><br><span class="line">            .build();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><strong>具体使用</strong></li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GET 请求示例</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getForObjectExample</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> restTemplate.getForObject(url, String.class);</span><br><span class="line">        <span class="keyword">return</span> response; <span class="comment">// 返回 JSON 格式的响应</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// POST 请求示例</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">postForObjectExample</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建请求体</span></span><br><span class="line">        Map&lt;String, Object&gt; requestBody = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        requestBody.put(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        requestBody.put(<span class="string">&quot;body&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        requestBody.put(<span class="string">&quot;userId&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送 POST 请求并接收响应</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> restTemplate.postForObject(url, requestBody, String.class);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li><strong>常用方法</strong></li>
</ol>
<table>
<thead>
<tr>
<th>方法名</th>
<th>请求类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>getForObject</code></td>
<td>GET</td>
<td>获取资源并将响应直接映射为 Java 对象。</td>
</tr>
<tr>
<td><code>getForEntity</code></td>
<td>GET</td>
<td>获取资源，返回 <code>ResponseEntity</code>，包含状态码、头信息和响应体。</td>
</tr>
<tr>
<td><code>postForObject</code></td>
<td>POST</td>
<td>发送请求体，并将响应映射为 Java 对象。</td>
</tr>
<tr>
<td><code>postForEntity</code></td>
<td>POST</td>
<td>发送请求体，返回 <code>ResponseEntity</code>。</td>
</tr>
<tr>
<td><code>put</code></td>
<td>PUT</td>
<td>发送 PUT 请求，无返回值。</td>
</tr>
<tr>
<td><code>delete</code></td>
<td>DELETE</td>
<td>发送 DELETE 请求，无返回值。</td>
</tr>
<tr>
<td><code>exchange</code></td>
<td>多种</td>
<td>提供更灵活的方式发送请求（支持自定义 HTTP 方法、头信息等）。</td>
</tr>
<tr>
<td><code>execute</code></td>
<td>多种</td>
<td>最底层的 HTTP 操作，可完全自定义请求。</td>
</tr>
</tbody></table>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202502132338149.png"
                     
                ></p>
<ol start="5">
<li><strong>使用 <code>exchange</code> 发送自定义请求</strong></li>
</ol>
<p>如果需要添加自定义请求头或使用复杂配置，可以使用 <code>exchange</code> 方法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateCustomExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建请求头</span></span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        headers.setContentType(MediaType.APPLICATION_JSON);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建请求体</span></span><br><span class="line">        Map&lt;String, Object&gt; requestBody = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        requestBody.put(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        requestBody.put(<span class="string">&quot;body&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        requestBody.put(<span class="string">&quot;userId&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建 HttpEntity</span></span><br><span class="line">        HttpEntity&lt;Map&lt;String, Object&gt;&gt; requestEntity = <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(requestBody, headers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送 POST 请求</span></span><br><span class="line">        ResponseEntity&lt;String&gt; responseEntity = restTemplate.exchange(</span><br><span class="line">                url,</span><br><span class="line">                HttpMethod.POST,</span><br><span class="line">                requestEntity,</span><br><span class="line">                String.class</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印响应</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Response Status: &quot;</span> + responseEntity.getStatusCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;Response Body: &quot;</span> + responseEntity.getBody());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="HttpClient及其连接池使用"><a href="#HttpClient及其连接池使用" class="headerlink" title="HttpClient及其连接池使用"></a>HttpClient及其连接池使用</h2><h3 id="1-功能模块"><a href="#1-功能模块" class="headerlink" title="1. 功能模块"></a>1. 功能模块</h3><ol>
<li><strong>HttpClient 接口和实现</strong><ul>
<li><code>HttpClient</code>：这是 Apache HttpClient 的核心接口，定义了执行 HTTP 请求的方法</li>
<li><code>CloseableHttpClient</code>：HttpClient 的主要实现类，提供了对 HTTP 请求的同步执行，并实现了 <code>Closeable</code> 接口，以便在使用完毕后释放资源。</li>
</ul>
</li>
<li><strong>请求与相应</strong><ul>
<li><strong>请求类</strong>：包括 <code>HttpGet</code>、<code>HttpPost</code>、<code>HttpPut</code>、<code>HttpDelete</code> 等，分别用于不同类型的 HTTP 请求。</li>
<li><strong>相应类</strong>：<code>HttpResponse</code> 接口用于表示 HTTP 响应，提供方法获取状态码、响应头和响应体。</li>
<li><strong><code>HttpEntity</code></strong>：表示请求或响应的内容主体，可以是流、字符串、字节数组等。【具体看 entity 接口的实现类】</li>
</ul>
</li>
<li><strong>连接管理</strong><ul>
<li><code>HttpClientConnectionManager</code>：接口用于管理 HTTP 连接的生命周期。</li>
<li><code>PoolingHttpClientConnectionManager</code>：常用的实现类，支持连接池管理，允许连接复用以提高性能，可以配置最大连接数和每个路由的最大连接数。</li>
</ul>
</li>
<li><strong>请求配置</strong><ul>
<li><code>RequestConfig</code>：用于配置请求参数，如连接超时、套接字超时、代理设置、重定向策略等。</li>
<li><code>SocketConfig</code>：用于配置套接字参数，如 TCP_NODELAY 、SO_TIMEOUT 等。</li>
</ul>
</li>
<li><strong>身份认证</strong><ul>
<li><code>CredentialsProvider</code>：用于提供认证信息，支持多种认证机制（Basic、Digest、NTLM、Kerberos）。</li>
<li><code>AuthCache</code>：缓存认证信息，减少重复认证的开销。</li>
</ul>
</li>
<li><strong>重试和重定向</strong><ul>
<li><code>HttpRequestRetryHandler</code>：定义重试策略，处理请求失败后的重试逻辑。</li>
<li><code>RedirectStrategy</code>：管理请求重定向，处理 3xx 响应状态码。</li>
</ul>
</li>
<li><strong>异步处理</strong><ul>
<li><code>HttpAsyncClient</code>：提供异步 HTTP 请求的支持，通过回调接口处理异步请求的结果。</li>
</ul>
</li>
<li><strong>拦截器</strong><ul>
<li><code>HttpRequestInterceptor</code> 和 <code>HttpResponseInterceptor</code>：允许在请求发送前和响应处理前后执行自定义逻辑，提供请求和响应的拦截和修改功能。</li>
</ul>
</li>
<li><strong>Cookie 管理</strong><ul>
<li><code>CookieStore</code>：用于存储和管理 HTTP Cookie。</li>
<li><code>CookieSpec</code>：定义 Cookie 的处理规则。</li>
</ul>
</li>
</ol>
<h3 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h3><ol>
<li><p><strong>连接管理器</strong></p>
<ul>
<li><code>PoolingHTTPClientConnectionManager</code>：用于管理HTTP连接池。通过设置最大连接数和每个路由的最大连接数，确保连接的高效复用。</li>
</ul>
</li>
<li><p><strong>请求配置</strong></p>
<ul>
<li><p>使用 <code>RequestConfig</code> 配置请求的超时时间、包括套接字超时、连接超时和请求超时。这样可以确保在网络条件不佳时，程序不会无限制地等待。</p>
<blockquote>
<ul>
<li><p>套接字超时：数据传输的最大等待时间</p>
</li>
<li><p>连接超时：连接建立的最大等待时间</p>
</li>
<li><p>请求超时：整体请求的最大等待时间</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>HttpClient 实例化</strong></p>
<ul>
<li>使用 <code>HttpClients.custom()</code> 方法创建 <code>CloseableHttpClient</code> 实例，并应用连接管理器和请求配置。</li>
<li><code>CloseableHttpClient</code> 是 <code>HttpClient</code> 的主要实现类，支持资源管理。</li>
</ul>
</li>
<li><p><strong>创建请求</strong></p>
<ul>
<li>创建一个 <code>HttpGet</code> 实例，指定请求的 URL 。在实际应用中，可以根据需要使用 <code>HttpPost</code>、<code>HttpPut</code> 等请求类。</li>
</ul>
</li>
<li><p><strong>执行请求</strong></p>
<ul>
<li>使用 <code>httpClient.execute(httpGet)</code> 方法执行请求，并获取 <code>CloseableHttpResponse</code> 对象。</li>
<li>连接管理器负责分配和管理连接的生命周期。</li>
</ul>
</li>
<li><p><strong>处理响应</strong></p>
<ul>
<li>从 <code>HttpResponse</code> 对象中获取状态行，检查请求是否成功。</li>
<li>使用 <code>EntityUtils.toString(entity)</code> 将响应实体转换为字符串，方便读取和处理响应数据。</li>
</ul>
</li>
<li><p><strong>资源释放</strong></p>
<ul>
<li>使用 <code>try-with-resources</code> 语法，确保 <code>CloseableHttpClient</code> 和 <code>CloseableHttpResponse</code> 在使用完毕后自动关闭，释放系统资源。</li>
</ul>
</li>
</ol>
<p>为了更好地理解 Apache HttpClient 的工作原理，下面将通过一个简单的示例代码来演示其核心组件的使用和工作流程。这段代码将展示如何创建一个 HTTP 客户端，发送 GET 请求，并处理响应。</p>
<ul>
<li><strong>引入Maven依赖</strong></li>
</ul>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 请使用最新的稳定版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>示例代码</strong></li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpClientExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个连接管理器</span></span><br><span class="line">        <span class="type">PoolingHttpClientConnectionManager</span> <span class="variable">connManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PoolingHttpClientConnectionManager</span>();</span><br><span class="line">        connManager.setMaxTotal(<span class="number">100</span>); <span class="comment">// 设置最大连接数</span></span><br><span class="line">        connManager.setDefaultMaxPerRoute(<span class="number">20</span>); <span class="comment">// 每个路由的默认最大连接数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个请求配置</span></span><br><span class="line">        <span class="type">RequestConfig</span> <span class="variable">requestConfig</span> <span class="operator">=</span> RequestConfig.custom()</span><br><span class="line">                .setSocketTimeout(<span class="number">5000</span>) <span class="comment">// 套接字超时</span></span><br><span class="line">                .setConnectTimeout(<span class="number">5000</span>) <span class="comment">// 连接超时</span></span><br><span class="line">                .setConnectionRequestTimeout(<span class="number">5000</span>) <span class="comment">// 请求超时</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个可关闭的 HttpClient 实例，并应用连接管理器和请求配置</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClients.custom()</span><br><span class="line">                .setConnectionManager(connManager)</span><br><span class="line">                .setDefaultRequestConfig(requestConfig)</span><br><span class="line">                .build()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建一个 GET 请求</span></span><br><span class="line">            <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;https://www.example.com&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 执行请求</span></span><br><span class="line">            <span class="keyword">try</span> (<span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpClient.execute(httpGet)) &#123;</span><br><span class="line">                <span class="comment">// 获取响应状态</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Response Status: &quot;</span> + response.getStatusLine());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取响应实体</span></span><br><span class="line">                <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">                <span class="keyword">if</span> (entity != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将响应实体转换为字符串</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">responseBody</span> <span class="operator">=</span> EntityUtils.toString(entity);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Response Body: &quot;</span> + responseBody);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-异步请求"><a href="#3-异步请求" class="headerlink" title="3. 异步请求"></a>3. 异步请求</h3><p>Apache HttpClient 的异步请求功能是通过 <code>HttpAsyncClient</code> 实现的，它使用 Java NIO 的非阻塞 I&#x2F;O 来处理 HTTP 请求。它可以在不阻塞线程的情况下发送和接收请求，满足高并发的需求。</p>
<h4 id="3-1-工作原理"><a href="#3-1-工作原理" class="headerlink" title="3.1 工作原理"></a>3.1 工作原理</h4><ol>
<li><strong>非阻塞 I&#x2F;O</strong><ul>
<li>Apache HttpAsyncClient 使用 Java NIO 来实现非阻塞 I&#x2F;O。请求和响应的处理可以在同一线程中进行，不需要为每一个请求单独分配一个独立的线程。</li>
</ul>
</li>
<li><strong>事件驱动</strong><ul>
<li>通过事件驱动机制处理 I&#x2F;O 操作的完成。请求的完成、失败或取消会触发响应的回调方法。</li>
</ul>
</li>
<li><strong>回调机制</strong><ul>
<li>使用 <code>FutureCallback</code> 接口处理请求的不同结果，包括成功、失败和取消。</li>
</ul>
</li>
</ol>
<h4 id="3-2-调优配置"><a href="#3-2-调优配置" class="headerlink" title="3.2 调优配置"></a>3.2 调优配置</h4><p>为了在高并发环境下实现最佳性能，配置连接管理和线程池是关键。</p>
<ol>
<li><strong>连接管理器</strong><ul>
<li>使用 <code>PollingHttpClientConnectionManager</code> 管理连接池，可以设置最大连接数和每个路由的最大连接数。</li>
</ul>
</li>
<li><strong>IO Reactor 配置</strong><ul>
<li>配置 IO 线程的数量，通常设置为可用处理器的数量，以充分利用多核 CPU 的性能。</li>
</ul>
</li>
<li><strong>线程池</strong><ul>
<li>自定义线程池可以通过 <code>ExecutorService</code> 和 <code>ThreadFactory</code> 来控制异步请求的执行线程数量。</li>
</ul>
</li>
</ol>
<h5 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h5><p><code>PoolingHttpClientConnectionManager</code> 管理连接池，支持连接复用和高效的多线程环境，具体见下文。</p>
<h5 id="IO-Reactor-配置"><a href="#IO-Reactor-配置" class="headerlink" title="IO Reactor 配置"></a>IO Reactor 配置</h5><p><strong>IO Reactor</strong> 是 Apache HttpClient 异步客户端的核心组件之一，主要用于处理网络 I&#x2F;O 操作。它的主要职责包括：</p>
<ul>
<li><strong>事件监听</strong><ul>
<li>IO Reactor 监听网络事件（如连接建立、数据到达等），并触发相应的处理操作。</li>
<li>使用 Java NIO 的 <code>Selector</code> 机制来实现高效的事件驱动。</li>
</ul>
</li>
<li><strong>线程管理</strong><ul>
<li>IO Reactor 通常包含一组 IO 线程，这些线程专门用于处理网络 I&#x2F;O 操作。</li>
<li>这些线程的数量通常设置为可用处理器的数量，以充分利用多核 CPU 的性能</li>
</ul>
</li>
</ul>
<h5 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h5><p><strong>线程池</strong>主要用于管理异步请求的执行线程，它负责：</p>
<ul>
<li><strong>任务调度</strong><ul>
<li>线程池负责调度和执行异步请求的任务。</li>
<li>当一个异步请求被提交到 HttpClient 时，线程池会选择一个线程来执行该请求。</li>
</ul>
</li>
<li><strong>资源管理</strong><ul>
<li>线程池可以限制执行请求的线程数量，防止过多的线程导致系统资源耗尽。</li>
<li>通过设置线程的大小，可以人为控制并发请求的数量。</li>
</ul>
</li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><ul>
<li><strong>引入Maven依赖</strong></li>
</ul>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpasyncclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 请使用最新的稳定版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpcore-nio<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 请使用最新的稳定版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>示例代码</strong></li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncHttpClientExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 配置 IO Reactor</span></span><br><span class="line">        <span class="type">IOReactorConfig</span> <span class="variable">ioReactorConfig</span> <span class="operator">=</span> IOReactorConfig.custom()</span><br><span class="line">                .setIoThreadCount(Runtime.getRuntime().availableProcessors()) <span class="comment">// 设置IO线程数</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接管理器</span></span><br><span class="line">        <span class="type">PoolingNHttpClientConnectionManager</span> <span class="variable">connectionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PoolingNHttpClientConnectionManager</span>(</span><br><span class="line">            			<span class="keyword">new</span> <span class="title class_">DefaultConnectingIOReactor</span>(ioReactorConfig));</span><br><span class="line">        </span><br><span class="line">        connectionManager.setMaxTotal(<span class="number">100</span>); <span class="comment">// 设置最大连接数</span></span><br><span class="line">        connectionManager.setDefaultMaxPerRoute(<span class="number">20</span>); <span class="comment">// 每个路由的默认最大连接数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义线程池</span></span><br><span class="line">        <span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> Executors.defaultThreadFactory();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>, threadFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建异步 HttpClient</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">CloseableHttpAsyncClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpAsyncClients.custom()</span><br><span class="line">                .setConnectionManager(connectionManager)</span><br><span class="line">                .setThreadFactory(threadFactory)</span><br><span class="line">                .setExecutorService(executorService)</span><br><span class="line">                .build()) &#123;</span><br><span class="line">            httpClient.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用 CountDownLatch 等待请求完成</span></span><br><span class="line">            <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 GET 请求</span></span><br><span class="line">            <span class="type">HttpGet</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;https://www.example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行请求并处理回调</span></span><br><span class="line">            httpClient.execute(request, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;HttpResponse&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(HttpResponse response)</span> &#123;</span><br><span class="line">                    <span class="comment">// 请求成功时调用</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Response: &quot;</span> + response.getStatusLine());</span><br><span class="line">                    latch.countDown(); <span class="comment">// 减少计数器</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">                    <span class="comment">// 请求失败时调用</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Request failed: &quot;</span> + ex.getMessage());</span><br><span class="line">                    latch.countDown(); <span class="comment">// 减少计数器</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancelled</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 请求取消时调用</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Request cancelled&quot;</span>);</span><br><span class="line">                    latch.countDown(); <span class="comment">// 减少计数器</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待请求完成</span></span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-连接池"><a href="#4-连接池" class="headerlink" title="4. 连接池"></a>4. 连接池</h3><h4 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h4><p>Apache HttpClient 的连接池通过 <code>PoolingHttpClientConnectionManager</code> 提供高效的连接管理功能。它允许客户端在执行 HTTP 请求时重用连接，以提高性能和资源利用率。</p>
<h4 id="4-2-基本原理"><a href="#4-2-基本原理" class="headerlink" title="4.2 基本原理"></a>4.2 基本原理</h4><ol>
<li><strong>连接复用</strong><ul>
<li>连接池通过维护一个连接集合，允许多个请求重用同一连接，避免每次请求都需要建立和关闭连接的开销。</li>
</ul>
</li>
<li><strong>连接分配</strong><ul>
<li>当一个请求需要发送是，连接池首先检查是否有空闲连接可用。如果有，则直接复用；如果没有，则根据配置创建新的连接。</li>
</ul>
</li>
<li><strong>连接释放</strong><ul>
<li>请求完成后，连接并不立即关闭，而是被释放回池中，以便后续请求使用。</li>
</ul>
</li>
<li><strong>连接过期和验证</strong><ul>
<li>为了避免使用失效的连接，连接池会在连接空闲时间过长时对其进行验证，并根据配置自动清理过期或不再有效的连接。</li>
</ul>
</li>
</ol>
<h4 id="4-3-关键组件和配置"><a href="#4-3-关键组件和配置" class="headerlink" title="4.3 关键组件和配置"></a>4.3 关键组件和配置</h4><ol>
<li><p><code>PoolingHttpClientConnectionManager</code></p>
<ul>
<li>核心连接管理器，负责维护连接池。</li>
<li>提供方法设置总连接数（<code>setMaxTotal</code>）和每个路由的最大连接数（<code>setDefaultMaxPerRoute</code>）。</li>
</ul>
</li>
<li><p><strong>路由（Route）</strong></p>
<ul>
<li>由目标主机、端口和协议组成，用于识别不同的连接路径。</li>
<li>可以为特定路由设置不同的最大连接数。</li>
</ul>
</li>
<li><p><strong>连接保持策略（Keep-Alive Strategy）</strong></p>
<ul>
<li>通过 <code>ConnectionKeepAliveStrategy</code> 确定连接的保持时间。</li>
<li>可以自定义策略，以根据响应头信息动态调整连接的保持时间。</li>
</ul>
</li>
<li><p><strong>连接验证和清理</strong></p>
<ul>
<li>使用 <code>IdleConnectionEvictor</code> 定期检查和清理空闲连接，防止资源浪费。</li>
<li><code>validateAfterInactivity</code> 设置连接空闲时间超过某个阈值后，在使用前需要进行验证。</li>
</ul>
</li>
</ol>
<h4 id="4-4-工作机制"><a href="#4-4-工作机制" class="headerlink" title="4.4 工作机制"></a>4.4 工作机制</h4><ol>
<li><strong>请求到达</strong><ul>
<li>客户端请求到达，连接管理器检查是否有可用的空闲连接。</li>
<li>如果有，则复用空闲连接；否则，根据配置创建新连接。</li>
</ul>
</li>
<li><strong>连接使用</strong><ul>
<li>请求使用连接和服务器进行通信。</li>
<li>完成后，连接被标记为可用，并返回连接池。</li>
</ul>
</li>
<li><strong>连接验证</strong><ul>
<li>在空闲连接重新使用前，连接管理器可能会对其进行验证，以确保连接仍然有效。</li>
</ul>
</li>
<li><strong>连接清理</strong><ul>
<li>定期清理空闲和过期连接，以释放系统资源。</li>
</ul>
</li>
</ol>
<h4 id="4-5-示例代码"><a href="#4-5-示例代码" class="headerlink" title="4.5 示例代码"></a>4.5 示例代码</h4><p>以下是一个示例代码，展示如何配置和使用 Apache HttpClient 的连接池：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpClientConnectionPoolExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建连接池管理器</span></span><br><span class="line">        <span class="type">PoolingHttpClientConnectionManager</span> <span class="variable">connectionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PoolingHttpClientConnectionManager</span>();</span><br><span class="line">        connectionManager.setMaxTotal(<span class="number">50</span>); <span class="comment">// 设置连接池的总最大连接数</span></span><br><span class="line">        connectionManager.setDefaultMaxPerRoute(<span class="number">5</span>); <span class="comment">// 设置每个路由的默认最大连接数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为特定的主机设置最大连接数</span></span><br><span class="line">        <span class="type">HttpHost</span> <span class="variable">targetHost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;www.example.com&quot;</span>, <span class="number">80</span>);</span><br><span class="line">        connectionManager.setMaxPerRoute(<span class="keyword">new</span> <span class="title class_">HttpRoute</span>(targetHost), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置自定义的 ConnectionKeepAliveStrategy</span></span><br><span class="line">        <span class="type">ConnectionKeepAliveStrategy</span> <span class="variable">keepAliveStrategy</span> <span class="operator">=</span> (HttpResponse response, HttpContext context) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 从响应头中获取 Keep-Alive 信息</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">keepAliveDuration</span> <span class="operator">=</span> <span class="number">5</span> * <span class="number">1000</span>; <span class="comment">// 默认 5 秒</span></span><br><span class="line">            <span class="keyword">return</span> keepAliveDuration;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置连接超时时间和读取超时时间</span></span><br><span class="line">        <span class="type">RequestConfig</span> <span class="variable">requestConfig</span> <span class="operator">=</span> RequestConfig.custom()</span><br><span class="line">                .setConnectTimeout(<span class="number">5000</span>)    <span class="comment">// 连接超时时间：5秒</span></span><br><span class="line">                .setSocketTimeout(<span class="number">5000</span>)     <span class="comment">// 读取超时时间：5秒</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 HttpClient 并配置连接管理器、请求配置和保持策略</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClients.custom()</span><br><span class="line">                .setConnectionManager(connectionManager)</span><br><span class="line">                .setDefaultRequestConfig(requestConfig)</span><br><span class="line">                .setKeepAliveStrategy(keepAliveStrategy)</span><br><span class="line">                .build()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建一个 GET 请求</span></span><br><span class="line">            <span class="type">HttpGet</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;http://www.example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行请求</span></span><br><span class="line">            <span class="keyword">try</span> (<span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpClient.execute(request)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Response Status: &quot;</span> + response.getStatusLine());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取响应实体</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">responseBody</span> <span class="operator">=</span> EntityUtils.toString(response.getEntity());</span><br><span class="line">                System.out.println(<span class="string">&quot;Response Body: &quot;</span> + responseBody);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="4-6-作用范围"><a href="#4-6-作用范围" class="headerlink" title="4.6 作用范围"></a>4.6 作用范围</h4><p>和 <code>OkHttp</code> 不同，<code>Apache HttpClient</code> 的连接池不仅可以控制总最大连接数（<code>setMaxTotal</code>），还可以控制每个路由（每个目标主机）的最大连接数（<code>setDefaultMaxPerRoute</code>），甚至还可以为特定的主机或路由指定不同的最大连接数（<code>setMaxPerRoute</code>）。</p>
<p>虽然 <code>OkHttp</code> 控制不了单机的最大连接数，但是有<strong>调度器</strong>（<code>Dispatcher</code>）替代，可以实现单机最大并发请求数控制。而<code>Apache HttpClient</code>中则没有类似<strong>调度器</strong>（<code>Dispatcher</code>）的组件。所以二者各有互补。</p>
<h3 id="5-和-OkHttp-对比"><a href="#5-和-OkHttp-对比" class="headerlink" title="5. 和 OkHttp 对比"></a>5. 和 OkHttp 对比</h3><p>从性能角度来看，OkHttp 和 Apache HttpClient 各有其优劣，具体取决于使用场景和配置。以下是对两者在性能方面的详细对比：</p>
<h4 id="5-1-连接管理和复用"><a href="#5-1-连接管理和复用" class="headerlink" title="5.1. 连接管理和复用"></a>5.1. 连接管理和复用</h4><ul>
<li><p><strong>OkHttp</strong></p>
<ul>
<li><p><strong>连接池</strong>：OkHttp 内置了一个高效的连接池，自动管理连接的生命周期，默认情况下支持 HTTP&#x2F;2 的多路复用，能够显著减少网络延迟。</p>
</li>
<li><p><strong>连接复用</strong>：通过复用连接来减少连接建立的开销，尤其是在高并发场景下，表现出色。</p>
</li>
<li><p><strong>并发性能</strong>：得益于 HTTP&#x2F;2 支持和连接池管理，OkHttp 在处理并发请求时具有较高的吞吐量和低延迟。</p>
</li>
</ul>
</li>
<li><p><strong>Apache HttpClient</strong></p>
<ul>
<li><p><strong>连接池管理</strong>：使用 <code>PoolingHttpClientConnectionManager</code> 进行连接池管理，允许更细粒度的连接配置。</p>
</li>
<li><p><strong>连接复用</strong>：也支持连接复用，但需要手动配置和管理连接池，使用不当可能导致性能瓶颈。</p>
</li>
<li><p><strong>路由控制</strong>：提供对连接路由的详细控制，适合复杂的网络拓扑，但可能增加配置复杂性。</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-2-协议支持"><a href="#5-2-协议支持" class="headerlink" title="5.2. 协议支持"></a>5.2. 协议支持</h4><ul>
<li><p><strong>OkHttp</strong></p>
<ul>
<li><p><strong>HTTP&#x2F;2 支持</strong>：OkHttp 原生支持 HTTP&#x2F;2，能够有效提高并发请求的性能，特别是在长连接和多请求场景下。</p>
</li>
<li><p><strong>WebSocket 支持</strong>：内置支持 WebSocket，可以用于实时通信场景。</p>
</li>
</ul>
</li>
<li><p><strong>Apache HttpClient</strong></p>
<ul>
<li><p><strong>HTTP&#x2F;1.1 支持</strong>：主要支持 HTTP&#x2F;1.1，缺乏对 HTTP&#x2F;2 的原生支持，可能在现代网络应用中表现稍逊。</p>
</li>
<li><p><strong>扩展性</strong>：虽然可以通过第三方库实现 HTTP&#x2F;2 支持，但增加了复杂性和潜在的性能开销。</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-3-异步处理"><a href="#5-3-异步处理" class="headerlink" title="5.3. 异步处理"></a>5.3. 异步处理</h4><ul>
<li><p><strong>OkHttp</strong></p>
<ul>
<li><p><strong>异步请求</strong>：OkHttp 提供了简单易用的异步 API，通过回调机制处理请求和响应，减少了线程管理的开销。</p>
</li>
<li><p><strong>线程池管理</strong>：内置的线程池管理简化了异步请求的调度，提高了异步处理的效率。</p>
</li>
</ul>
</li>
<li><p><strong>Apache HttpClient</strong></p>
<ul>
<li><p><strong>异步请求</strong>：通过 <code>HttpAsyncClient</code> 提供异步请求支持，但配置和使用相对复杂，需要手动管理线程池。</p>
</li>
<li><p><strong>复杂场景</strong>：在复杂的异步场景中可能需要更多的样板代码和配置，增加了开发和维护成本。</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-4-缓存机制"><a href="#5-4-缓存机制" class="headerlink" title="5.4. 缓存机制"></a>5.4. 缓存机制</h4><ul>
<li><p><strong>OkHttp</strong></p>
<ul>
<li><p><strong>内置缓存</strong>：OkHttp 提供了内置的缓存机制，可以自动处理 HTTP 缓存头，减少网络请求次数，提升性能。</p>
</li>
<li><p><strong>灵活的缓存策略</strong>：支持自定义缓存策略，通过拦截器机制实现缓存控制。</p>
</li>
</ul>
</li>
<li><p><strong>Apache HttpClient</strong></p>
<ul>
<li><strong>缓存支持</strong>：需要手动实现缓存机制，Apache HttpClient 不提供开箱即用的缓存支持，增加了实现复杂性。</li>
</ul>
</li>
</ul>
<h4 id="5-5-资源消耗"><a href="#5-5-资源消耗" class="headerlink" title="5.5. 资源消耗"></a>5.5. 资源消耗</h4><ul>
<li><p><strong>OkHttp</strong></p>
<ul>
<li><p><strong>轻量级</strong>：相对较小的内存和 CPU 占用，适合在资源受限的环境（如 Android）中使用。</p>
</li>
<li><p><strong>优化的资源使用</strong>：得益于高效的连接管理和异步处理机制，OkHttp 在资源使用上表现优秀。</p>
</li>
</ul>
</li>
<li><p><strong>Apache HttpClient</strong></p>
<ul>
<li><p><strong>资源消耗</strong>：由于其功能丰富和高度可配置，可能在复杂配置下增加内存和 CPU 占用。</p>
</li>
<li><p><strong>线程安全</strong>：设计为线程安全，但需要合理配置以避免资源浪费。</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-6-总结"><a href="#5-6-总结" class="headerlink" title="5.6. 总结"></a>5.6. 总结</h4><ul>
<li><strong>OkHttp</strong>：<ul>
<li>在现代应用中，尤其是需要 HTTP&#x2F;2 和 WebSocket 支持的场景下，OkHttp 在性能上表现优异。</li>
<li>适合需要高并发处理和低延迟的应用场景，如移动应用和微服务架构。</li>
<li>内置的缓存和异步支持简化了开发，减少了资源消耗。</li>
</ul>
</li>
<li><strong>Apache HttpClient</strong>：<ul>
<li>在需要复杂配置和扩展的场景下，Apache HttpClient 提供了灵活性，但可能在性能上稍逊。</li>
<li>适合在服务器端处理复杂的 HTTP 请求，尤其是需要复杂身份验证和路由控制的场景。</li>
<li>需要手动优化连接管理和异步处理以提升性能。</li>
</ul>
</li>
</ul>
<h2 id="HttpClient工具类模板"><a href="#HttpClient工具类模板" class="headerlink" title="HttpClient工具类模板"></a>HttpClient工具类模板</h2><h3 id="HttpClientUtil-类概述"><a href="#HttpClientUtil-类概述" class="headerlink" title="HttpClientUtil 类概述"></a>HttpClientUtil 类概述</h3><p>该类是一个 HTTP 请求工具类，包含了发送 <code>GET</code> 和 <code>POST</code> 请求的功能，支持普通的表单数据和 JSON 数据的发送。它使用 <code>Apache HttpClient</code> 来执行 HTTP 请求，并通过配置连接超时、读取超时等参数来增强请求的稳定性。</p>
<hr>
<h3 id="代码注释与功能说明"><a href="#代码注释与功能说明" class="headerlink" title="代码注释与功能说明"></a>代码注释与功能说明</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HttpClient工具类，提供了发送GET、POST请求的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpClientUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时时间（5秒）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIMEOUT_MSEC</span> <span class="operator">=</span> <span class="number">5</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送GET方式请求</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     请求的URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paramMap 请求的参数，键值对形式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回响应结果字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">doGet</span><span class="params">(String url, Map&lt;String, String&gt; paramMap)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Httpclient对象</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 构造URL并附加参数</span></span><br><span class="line">            <span class="type">URIBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URIBuilder</span>(url);</span><br><span class="line">            <span class="keyword">if</span> (paramMap != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String key : paramMap.keySet()) &#123;</span><br><span class="line">                    builder.addParameter(key, paramMap.get(key));  <span class="comment">// 添加参数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> builder.build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建GET请求</span></span><br><span class="line">            <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(uri);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送请求</span></span><br><span class="line">            response = httpClient.execute(httpGet);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断响应状态</span></span><br><span class="line">            <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">                result = EntityUtils.toString(response.getEntity(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 确保释放资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.close();</span><br><span class="line">                httpClient.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送POST方式请求（表单数据）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     请求的URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paramMap 请求的参数，键值对形式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回响应结果字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">doPost</span><span class="params">(String url, Map&lt;String, String&gt; paramMap)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建Httpclient对象</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resultString</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建Http Post请求</span></span><br><span class="line">            <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(url);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建参数列表</span></span><br><span class="line">            <span class="keyword">if</span> (paramMap != <span class="literal">null</span>) &#123;</span><br><span class="line">                List&lt;NameValuePair&gt; paramList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; param : paramMap.entrySet()) &#123;</span><br><span class="line">                    paramList.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(param.getKey(), param.getValue()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将参数封装为表单数据</span></span><br><span class="line">                <span class="type">UrlEncodedFormEntity</span> <span class="variable">entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlEncodedFormEntity</span>(paramList);</span><br><span class="line">                httpPost.setEntity(entity);  <span class="comment">// 设置表单数据</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            httpPost.setConfig(builderRequestConfig()); <span class="comment">// 设置请求配置</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行HTTP请求</span></span><br><span class="line">            response = httpClient.execute(httpPost);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取响应内容</span></span><br><span class="line">            resultString = EntityUtils.toString(response.getEntity(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭响应流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送POST方式请求（JSON数据）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     请求的URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paramMap 请求的参数，键值对形式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回响应结果字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">doPost4Json</span><span class="params">(String url, Map&lt;String, String&gt; paramMap)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建Httpclient对象</span></span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClients.createDefault();</span><br><span class="line">        <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resultString</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建Http Post请求</span></span><br><span class="line">            <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(url);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (paramMap != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 构造JSON格式数据</span></span><br><span class="line">                <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; param : paramMap.entrySet()) &#123;</span><br><span class="line">                    jsonObject.put(param.getKey(), param.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">StringEntity</span> <span class="variable">entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringEntity</span>(jsonObject.toString(), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                <span class="comment">// 设置请求内容</span></span><br><span class="line">                entity.setContentEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                entity.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">                httpPost.setEntity(entity);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            httpPost.setConfig(builderRequestConfig()); <span class="comment">// 设置请求配置</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行HTTP请求</span></span><br><span class="line">            response = httpClient.execute(httpPost);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取响应内容</span></span><br><span class="line">            resultString = EntityUtils.toString(response.getEntity(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭响应流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建请求配置，设置连接超时和读取超时</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回配置对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RequestConfig <span class="title function_">builderRequestConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RequestConfig.custom()</span><br><span class="line">                .setConnectTimeout(TIMEOUT_MSEC)  <span class="comment">// 设置连接超时</span></span><br><span class="line">                .setConnectionRequestTimeout(TIMEOUT_MSEC)  <span class="comment">// 设置获取连接超时</span></span><br><span class="line">                .setSocketTimeout(TIMEOUT_MSEC)  <span class="comment">// 设置读取数据超时</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li><strong>发送 GET 请求</strong></li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义请求 URL 和参数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://www.example.com/api&quot;</span>;</span><br><span class="line">Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">params.put(<span class="string">&quot;param1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">params.put(<span class="string">&quot;param2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 doGet 方法发送请求</span></span><br><span class="line"><span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> HttpClientUtil.doGet(url, params);</span><br><span class="line">System.out.println(response);</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><strong>发送 POST 请求（表单数据）</strong></li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义请求 URL 和参数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://www.example.com/api&quot;</span>;</span><br><span class="line">Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">params.put(<span class="string">&quot;param1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">params.put(<span class="string">&quot;param2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 doPost 方法发送 POST 请求</span></span><br><span class="line"><span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> HttpClientUtil.doPost(url, params);</span><br><span class="line">System.out.println(response);</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><strong>发送 POST 请求（JSON 数据）</strong></li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义请求 URL 和参数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://www.example.com/api&quot;</span>;</span><br><span class="line">Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">params.put(<span class="string">&quot;param1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">params.put(<span class="string">&quot;param2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 doPost4Json 方法发送 JSON 格式的 POST 请求</span></span><br><span class="line"><span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> HttpClientUtil.doPost4Json(url, params);</span><br><span class="line">System.out.println(response);</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>doGet</code> 方法用于发送 GET 请求，支持 URL 参数传递。</li>
<li><code>doPost</code> 方法用于发送 POST 请求，支持表单数据。</li>
<li><code>doPost4Json</code> 方法用于发送 POST 请求，支持 JSON 数据格式。</li>
</ul>
<p>这些方法统一返回请求的响应内容（字符串形式）。使用时，只需要调用相应的方法并传入 URL 和参数即可。</p>
]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>工具集</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL配置项</title>
    <url>/2024/07/18/MySQL%E9%85%8D%E7%BD%AE%E9%A1%B9/</url>
    <content><![CDATA[<h3 id="1-rewriteBatchedStatements"><a href="#1-rewriteBatchedStatements" class="headerlink" title="1. rewriteBatchedStatements"></a><strong>1. <code>rewriteBatchedStatements</code></strong></h3><h4 id="功能："><a href="#功能：" class="headerlink" title="功能："></a><strong>功能：</strong></h4><ul>
<li>用于优化批量执行语句，将多次执行的相同SQL语句（带不同参数）<strong>合并为一条SQL语句</strong>，从而减少与数据库的通信次数，提高性能。</li>
<li>常用于<strong>批量插入或更新</strong>场景。</li>
</ul>
<h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a><strong>应用场景：</strong></h4><ul>
<li>当你使用 JDBC 的 <code>addBatch()</code> 和 <code>executeBatch()</code> 方法批量执行语句时，驱动会自动优化：<ul>
<li>将多条<code>INSERT</code>语句合并为单条多值<code>INSERT</code>。</li>
<li>将多条<code>UPDATE</code>语句合并为一个批处理命令（如果语法允许）。</li>
</ul>
</li>
</ul>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a><strong>特点：</strong></h4><ul>
<li><strong>透明性高</strong>：客户端代码无需更改，驱动会自动优化语句。</li>
<li><strong>安全性高</strong>：驱动优化后仍然会遵循数据库的事务管理规则。</li>
<li><strong>限制：</strong> 仅对<strong>批处理操作</strong>有效，不支持一次性执行多条任意SQL语句。</li>
</ul>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h4><p>配置方式：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/testdb?rewriteBatchedStatements=true&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br></pre></td></tr></table></figure></div>

<p>优化前（发送多条单独的SQL语句）：</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> table_name (col1, col2) <span class="keyword">VALUES</span> (<span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;b1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> table_name (col1, col2) <span class="keyword">VALUES</span> (<span class="string">&#x27;a2&#x27;</span>, <span class="string">&#x27;b2&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<p>优化后（合并为一条SQL语句）：</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> table_name (col1, col2) <span class="keyword">VALUES</span> (<span class="string">&#x27;a1&#x27;</span>, <span class="string">&#x27;b1&#x27;</span>), (<span class="string">&#x27;a2&#x27;</span>, <span class="string">&#x27;b2&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="2-allowMultiQueries"><a href="#2-allowMultiQueries" class="headerlink" title="2. allowMultiQueries"></a><strong>2. <code>allowMultiQueries</code></strong></h3><h4 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a><strong>功能：</strong></h4><ul>
<li>允许在<strong>单个SQL语句中执行多条独立的SQL命令</strong>。</li>
<li>常用于需要执行多条不同的SQL语句的场景。</li>
</ul>
<h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a><strong>应用场景：</strong></h4><ul>
<li>当你需要在一次<code>execute()</code>或<code>executeQuery()</code>调用中同时执行多条SQL语句时：<ul>
<li>可以在一条命令中写多条SQL语句，每条语句以<code>;</code>分隔。</li>
</ul>
</li>
<li>适合脚本执行或一次性初始化大量SQL。</li>
</ul>
<h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a><strong>特点：</strong></h4><ul>
<li><strong>灵活性高</strong>：支持任意SQL语句的组合。</li>
<li><strong>潜在安全风险</strong>：容易引发SQL注入问题，因此需特别注意使用参数化查询。</li>
<li><strong>限制：</strong> 不会对批量语句进行优化，语句仍会逐条执行。</li>
</ul>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a><strong>示例：</strong></h4><p>配置方式：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/testdb?allowMultiQueries=true&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br></pre></td></tr></table></figure></div>

<p>多条SQL语句执行：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO table_name (col1, col2) VALUES (&#x27;a1&#x27;, &#x27;b1&#x27;); &quot;</span> +</span><br><span class="line">             <span class="string">&quot;UPDATE table_name SET col2 = &#x27;updated&#x27; WHERE col1 = &#x27;a1&#x27;;&quot;</span>;</span><br><span class="line">stmt.execute(sql);</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="3-区别总结"><a href="#3-区别总结" class="headerlink" title="3. 区别总结"></a><strong>3. 区别总结</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>rewriteBatchedStatements</code></th>
<th><code>allowMultiQueries</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>用途</strong></td>
<td>优化批量执行相同的SQL语句</td>
<td>允许一次执行多条不同SQL语句</td>
</tr>
<tr>
<td><strong>典型应用场景</strong></td>
<td>批量插入、批量更新</td>
<td>脚本执行、SQL初始化、多条独立SQL</td>
</tr>
<tr>
<td><strong>语法要求</strong></td>
<td>使用<code>addBatch()</code>和<code>executeBatch()</code>方法</td>
<td>使用<code>;</code>分隔多条SQL语句</td>
</tr>
<tr>
<td><strong>性能提升</strong></td>
<td>合并多条相同SQL以减少通信次数</td>
<td>不提升性能，逐条执行</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>高，自动优化</td>
<td>低，易受SQL注入攻击影响</td>
</tr>
<tr>
<td><strong>限制</strong></td>
<td>仅适用于批处理</td>
<td>不优化批处理，仅支持多条语句</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-选择建议"><a href="#4-选择建议" class="headerlink" title="4. 选择建议"></a><strong>4. 选择建议</strong></h3><ul>
<li>如果需要<strong>批量操作的性能优化</strong>，如批量插入或更新数据，推荐使用 <strong><code>rewriteBatchedStatements</code></strong>。</li>
<li>如果需要一次性执行<strong>多条独立的SQL语句</strong>（如初始化脚本），推荐使用 <strong><code>allowMultiQueries</code></strong>，但需注意SQL注入风险。</li>
</ul>
<p>通常情况下，两者并不会同时使用，选择适合具体场景的配置即可。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Knife4j</title>
    <url>/2024/07/18/Knife4j/</url>
    <content><![CDATA[<h2 id="Knife4j-使用教程"><a href="#Knife4j-使用教程" class="headerlink" title="Knife4j 使用教程"></a>Knife4j 使用教程</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Knife4j 是基于 springboot 构建的一个文档生成工具，它可以让开发者为我们的应用生成 API 文档，目的是可以更加方便的基于 API 文档进行测试，生成的文档还可以导出，然后给到前端开发团队，前端开发团队可以基于 API 接口写具体的调用。</p>
<h3 id="版本参考"><a href="#版本参考" class="headerlink" title="版本参考"></a>版本参考</h3><p>knife4j 目前主要支持以 Java 开发为主，并且支持 Spring MVC、Spring Boot、Spring Cloud 框架的集成使用。</p>
<p><code>Knife4j</code> 的版本说明：</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1.9.6</td>
<td>蓝色皮肤风格，开始更名，增加更多后端模块</td>
</tr>
<tr>
<td>2.0~2.0.5</td>
<td>Ui 重写，底层依赖的 springfox 框架版本是 2.9.2</td>
</tr>
<tr>
<td>2.0.6~2.0.9</td>
<td>底层 springfox 框架版本升级知 2.10.5，OpenAPI 规范是 v 2</td>
</tr>
<tr>
<td>3.0~3.0.3</td>
<td>底层依赖 springfox 框架版本升级至 3.0.3， OpenAPI 规范是 v 3</td>
</tr>
<tr>
<td>4.0~</td>
<td>4.0 重要版本，提供 OpenAPI 2 和 OpenAPI 3 两种规范供开发者自行选择，主版本统一</td>
</tr>
</tbody></table>
<p><code>Knife4j</code> 的引入要和 <code>Spring Boot</code> 的版本相匹配，所以得首先保证你项目中所使用的 <code>Spring Boot</code> 版本和 <code>Knife4j</code> 的兼容性，以下是版本兼容推荐：</p>
<table>
<thead>
<tr>
<th>Spring Boot 版本</th>
<th>knife4j Swagger 2 规范</th>
<th>knife4j OpenAPI 3 规范</th>
</tr>
</thead>
<tbody><tr>
<td>1.5. x~2.0.0</td>
<td>&lt;Knife4j 2.0.0</td>
<td>&gt;&#x3D;knife4j 4.0.0</td>
</tr>
<tr>
<td>2.0~2.2</td>
<td>knife4j 2.0.0 ~ 2.0.6</td>
<td>&gt;&#x3D;knife4j 4.0.0</td>
</tr>
<tr>
<td>2.2. x~2.4.0</td>
<td>knife4j 2.0.6 ~ 2.0.9</td>
<td>&gt;&#x3D;knife4j 4.0.0</td>
</tr>
<tr>
<td>2.4.0~2.7. x</td>
<td>&gt;&#x3D;knife4j 4.0.0</td>
<td>&gt;&#x3D;knife4j 4.0.0</td>
</tr>
<tr>
<td>&#x3D; 3.0</td>
<td>&gt;&#x3D;knife4j 4.0.0</td>
<td>&gt;&#x3D;knife4j 4.0.0</td>
</tr>
</tbody></table>
<p>如果你不考虑使用 <code>Knife4j</code> 提供的服务端增强功能，引入 <code>Knife4j</code> 的 <code>纯UI版本</code> 没有任何限制，只需要考虑不同的规范即可。</p>
<p><strong>规范说明：</strong></p>
<p>针对 Swagger 2 规范和 OpenAPI 3 规范的说明：</p>
<blockquote>
<p>在 Spring Boot 框架中，knife4j 对于服务端将 Spring 开放接口解析成 Swagger 2 或者 OpenAPI 3 规范的框架，也是依赖的第三方框架组件。说明如下：</p>
<ul>
<li>Swagger 2 规范：依赖 Springfox 项目，该项目目前几乎处于停更状态，但很多老项目依然使用的是该规范，所以 knife4j 在更新前端 UI 的同时也继续保持了兼容性</li>
<li>OpenAPI 3 规范：依赖 Springdoc 项目，更新发版频率非常快，建议开发者尽快迁移过来使用  OpenAPI 3 规范，knife4j 后面的重心也会在这里</li>
</ul>
</blockquote>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="1-导入相关依赖"><a href="#1-导入相关依赖" class="headerlink" title="1. 导入相关依赖"></a>1. 导入相关依赖</h4><p><code>Knife4j</code> 的依赖需要兼容 <code>Spring Boot</code> 的版本，除此之外，有些低版本的 <code>Knife4j</code> 还需要保留 <code>swagger</code> 的相关依赖，并且 <code>Knife4j</code> 的版本要和 <code>springfox</code> 的版本相兼容，但是有些高版本的 <code>Knife4j</code> 是不需要引入 <code>swagger</code> 相关依赖的，例如 <code>3.0.3</code> 版本。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411081024886.png"
                      alt="image-20241108102400665|500"
                ></p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>注意：</strong> 不能与 <code>Swagger2</code> 依赖一起使用，否则会报错</p>
</blockquote>
<h4 id="2-开启-knife4j-配置"><a href="#2-开启-knife4j-配置" class="headerlink" title="2. 开启 knife4j 配置"></a>2. 开启 knife4j 配置</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableKnife4j</span> <span class="comment">// 在新版的 Knife4j 中，一般情况下不再需要手动添加 @EnableKnife4j 注解。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(RedisDemo.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-编写-knife4j-配置"><a href="#3-编写-knife4j-配置" class="headerlink" title="3. 编写 knife4j 配置"></a>3. 编写 knife4j 配置</h4><p><strong>方式一：通过编写配置类</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ApiInfo</span> <span class="variable">apiInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">            .title(<span class="string">&quot;苍穹外卖项目接口文档&quot;</span>)</span><br><span class="line">            .version(<span class="string">&quot;2.0&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;苍穹外卖项目接口文档&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="type">Docket</span> <span class="variable">docket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">            .apiInfo(apiInfo)</span><br><span class="line">            .select()</span><br><span class="line">            .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.sky.controller.admin&quot;</span>))</span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build().groupName(<span class="string">&quot;服务端接口&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> docket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">docket2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ApiInfo</span> <span class="variable">apiInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">            .title(<span class="string">&quot;苍穹外卖项目接口文档&quot;</span>)</span><br><span class="line">            .version(<span class="string">&quot;2.0&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;苍穹外卖项目接口文档&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="type">Docket</span> <span class="variable">docket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">            .apiInfo(apiInfo)</span><br><span class="line">            .select()</span><br><span class="line">            .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.sky.controller.user&quot;</span>))</span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build().groupName(<span class="string">&quot;客户端接口&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> docket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：</strong>. apis (RequestHandlerSelectors.basePackage (“com. sky. controller. user”)) &#x3D;&#x3D; 自行修改</p>
<p><strong>方式二：通过编写 yaml 文件（仅支持 4.1.0 之后）</strong></p>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">openapi:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">黑马商城接口文档</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">&quot;黑马商城接口文档&quot;</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">zhanghuyi@itcast.cn</span></span><br><span class="line">    <span class="attr">concat:</span> <span class="string">虎哥</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://www.itcast.cn</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">group-name:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">api-rule:</span> <span class="string">package</span></span><br><span class="line">        <span class="attr">api-rule-resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.hmall.controller</span> <span class="comment"># 指定自己的controller包</span></span><br></pre></td></tr></table></figure></div>

<h4 id="4-开启静态资源映射"><a href="#4-开启静态资源映射" class="headerlink" title="4. 开启静态资源映射"></a>4. 开启静态资源映射</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WebMvcConfiguration</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span> <span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">//支持 webjars</span></span><br><span class="line">    registry.addResourceHandler (<span class="string">&quot;/webjars/**&quot;</span>)</span><br><span class="line">            .addResourceLocations (<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">    <span class="comment">//支持 swagger</span></span><br><span class="line">    registry.addResourceHandler (<span class="string">&quot;swagger-ui. html&quot;</span>)</span><br><span class="line">            .addResourceLocations (<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>);</span><br><span class="line">    <span class="comment">//支持小刀</span></span><br><span class="line">    registry.addResourceHandler (<span class="string">&quot;doc. html&quot;</span>)</span><br><span class="line">            .addResourceLocations (<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="5-常用注解使用"><a href="#5-常用注解使用" class="headerlink" title="5. 常用注解使用"></a>5. 常用注解使用</h4><ul>
<li><p><code>@API</code>：用于请求的类上，表示对类的说明。</p>
<ul>
<li><p><code>tags</code>：说明该类的作用，可以在前台界面上看到的注解</p>
</li>
<li><p>value：该参数无意义，在 UI 界面上看不到，不需要配置</p>
</li>
</ul>
</li>
</ul>
<p><strong>用法：</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &quot;【测试-方法】&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/e4a75f2cd2bf269389023811e6a3467e.png"
                      alt="在这里插入图片描述"
                ></p>
<p>名称由 <code>test-controller</code> 改为 <code>测试-方法</code>。</p>
<ul>
<li><code>@ApiOperation</code>：该注解用来对某个方法&#x2F;接口进行描述<ul>
<li><code>value</code>：对该操作进行简单的描述</li>
<li><code>notes</code>：对操作的详细描述</li>
<li><code>httpMethod</code>：指定操作使用的 HTTP 方法类型，比如：“GET”、“POST”……但可以直接通过@GetMapping 等来指定，所以使用不多</li>
<li><code>response</code>：指定操作的响应类型，手动设置此属性将覆盖任何自动生成的数据类型。</li>
</ul>
</li>
</ul>
<p><strong>用法：</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/get/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;get-测试方法&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;TestDto&gt; <span class="title function_">testGet</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411081109303.png"
                      alt="image-20241108110907072|700"
                ></p>
<ul>
<li><code>@ApiModel</code>：该注解是作用于 POJO 等实体类上面的，是用来描述类的一些基本信息的。<ul>
<li><code>value</code>：提供类的一个备用名，如果不设置，默认情况下将使用 class 类的名称</li>
<li><code>description</code>：对于类，提供一个详细的描述信息</li>
<li>parent：这个属性用于描述的是类的一些父类信息</li>
<li>discriminator：主要体现在断言当中</li>
<li>subTypes：可以通过这个属性，指定我们想要使用的子类</li>
</ul>
</li>
</ul>
<p><strong>用法：</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(value = &quot;TestDto&quot;, description = &quot;测试dto&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDto</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411081655808.png"
                      alt="image-20241108165508507"
                ></p>
<ul>
<li><code>@ApiParam</code>：用于描述 API 方法的参数信息。它通常用于标注方法参数<ul>
<li><strong><code>value</code></strong>：描述参数的含义或用途。</li>
<li><strong><code>example</code></strong>：提供参数的示例值，帮助开发者理解参数的具体格式或内容。</li>
<li><strong><code>required</code></strong>：指定参数是否为必填项，默认为 <code>false</code>。</li>
<li><strong><code>allowableValues</code></strong>：定义参数的可选值范围，通常用于枚举类型或指定数值区间。</li>
<li><strong><code>dataType</code></strong>：显式指定参数的数据类型（如 <code>String</code>、<code>Integer</code> 等）。通常情况下，Swagger 会自动推断数据类型，但可以通过此属性手动指定。</li>
</ul>
</li>
</ul>
<p><strong>用例：</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ResponseEntity&lt;List&lt;User&gt;&gt; <span class="title function_">getUsers</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@ApiParam(value = &quot;页码&quot;, example = &quot;1&quot;)</span> <span class="meta">@RequestParam</span> <span class="type">int</span> page,</span></span><br><span class="line"><span class="params">    <span class="meta">@ApiParam(value = &quot;每页大小&quot;, example = &quot;10&quot;)</span> <span class="meta">@RequestParam</span> <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<ul>
<li><code>@ApiModelProperty</code>：作用于 POJO 等实体类的属性值上<ul>
<li><p><strong><code>value</code></strong>：提供字段的描述信息，说明该属性的用途或含义。</p>
</li>
<li><p><strong><code>example</code></strong>：指定字段的示例值，便于用户理解字段的数据格式和内容。</p>
</li>
<li><p><strong><code>required</code></strong>：指定字段是否为必填项，默认为 <code>false</code>。设置为 <code>true</code> 时，表明此字段在请求或响应中不可省略。</p>
</li>
<li><p><strong><code>allowableValues</code></strong>：定义字段的可选值，通常用于限定字段值范围，如枚举类型或指定数值区间。</p>
</li>
<li><p><strong><code>position</code></strong>：定义字段在文档中显示的顺序，数值越小，位置越靠前。</p>
</li>
<li><p><strong><code>dataType</code></strong>：指定字段的数据类型，如 <code>String</code>、<code>Integer</code> 等。一般情况下会自动推断，可以手动指定。</p>
</li>
<li><p><strong><code>notes</code></strong>：提供字段的额外说明信息，详细描述或补充字段的相关内容。</p>
</li>
</ul>
</li>
</ul>
<p><strong>用例：</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(value = &quot;TestDto&quot;, description = &quot;测试dto&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDto</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;名称&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;值&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411081706334.png"
                      alt="image-20241108170643923"
                ></p>
<h3 id="网关聚合"><a href="#网关聚合" class="headerlink" title="网关聚合"></a>网关聚合</h3><p>在 <code>Spring Cloud</code> 中，我们可以将每个服务的接口文档全部都整合到 <code>Gateway</code> 中，也就是说我们只要从 <code>Gateway</code> 中打开接口文档就能够很方便的切换查看各个服务的接口文档。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411081717320.png"
                      alt="image-20241108171721971"
                ></p>
<p><strong>操作：</strong></p>
<p><a class="link"   href="https://blog.csdn.net/xhmico/article/details/131701790" >knife4j使用-CSDN博客<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>工具集</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cache</title>
    <url>/2024/07/16/SpringCache/</url>
    <content><![CDATA[<h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><p>Spring Cache 是一个框架，实现了基于 <code>注解</code> 的缓存功能，只需要简单地加一个注解，就能实现缓存功能。</p>
<p>Spring Cache 提供了一层抽象，底层可以切换不同的缓存实现，例如：</p>
<ul>
<li>EHCache</li>
<li>Caffeine</li>
<li>Redis</li>
</ul>
<h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><h4 id="引入Maven依赖"><a href="#引入Maven依赖" class="headerlink" title="引入Maven依赖"></a>引入Maven依赖</h4><ol>
<li><strong>Spring</strong></li>
</ol>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Cache --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 请使用最新的稳定版本 或者 不填版本，让Spring管理版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--提供了更多由 EhCache 或 Caffeine 支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="comment">&lt;!-- 请使用最新的稳定版本 或者 不填版本，让Spring管理版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>**注意：**如果引入了 <code>pring-context-support</code> 依赖，则通常不需要再依赖 <code>spring-context</code>，因为前者已经包含了后者</p>
<ol start="2">
<li><strong>Spring Boot</strong></li>
</ol>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 请使用最新的稳定版本 或者 不填版本，让Spring管理版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>该 Starter 包含了 <em>spring-context-support</em> 模块。</p>
<h4 id="启用缓存"><a href="#启用缓存" class="headerlink" title="启用缓存"></a>启用缓存</h4><p>只需要再任何配置类中添加 <code>@EnableCaching</code> 注解，即可启用缓存功能（推荐在启动类或者相关配置类上）：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCacheConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofMinutes(<span class="number">10</span>)) <span class="comment">// 设置缓存默认过期时间10分钟</span></span><br><span class="line">                .serializeKeysWith(RedisSerializationContext</span><br><span class="line">                                   .SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>()))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext</span><br><span class="line">                                     .SerializationPair.</span><br><span class="line">                                     fromSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RedisCacheManager.builder(redisConnectionFactory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在Spring中，启用缓存后，必须注册一个 <code>cacheManager</code>，这是最基本的设置。</p>
<p>在使用 Spring Boot 时，只需在 <strong>classpath</strong> 上存在 Starter 依赖，并且与 <code>@EnableCaching</code> 注解一起使用，就会注册相同的 <code>ConcurrentMapCacheManager</code>，因此不需要单独的 Bean 声明。还可以使用一个或多个 <code>CacheManagerCustomizer&lt;T&gt;</code> Bean 来自定义 <a class="link"   href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/cache/CacheAutoConfiguration.java" >自动配置<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 的 <code>CacheManager</code>。</p>
</blockquote>
<h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>@EnableCaching</code></td>
<td>开启缓存注解功能，通常加在启动类或者相关的配置类上</td>
</tr>
<tr>
<td><code>@Cacheable</code></td>
<td>在方法执行前查询缓存中是否有数据，如果有数据，则直接返回缓存数据；<br />如果没有缓存数据，调用方法并将方法返回值放到缓存中</td>
</tr>
<tr>
<td><code>@CachePut</code></td>
<td>将方法的返回值放到缓存中</td>
</tr>
<tr>
<td><code>@CacheEvict</code></td>
<td>将一条或多条数据从缓存中删除</td>
</tr>
<tr>
<td><code>@CacheConfig</code></td>
<td>统一配置本类的缓存注解的属性</td>
</tr>
<tr>
<td><code>@Caching</code></td>
<td>组合多个 Cache 注解使用</td>
</tr>
</tbody></table>
<p><strong>@Cacheable&#x2F;@CachePut&#x2F;@CacheEvict 主要的参数</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411110014314.png"
                      alt="image-20241111001419032"
                ></p>
<h3 id="SpEL上下文数据"><a href="#SpEL上下文数据" class="headerlink" title="SpEL上下文数据"></a>SpEL上下文数据</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411110016822.png"
                      alt="image-20241111001659625"
                ></p>
<p><strong>注意：</strong></p>
<p>1.当我们要使用root对象的属性作为key时我们也可以将“#root”省略，因为Spring默认使用的就是root对象的属性。 如：</p>
<ul>
<li><code>@Cacheable(key = &quot;targetClass + methodName +#p0&quot;)</code></li>
</ul>
<p>2.使用方法参数时我们可以直接使用“#参数名”或者“#p参数index”。 如：</p>
<ul>
<li>@Cacheable(value&#x3D;”users”, key&#x3D;”#id”)</li>
<li>@Cacheable(value&#x3D;”users”, key&#x3D;”#p0”)</li>
</ul>
<blockquote>
<p>在实现不同缓存时，SpringCache缓存键值的选取</p>
<ul>
<li><p><strong>Redis</strong>：Spring Cache 在 Redis 中存储的键会是 <code>cacheName::key</code> 的格式，例如 <code>users::123</code>。</p>
</li>
<li><p><strong>Caffeine</strong>：Spring Cache 在 Caffeine 中，通常直接将 <code>@Cacheable</code> 的 <code>key</code>（方法参数）作为缓存的键存储。如 <code>123</code>（没有 <code>cacheName::</code> 前缀）。</p>
</li>
</ul>
</blockquote>
<p><strong>SpEL提供了多种运算符</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411110024744.png"
                      alt="image-20241111002402577"
                ></p>
<h3 id="注解讲解"><a href="#注解讲解" class="headerlink" title="注解讲解"></a>注解讲解</h3><h5 id="CachePut、-Cacheable"><a href="#CachePut、-Cacheable" class="headerlink" title="@CachePut、@Cacheable"></a>@CachePut、@Cacheable</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411110026170.png"
                      alt="image-20241111002636009"
                ></p>
<h5 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h5><p> 主要针对方法配置，能够根据一定的条件对缓存进行清空 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411110028295.png"
                      alt="image-20241111002856159"
                ></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411110029267.png"
                      alt="image-20241111002911173" style="zoom:80%;" 
                >

<h5 id="CacheConfig"><a href="#CacheConfig" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h5><p>当我们需要缓存的地方越来越多，你可以使用<code>@CacheConfig(cacheNames = &#123;&quot;myCache&quot;&#125;)</code>注解来统一指定<code>value</code>的值，这时可省略<code>value</code>，如果你在你的方法依旧写上了<code>value</code>，那么依然以方法的<code>value</code>值为准。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheConfig(cacheNames = &#123;&quot;myCache&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BotRelationServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BotRelationService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Cacheable(key = &quot;targetClass + methodName +#p0&quot;)</span><span class="comment">//此处没写value</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;BotRelation&gt; <span class="title function_">findAllLimit</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> botRelationRepository.findAllLimit(num);</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="Caching"><a href="#Caching" class="headerlink" title="@Caching"></a>@Caching</h5><p>有时候我们可能组合多个Cache注解使用，此时就需要@Caching组合多个注解标签了。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Caching(cacheable = &#123;</span></span><br><span class="line"><span class="meta">        @Cacheable(value = &quot;emp&quot;,key = &quot;#p0&quot;),</span></span><br><span class="line"><span class="meta">        ...</span></span><br><span class="line"><span class="meta">        &#125;,</span></span><br><span class="line"><span class="meta">        put = &#123;</span></span><br><span class="line"><span class="meta">                @CachePut(value = &quot;emp&quot;,key = &quot;#p0&quot;),</span></span><br><span class="line"><span class="meta">        ...</span></span><br><span class="line"><span class="meta">        &#125;,evict = &#123;</span></span><br><span class="line"><span class="meta">        @CacheEvict(value = &quot;emp&quot;,key = &quot;#p0&quot;),</span></span><br><span class="line"><span class="meta">        ....</span></span><br><span class="line"><span class="meta">        &#125;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="整合-Caffeine"><a href="#整合-Caffeine" class="headerlink" title="整合 Caffeine"></a>整合 Caffeine</h2><p>在 Spring Cache 中整合 Caffeine 可以通过以下步骤实现：</p>
<h3 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h3><p>在你的 <code>pom.xml</code> 中添加 Caffeine 依赖：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 使用最新版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-配置-application-yml"><a href="#2-配置-application-yml" class="headerlink" title="2. 配置 application.yml"></a>2. 配置 application.yml</h3><p>在 <code>application.yml</code> 中配置 Spring Cache 和 Caffeine 的参数：</p>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">caffeine</span></span><br><span class="line">    <span class="attr">caffeine:</span></span><br><span class="line">      <span class="attr">spec:</span> <span class="string">maximumSize=1000,expireAfterWrite=5m</span></span><br></pre></td></tr></table></figure></div>

<p>这里的 <code>spec</code> 定义了 Caffeine 的缓存策略，可以指定：</p>
<ul>
<li><code>maximumSize</code>：缓存的最大条目数</li>
<li><code>expireAfterWrite</code>：写入后到期时间（例如：5分钟）</li>
</ul>
<h3 id="3-配置-CaffeineCacheManager（可选）"><a href="#3-配置-CaffeineCacheManager（可选）" class="headerlink" title="3. 配置 CaffeineCacheManager（可选）"></a>3. 配置 CaffeineCacheManager（可选）</h3><p>如果需要更精细的控制，可以创建一个配置类，用于配置 <code>CaffeineCacheManager</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Caffeine;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.caffeine.CaffeineCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CaffeineCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaffeineCacheManager</span>();</span><br><span class="line">        cacheManager.setCaffeine(caffeineCacheBuilder());</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Caffeine&lt;Object, Object&gt; <span class="title function_">caffeineCacheBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Caffeine.newBuilder()</span><br><span class="line">                .expireAfterWrite(<span class="number">5</span>, TimeUnit.MINUTES)</span><br><span class="line">                .maximumSize(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个配置类定义了一个 CaffeineCacheManager 并设置了缓存策略，可以替代 <code>application.yml</code> 中的 <code>spec</code> 配置方式。</p>
<h3 id="4-使用-Cacheable-注解"><a href="#4-使用-Cacheable-注解" class="headerlink" title="4. 使用 @Cacheable 注解"></a>4. 使用 @Cacheable 注解</h3><p>在需要缓存的方法上使用 <code>@Cacheable</code> 注解。例如：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;users&quot;, key = &quot;#userId&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设这里是一个耗时的数据库查询</span></span><br><span class="line">        <span class="keyword">return</span> findUserByIdFromDatabase(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，当调用 <code>getUserById</code> 方法时，结果会被缓存到 <code>users</code> 缓存中，<code>key</code> 是 <code>userId</code>。下一次调用相同参数时会直接从缓存中获取数据，而不是再次调用方法。</p>
<h3 id="5-常用注解"><a href="#5-常用注解" class="headerlink" title="5. 常用注解"></a>5. 常用注解</h3><ul>
<li><code>@Cacheable</code>：用于标注需要缓存的方法。</li>
<li><code>@CachePut</code>：每次调用时强制更新缓存。</li>
<li><code>@CacheEvict</code>：清除指定缓存。</li>
</ul>
<h2 id="整合-Redis"><a href="#整合-Redis" class="headerlink" title="整合 Redis"></a>整合 Redis</h2><p>在 Spring Cache 中整合 Redis，可以通过以下步骤完成：</p>
<h3 id="1-添加依赖-1"><a href="#1-添加依赖-1" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h3><p>在 <code>pom.xml</code> 中添加 Spring Data Redis 依赖：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-配置-application-yml-1"><a href="#2-配置-application-yml-1" class="headerlink" title="2. 配置 application.yml"></a>2. 配置 application.yml</h3><p>在 <code>application.yml</code> 中配置 Redis 的连接信息和 Spring Cache 的类型为 Redis：</p>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="number">600000</span>  <span class="comment"># 默认缓存超时时间为10分钟（单位为毫秒）</span></span><br><span class="line">      <span class="attr">cache-null-values:</span> <span class="literal">true</span>  <span class="comment"># 是否缓存空值</span></span><br><span class="line">      <span class="attr">key-prefix:</span> <span class="string">&quot;myapp::&quot;</span>  <span class="comment"># 设置 Redis 键的前缀</span></span><br><span class="line">      <span class="attr">use-key-prefix:</span> <span class="literal">true</span>   <span class="comment"># 启用键前缀</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span>          <span class="comment"># Redis 服务器地址</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span>               <span class="comment"># Redis 服务器端口</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yourpassword</span>   <span class="comment"># Redis 密码（如果有的话）</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span>        <span class="comment"># 连接池最大连接数</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span>          <span class="comment"># 连接池最大空闲连接数</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span>          <span class="comment"># 连接池最小空闲连接数</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">6000ms</span>          <span class="comment"># 连接超时时间</span></span><br></pre></td></tr></table></figure></div>

<h3 id="3-配置-RedisCacheManager（可选）"><a href="#3-配置-RedisCacheManager（可选）" class="headerlink" title="3. 配置 RedisCacheManager（可选）"></a>3. 配置 RedisCacheManager（可选）</h3><p>如果需要自定义 Redis 缓存配置，可以通过配置类自定义 <code>RedisCacheManager</code>，例如设置缓存的默认超时时间：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCacheConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofMinutes(<span class="number">10</span>)) <span class="comment">// 设置缓存默认过期时间10分钟</span></span><br><span class="line">                .serializeKeysWith(RedisSerializationContext</span><br><span class="line">                                   .SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>()))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext</span><br><span class="line">                                     .SerializationPair</span><br><span class="line">                                     .fromSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RedisCacheManager.builder(redisConnectionFactory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-使用-Cacheable-注解-1"><a href="#4-使用-Cacheable-注解-1" class="headerlink" title="4. 使用 @Cacheable 注解"></a>4. 使用 @Cacheable 注解</h3><p>在需要缓存的方法上使用 <code>@Cacheable</code> 注解。例如：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;users&quot;, key = &quot;#userId&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设这是一个耗时的数据库查询</span></span><br><span class="line">        <span class="keyword">return</span> findUserByIdFromDatabase(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，当调用 <code>getUserById</code> 方法时，结果会被缓存到 Redis 的 <code>users</code> 缓存中，<code>key</code> 是 <code>userId</code>。下一次调用相同参数时会直接从缓存中获取数据，而不是再次调用方法。</p>
<h3 id="5-常用注解-1"><a href="#5-常用注解-1" class="headerlink" title="5. 常用注解"></a>5. 常用注解</h3><ul>
<li><code>@Cacheable</code>：用于标注需要缓存的方法。</li>
<li><code>@CachePut</code>：每次调用时强制更新缓存。</li>
<li><code>@CacheEvict</code>：清除指定缓存。</li>
</ul>
<h3 id="何时使用-Java-配置类？"><a href="#何时使用-Java-配置类？" class="headerlink" title="何时使用 Java 配置类？"></a>何时使用 Java 配置类？</h3><p>​    如果需要更复杂的配置，比如特定缓存的不同超时时间或自定义序列化器（如 JSON 序列化），则需要使用 Java 配置类。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>缓存数据的过期时间</strong>：可以通过 <code>RedisCacheConfiguration</code> 的 <code>entryTtl</code> 方法来设置默认的过期时间。</li>
<li><strong>序列化</strong>：在配置中，我们使用 <code>GenericJackson2JsonRedisSerializer</code> 作为值的序列化器，以支持对象序列化为 JSON。</li>
</ul>
]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>工具集</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Task</title>
    <url>/2024/07/18/Spring%20Task/</url>
    <content><![CDATA[<h2 id="Spring-Task"><a href="#Spring-Task" class="headerlink" title="Spring Task"></a>Spring Task</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Spring Task 是 Spring 框架提供的任务调度工具，可以 <strong>按照约定的时间自动执行某个代码逻辑</strong></p>
<ul>
<li><strong>定位</strong><ul>
<li>定时任务框架（单体架构下）</li>
</ul>
</li>
<li><strong>应用场景</strong><ul>
<li>信用卡每月还款提醒</li>
<li>银行贷款每月还款提醒</li>
<li>入职纪念日为用户发送通知</li>
</ul>
</li>
</ul>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ol>
<li><strong>导入 Maven 坐标 spring-context（已存在）</strong></li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411111700810.png"
                      alt="image-20241111170000555" style="zoom:50%;" 
                >

<ol start="2">
<li><strong>在启动类上添加注解 <code>@EnableScheduling</code> 开启任务调度</strong></li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskApplication</span> &#123;   </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  	 </span><br><span class="line">		SpringApplication.run(TaskApplication.class, args);  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><strong>通过 <code>@Scheduled</code> 注解方式自定义定时任务</strong></li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledBean</span> &#123;</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/5 * * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLog</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>重启服务：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411111704414.png"
                      alt="image-20241111170441188"
                ></p>
<hr>
<h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><p>以上是基本使用，还可配置一些通用配置，如下：</p>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">task:</span></span><br><span class="line">    <span class="attr">scheduling:</span></span><br><span class="line">      <span class="comment"># 任务调度线程池的核心线程数大小，默认是 1</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">size:</span> <span class="number">1</span></span><br><span class="line">      <span class="comment"># 任务调度线程池的线程名称前缀，默认是 scheduling-</span></span><br><span class="line">      <span class="attr">thread-name-prefix:</span> <span class="string">ssm_</span></span><br><span class="line">      <span class="attr">shutdown:</span></span><br><span class="line">        <span class="comment"># 线程池关闭时，是否等待所有任务完成</span></span><br><span class="line">        <span class="attr">await-termination:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 调度线程关闭前最大等待时间，确保最后一定关闭 (如果等待，最多等几秒)</span></span><br><span class="line">        <span class="attr">await-termination-period:</span> <span class="string">10s</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Scheduled-注解"><a href="#Scheduled-注解" class="headerlink" title="@Scheduled 注解"></a>@Scheduled 注解</h3><p>@Scheduled 注解的常用属性：</p>
<ul>
<li><p><strong>cron</strong>：cron 表达式，具体语法：<a class="link"   href="https://blog.csdn.net/llg___/article/details/133581984" >cron 表达式语法<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，cron 在线表达式生成器：<a class="link"   href="https://cron.ciding.cc/" >https://cron.ciding.cc/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<ul>
<li>cron 表达式其实就是一个字符串，通过 cron 表达式可以 <strong>定义任务触发的时间</strong>。构成规则：分为 6 或 7 个域，由空格分隔开，每个域代表一个含义，分别为：秒、分钟、小时、日、月、周、年(可选) 【日和周一般不能同时设置】</li>
</ul>
</li>
<li><p><strong>fixedDelay</strong>：固定延迟。从上次任务执行结束的时间开始，到下一个任务开始的时间间隔。不关心任务逻辑、任务本身执行多长时间。下图为 fixedDelay 为 4s 的示意图：</p>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411111735147.png"
                      alt="image-20241111173558035" style="zoom:50%;" 
                >

<ul>
<li><strong>fixedRate</strong>：固定频率。在理想情况下，下一次开始和上一次开始之间的时间间隔是一定的，但当如果上一次任务因为其他原因超时好久，而 pool.size 的默认值为 1，即默认情况下 Spring Boot 定时任务是单线程执行的，那下一轮任务就会被阻塞。类比地铁每隔 10 分钟发一列，也就是说所有列车其实已经安排好了时刻表，理想情况下，每列车准点发就行了，互不影响，但是如果其中一列晚点，那么就会导致下一列晚点。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411111738931.png"
                      alt="image-20241111173830752" style="zoom:50%;" 
                >

<ul>
<li><strong>initialDelay</strong>：初始化延迟时间，也就是第一次延迟执行的时间。这个参数对 cron 属性无效，只能配合 fixedDelay 或 fixedRate 使用。如 @Scheduled(initialDelay &#x3D; 5000, fixedDelay &#x3D; 1000) 表示第一次延迟 5000 毫秒执行，下一次任务在上一次任务结束后 1000 毫秒后执行。</li>
</ul>
<blockquote>
<p>fixedDelay 和 fixedRate，都是和两轮任务有关，但 <code>前者关注的是第一轮的结束时间和第二轮的开始时间的这个间隔。而后者关注的都是两轮的开始时间中间的这个间隔。</code></p>
</blockquote>
<h3 id="Spring-Task-单线程下的阻塞问题"><a href="#Spring-Task-单线程下的阻塞问题" class="headerlink" title="Spring Task 单线程下的阻塞问题"></a>Spring Task 单线程下的阻塞问题</h3><p>demo 代码，演示两个任务在单线程下的阻塞：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上一次任务执行完后，歇一秒，再执行下一轮</span></span><br><span class="line"><span class="comment">     * 执行一次任务耗时5秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedDelay = 1000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    </span><br><span class="line">        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">&quot;&lt;mark&gt;&gt;  spring task 1 &lt;/mark&gt;&gt; &quot;</span></span><br><span class="line">                + LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;</span>))</span><br><span class="line">        );</span><br><span class="line">                </span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下轮任务在上一轮任务开始后2秒执行.</span></span><br><span class="line"><span class="comment">     * 执行一次任务耗时可忽略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 2000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">&quot;&lt;mark&gt;&gt;  spring task2 &lt;/mark&gt;&gt; &quot;</span></span><br><span class="line">                + LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;</span>))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>执行效果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411111744916.png"
                      alt="image-20241111174456740"
                ></p>
<p>可以看到 task2 被连续执行三次，且不妙的是两次任务开始时间没有间隔 2s。这就是单线程下阻塞导致的问题，task1 执行的 5 秒内，task2 按预定的间隔触发的任务被阻塞，等 task1 一执行完，就会立刻执行这些阻塞的任务。这个延迟和堆积在生产中还是很严重的。</p>
<h3 id="Spring-Task-阻塞问题的处理思路"><a href="#Spring-Task-阻塞问题的处理思路" class="headerlink" title="Spring Task 阻塞问题的处理思路"></a>Spring Task 阻塞问题的处理思路</h3><p><strong>第一种是直接改配置文件：</strong></p>
<p>既然问题在单线程，一个线程处理不过来而导致的问题，那让定时任务的执行改为多线程就行了：</p>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">task:</span></span><br><span class="line">    <span class="attr">scheduling:</span></span><br><span class="line">      <span class="comment"># 任务调度线程池的核心线程数大小，默认是 1</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">size:</span> <span class="number">1</span></span><br><span class="line">        <span class="comment"># 像上面的demo，设size为2即可 </span></span><br></pre></td></tr></table></figure></div>

<p><strong>第二种是定义配置类，实现 SchedulingConfigurer 接口，设置 taskScheduler：</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleConfig</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;</span><br><span class="line">        <span class="comment">//设定一个长度10的定时任务线程池，这个大小自己判断</span></span><br><span class="line">        taskRegistrar.setScheduler(Executors.newScheduledThreadPool(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>第三种是加@Async 注解开启异步任务：</strong></p>
<p>启动类加 <code>@EnableAsyn</code> 开启注解支持 c，在定时任务方法上加入注解 <code>@Async</code></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="meta">@Schedule(...)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task1</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="meta">@Schedule(...)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task2</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果有@Async 这个注解的额外配置需求，参考：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非必须，看自己需求</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">taskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">poolTaskExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">    poolTaskExecutor.setCorePoolSize(<span class="number">4</span>);</span><br><span class="line">    poolTaskExecutor.setMaxPoolSize(<span class="number">6</span>);</span><br><span class="line">    <span class="comment">// 设置线程活跃时间（秒）</span></span><br><span class="line">    poolTaskExecutor.setKeepAliveSeconds(<span class="number">120</span>);</span><br><span class="line">    <span class="comment">// 设置队列容量</span></span><br><span class="line">    poolTaskExecutor.setQueueCapacity(<span class="number">40</span>);</span><br><span class="line">    poolTaskExecutor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">    <span class="comment">// 等待所有任务结束后再关闭线程池</span></span><br><span class="line">    poolTaskExecutor.setWaitForTasksToCompleteOnShutdown(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> poolTaskExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Spring-Task-在分布式环境中"><a href="#Spring-Task-在分布式环境中" class="headerlink" title="Spring Task 在分布式环境中"></a>Spring Task 在分布式环境中</h3><p>Spring Task 并不是为分布式环境设计的，在分布式环境下，这种定时任务是不支持集群配置的，如果部署到多个节点上，各个节点之间并没有任何协调通讯机制，集群的节点之间是不会共享任务信息的，每个节点上的任务都会按时执行，导致任务的重复执行。我们可以使用支持分布式的定时任务调度框架，比如 <strong>Quartz、XXL-Job、Elastic Job</strong>。也可以借助 <strong>zookeeper、redis</strong>等实现分布式锁来处理各个节点的协调问题。或者把所有的定时任务抽成单独的服务单独部署。</p>
]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>工具集</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记</title>
    <url>/2024/03/16/Linux/</url>
    <content><![CDATA[<h2 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h2><h3 id="1-路径和特殊IP"><a href="#1-路径和特殊IP" class="headerlink" title="1 路径和特殊IP"></a>1 路径和特殊IP</h3><h4 id="1-1-基本路径"><a href="#1-1-基本路径" class="headerlink" title="1.1 基本路径"></a>1.1 基本路径</h4><ul>
<li><strong>绝对路径</strong>：以<code>根目录为起点</code>，描述路径的一种写法，路径描述以<code>/</code>开头</li>
<li><strong>相对路径</strong>：以<code>当前目录为起点</code>，描述路径的一种写法，路径不需要以<code>/</code>开头</li>
</ul>
<h4 id="1-2-特殊路径符"><a href="#1-2-特殊路径符" class="headerlink" title="1.2 特殊路径符"></a>1.2 特殊路径符</h4><ul>
<li><code>.</code>：表示当前目录，比如<code>cd ./Desktop</code>表示切换到当前目录下的Desktop目录内，与<code>cd Desktop</code>效果一致</li>
<li><code>..</code>：表示上一级目录，比如<code>cd ..</code>即可切换到上一级目录，<code>cd ../..</code>切换到上二级的目录</li>
<li><code>~</code>：表示home目录，比如<code>cd ~</code>即可切换到home目录,<code>cd ~/Desktop</code>,切换到home内的Desktop目录</li>
</ul>
<blockquote><p>练习：<br>    <strong>当前工作目录内有一个test文件夹，文件夹内有一个文件hello.txt,描述文件的相对路径：</strong><br>    test&#x2F;hello.txt<br>    <strong>在当前工作目录的上级目录有一个test文件夹，文件夹内有一个文件hello.txt,描述文件的相对路径：</strong><br>    ..&#x2F;test&#x2F;hello.txt<br>    <strong>在home目录内有一个test文件夹，文件夹内有一个文件hello.txt,描述文件的相对路径：</strong><br>    ~&#x2F;test&#x2F;hello.txt</p>
</blockquote>
<h4 id="1-3-特殊IP地选"><a href="#1-3-特殊IP地选" class="headerlink" title="1.3 特殊IP地选"></a>1.3 特殊IP地选</h4><ul>
<li><code>127.0.0.1</code>：指代本机</li>
<li><code>0.0.0.0</code>：<ul>
<li>可以用于指代本机</li>
<li>可以在端口绑定中来确定绑定关系</li>
<li>在一些IP地址限制中，表示所有IP的意思，如放行规则设置为0.0.0.0，表示允许任意IP访问</li>
</ul>
</li>
</ul>
<h4 id="1-4-主机名"><a href="#1-4-主机名" class="headerlink" title="1.4 主机名"></a>1.4 主机名</h4><p><code>hostname</code>:查看主机名<br><code>hostnamectl set-hostname 新名字</code>：修改主机名[更改主机名字，需要root]</p>
<h3 id="2-Linux命令基础"><a href="#2-Linux命令基础" class="headerlink" title="2 Linux命令基础"></a>2 Linux命令基础</h3><h4 id="2-1-ls-展示内容"><a href="#2-1-ls-展示内容" class="headerlink" title="2.1 ls(展示内容)"></a>2.1 ls(展示内容)</h4><ul>
<li><code>ls</code>：展示当前工作目录(默认是home目录)下的内容(文件&#x2F;文件夹)</li>
<li>用法：<code>ls [-a -l -h] [Linux路径]</code><br>  <code>-a</code>:可以展示出隐藏的内容(<strong>以.开头的文件或文件夹默认被隐藏，需要-a才能显示出来</strong>)<br>  <code>-l</code>:以列表的形式展开内容，展示更多细节(存在缩写:<code>ls -l</code>&lt;&#x3D;&gt;<code>ll</code>)<br>  <code>-h</code>:需要和-l选项搭配使用，以展示更加人性化的文件大小单位<br>  <code>没有路径参数</code>：显示当前工作目录下的内容</li>
<li>组合使用：命令的选项是可以组合使用的，比如<code>ls -lah</code>,等同于<code>ls -a -l -h</code></li>
</ul>
<p><strong>图例：</strong> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusysakura3/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-17%20104031.png"
                      alt="Alt"
                ></p>
<h4 id="2-2-cd-切换目录"><a href="#2-2-cd-切换目录" class="headerlink" title="2.2 cd(切换目录)"></a>2.2 cd(切换目录)</h4><ul>
<li><code>cd</code>：可以切换当前目录</li>
<li>用法：<code>cd [Linux路径]</code><br>  <code>使用路径参数</code>：切换到指定路径<br>  <code>没有路径参数</code>：切换工作目录到当前用户的home</li>
</ul>
<h4 id="2-3-pwd-显示路径"><a href="#2-3-pwd-显示路径" class="headerlink" title="2.3 pwd(显示路径)"></a>2.3 pwd(显示路径)</h4><ul>
<li><code>pwd</code>：输出当前所在的工作目录</li>
<li>用法：<code>pwd</code>(没有选项和参数)<br><strong>图例：</strong> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusysakura3/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-17%20205029.png"
                      alt="Alt"
                ></li>
</ul>
<h4 id="2-4-mkdir-创建目录"><a href="#2-4-mkdir-创建目录" class="headerlink" title="2.4 mkdir(创建目录)"></a>2.4 mkdir(创建目录)</h4><ul>
<li><code>mkdir</code>：可以创建新的目录(文件夹)</li>
<li>用法：<code>mkdir [-p] Linux路径</code><br>  <code>-p</code>：表示自动创建不存在的父目录，适用于创建连续多级的目录<br>  <code>Linux路径</code>：即要创建的文件夹的路径</li>
<li>注意：普通用户下只有在自己的home目录下创建新目录的权限<br><strong>图例：</strong><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusysakura3/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-17%20211000.png"
                      alt="Alt"
                ></li>
</ul>
<h4 id="2-5-touch-创建文件"><a href="#2-5-touch-创建文件" class="headerlink" title="2.5 touch(创建文件)"></a>2.5 touch(创建文件)</h4><ul>
<li><code>touch</code>：可以创建新的文件</li>
<li>用法：<code>touch Linux路径</code><br>  <code>Linux路径</code>：要创建的文件的路径</li>
</ul>
<h4 id="2-6-cat-more-查看文件"><a href="#2-6-cat-more-查看文件" class="headerlink" title="2.6 cat&#x2F;more(查看文件)"></a>2.6 cat&#x2F;more(查看文件)</h4><h5 id="2-6-1-cat"><a href="#2-6-1-cat" class="headerlink" title="2.6.1 cat"></a>2.6.1 cat</h5><ul>
<li><code>cat</code>：可以查看文件里面的内容</li>
<li>用法：<code>cat Linux路径</code></li>
</ul>
<h5 id="2-6-2-more"><a href="#2-6-2-more" class="headerlink" title="2.6.2 more"></a>2.6.2 more</h5><ul>
<li><code>more</code>：可以查看文件里面的内容</li>
<li>用法：<code>more Linux路径</code></li>
<li>快捷键：<ul>
<li><code>Space</code>(空格键)：下一页</li>
<li><code>b</code>：上一页</li>
<li><code>\n</code>(回车键)：下一行</li>
<li><code>q</code>：退出</li>
</ul>
</li>
</ul>
<blockquote><p><strong>区别：</strong></p>
<ul>
<li><code>cat</code>是直接将内容全部显示出来</li>
<li><code>more</code>支持翻页，如果文件内容过多，可以一页页的展示</li>
</ul>
</blockquote>
<h4 id="2-7-cp-复制文件-文件夹"><a href="#2-7-cp-复制文件-文件夹" class="headerlink" title="2.7 cp(复制文件&#x2F;文件夹)"></a>2.7 cp(复制文件&#x2F;文件夹)</h4><ul>
<li><code>cp</code>：可以用于复制文件&#x2F;文件夹</li>
<li>用法：<code>cp [-r] 参数1 参数2</code><br>  <code>-r</code>：用于复制文件夹，表示递归<br>  <code>参数1</code>：Linux路径，表示被复制的文件&#x2F;文件夹<br>  <code>参数2</code>：Linux路径，表示要复制去的地方</li>
</ul>
<h4 id="2-8-mv-移动文件-文件夹"><a href="#2-8-mv-移动文件-文件夹" class="headerlink" title="2.8 mv(移动文件&#x2F;文件夹)"></a>2.8 mv(移动文件&#x2F;文件夹)</h4><ul>
<li><code>mv</code>：可以用于移动文件&#x2F;文件夹</li>
<li>用法：<code>mv 参数1 参数2</code><br>  <code>参数1</code>：Linux路径，表示被移动的文件或文件夹<br>  <code>参数2</code>：Linux路径，表示要移动去的地方，如果目标不存在，则进行改名，确保目标存在</li>
</ul>
<h4 id="2-9-rm-删除文件-文件夹"><a href="#2-9-rm-删除文件-文件夹" class="headerlink" title="2.9 rm(删除文件&#x2F;文件夹)"></a>2.9 rm(删除文件&#x2F;文件夹)</h4><ul>
<li><p><code>rm</code>：可以用于删除文件&#x2F;文件夹</p>
</li>
<li><p>用法：<code>rm [-r -f] 参数1 参数2 …… 参数n</code><br>  <code>-r</code>：删除文件夹<br>  <code>-f</code>：强制删除（不会弹出提示确认信息）</p>
<ul>
<li>普通用户删除内容不会弹出提示，只有root管理员用户删除内容会有提示</li>
<li>所以一般普通用户用不到<code>-f</code>选项</li>
</ul>
<p>  <code>参数1 参数2 …… 参数n</code>：表示要删除的文件&#x2F;文件夹路径，按照空格隔开</p>
</li>
<li><p>支持通配符*：<code>用来做模糊匹配</code><br>  <code>*</code>：通配符，即匹配任意内容(包含空)</p>
<ul>
<li><code>test*</code> 表示匹配任何以test开头的内容</li>
<li><code>*test</code> 表示匹配任何以test结尾的内容</li>
<li><code>*test*</code>表示匹配任何含有test的内容</li>
</ul>
</li>
</ul>
<p><strong>图例：</strong><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusysakura3/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-17%20232921.png"
                      alt="Alt"
                ></p>
<h4 id="2-10-which-查找命令的程序文件"><a href="#2-10-which-查找命令的程序文件" class="headerlink" title="2.10 which(查找命令的程序文件)"></a>2.10 which(查找命令的程序文件)</h4><ul>
<li><code>which</code>：查看所使用的一系列命令的程序文件存放在哪里</li>
<li>用法：<code>which 要查找的命令(cd,cp,pwd……)</code></li>
</ul>
<h4 id="2-11-find-查找文件"><a href="#2-11-find-查找文件" class="headerlink" title="2.11 find(查找文件)"></a>2.11 find(查找文件)</h4><ul>
<li><code>find</code>：可以搜索指定的文件</li>
<li>用法：<br>  ①按文件名查找：<code>find 起始路径 -name &quot;被查找文件名&quot;</code>[文件名支持通配符]<br>  ②按文件大小查找：<code>find 起始路径 -size +/- n[kMG]</code><ul>
<li><code>+,-</code>：表示大于和小于</li>
<li><code>n</code>：表示大小数字</li>
<li><code>kMG</code>：表示单位大小，<code>k</code>(小写字母)表示kb，<code>M</code>表示MB，<code>G</code>表示GB</li>
</ul>
</li>
</ul>
<blockquote><p><strong>注意：</strong><br><code>find</code>命令存在权限问题，普通用户使用<code>find</code>命令时可能受到权限限制，无法搜索到部分目录或文件。</p>
</blockquote>

<h4 id="2-12-grep-过滤文件行"><a href="#2-12-grep-过滤文件行" class="headerlink" title="2.12 grep(过滤文件行)"></a>2.12 grep(过滤文件行)</h4><ul>
<li><code>grep</code>：从文件中通过关键字过滤文件行</li>
<li>用法：<code>grep [-n] &quot;关键字&quot; 文件路径</code><br>  <code>-n</code>：表示在结果中显示匹配的行的行号<br>  <code>&quot;关键字&quot;</code>：表示要过滤的关键词，带有空格或其他特殊符号，建议使用” “将关键词包围起来<br>  <code>文件路径</code>：表示过滤内容的文件路径，<strong>可作为内容输入端口</strong></li>
</ul>
<h4 id="2-13-wc-数量统计"><a href="#2-13-wc-数量统计" class="headerlink" title="2.13 wc(数量统计)"></a>2.13 wc(数量统计)</h4><ul>
<li><code>wc</code>：可以统计文件的行数、单词数量等</li>
<li>用法：<code>wc [-c -m -l -w] 文件路径</code><br>  <code>-c</code>：统计bytes数量<br>  <code>-m</code>：统计字符数量<br>  <code>-l</code>：统计行数<br>  <code>-w</code>：统计单词数量<br>  <strong>没有输入选项</strong>：默认输出<code>行数</code>、<code>单词数</code>、<code>字节数</code><br>  <code>文件路径</code>：可以作为内容输入的端口</li>
</ul>
<h4 id="2-14-管道符"><a href="#2-14-管道符" class="headerlink" title="2.14 | (管道符)"></a>2.14 | (管道符)</h4><ul>
<li><code>|</code>：将管道符左边命令的结果，作为右边命令的输入</li>
<li>用法：可以和<code>grep</code>、<code>wc</code>……结合使用。</li>
</ul>
<blockquote><p><strong>注意：</strong><br><code>|</code>可以多次嵌套使用。<br>下图例子：<code>cat hello.txt | grep &quot;lusy&quot; | grep love</code><br>        先通过<code>cat hello.txt | grep &quot;lusy&quot;</code>筛选出<br>        <strong>lusy</strong> love you<br>        <strong>lusy</strong> qq lus<br>        wwsa <strong>lusy</strong><br>        再进行<code>| grep love</code>筛选出<br>        lusy <strong>love</strong></p>
</blockquote>
<p><strong>图例：</strong><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-18%20184306.png"
                      alt="Alt"
                ></p>
<h4 id="2-15-echo-输出内容"><a href="#2-15-echo-输出内容" class="headerlink" title="2.15 echo(输出内容)"></a>2.15 echo(输出内容)</h4><ul>
<li><code>echo</code>：输出指定的内容[类似于C中的printf语句]</li>
<li>用法：<code>echo &quot;输出的内容&quot;</code> [带有空格或其他特殊符号，建议使用” “将关键词包围起来]</li>
</ul>
<h4 id="2-16-反引号"><a href="#2-16-反引号" class="headerlink" title="2.16 &#96; (反引号)"></a>2.16 &#96; (反引号)</h4><ul>
<li>用法：被&#96;包围的内容将会被当成命令执行，可以和echo搭配使用</li>
</ul>
<h4 id="2-17-和-重定项符"><a href="#2-17-和-重定项符" class="headerlink" title="2.17 &gt;和&gt;&gt;(重定项符)"></a>2.17 &gt;和&gt;&gt;(重定项符)</h4><ul>
<li><code>&gt;/&gt;&gt;</code>：修改文件内容</li>
<li>用法：<ul>
<li><code>&gt;</code>：将左侧命令的结果，<strong>覆盖</strong>写到符号右侧指定的文件中</li>
<li><code>&gt;&gt;</code>：将左侧命令的结果，<strong>追加</strong>写入符号右侧指定的文件中</li>
</ul>
</li>
</ul>
<h4 id="2-18-tail-查看文件尾部"><a href="#2-18-tail-查看文件尾部" class="headerlink" title="2.18 tail(查看文件尾部)"></a>2.18 tail(查看文件尾部)</h4><ul>
<li><code>tail</code>：可以查看文件尾部内容，跟踪文件的最新更改</li>
<li>用法：<code>tail [-f -n] Linux路径</code><br><code>-f</code>：表示持续跟踪，会实时更新[要退出持续跟踪，可以按<code>Ctrl + C</code>]<br><code>-n</code>：n是具体数字，表示要查看尾部多少行，不填默认<strong>10</strong>行</li>
</ul>
<p><strong>图例：</strong><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-18%20204315.png"
                      alt="Alt"
                ></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-18%20204642.png"
                      alt='' style="float: right; width: 300px; height: auto;"
                >

<h4 id="2-19-vi-vim-编辑文件"><a href="#2-19-vi-vim-编辑文件" class="headerlink" title="2.19 vi&#x2F;vim(编辑文件)"></a>2.19 vi&#x2F;vim(编辑文件)</h4><ul>
<li><code>vi/vim</code>：编辑器，可以编辑文件内容[vim是vi的pro版本]</li>
<li>用法：<code>vi/vim 文件路径</code><ul>
<li>如果文件路径表示的文件<strong>不存在</strong>，那么此命令会用于<strong>编辑新文件</strong></li>
<li>如果文件路径表示的文件<strong>存在</strong>，那么此命令会用于<strong>编辑已有文件</strong></li>
</ul>
</li>
<li>注意：通过vi&#x2F;vim命令编辑文件，会打开一个新的窗口，此时这个窗口是<strong>命令模式</strong>窗口，<strong>命令模式</strong>是vi&#x2F;vim编辑器的入口和出口，如右图<ul>
<li>进入vi&#x2F;vim编辑器会进入<strong>命令模式</strong></li>
<li>通过<strong>命令模式</strong>输入键盘指令<code>i、a、o</code>[任选一个即可]，可以进入<strong>输入模式</strong></li>
<li><strong>输入模式</strong>需要退回到<strong>命令模式</strong>，如何通过命令才可以进入<strong>底线命令模式</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>模式</th>
<th>命令</th>
<th>描述</th>
<th>模式</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>命令模式</td>
<td><code>i</code></td>
<td>在当前光标位置进入 输入模式</td>
<td>命令模式</td>
<td><code>yy</code></td>
<td>复制当前行</td>
</tr>
<tr>
<td>命令模式</td>
<td><code>a</code></td>
<td>在当前光标位置 之后 进入 输入模式</td>
<td>命令模式</td>
<td><code>nyy</code></td>
<td>n是数字,复制当前行和下面的n行</td>
</tr>
<tr>
<td>命令模式</td>
<td><code>o</code></td>
<td>在当前光标下一行进入输入模式</td>
<td>命令模式</td>
<td><code>p</code></td>
<td>粘贴复制的内容</td>
</tr>
<tr>
<td>命令模式</td>
<td><code>I</code></td>
<td>在当前行的开头,进入输入模式</td>
<td>命令模式</td>
<td><code>u</code></td>
<td>撤销修改</td>
</tr>
<tr>
<td>命令模式</td>
<td><code>A</code></td>
<td>在当前行的结尾,进入输入模式</td>
<td>命令模式</td>
<td><code>ctrl + r</code></td>
<td>反向撤销修改</td>
</tr>
<tr>
<td>命令模式</td>
<td><code>O</code></td>
<td>在当前光标上一行进入输入模式</td>
<td>命令模式</td>
<td><code>gg</code></td>
<td>跳到首行</td>
</tr>
<tr>
<td>输入模式</td>
<td><code>esc</code></td>
<td>任何情况下输入<code>esc</code>都能回到命令模式</td>
<td>命令模式</td>
<td><code>G</code></td>
<td>跳到行尾</td>
</tr>
<tr>
<td>命令模式</td>
<td><code>键盘上、键盘k</code></td>
<td>向上移动光标</td>
<td>命令模式</td>
<td><code>dd</code></td>
<td>删除光标所在行的内容</td>
</tr>
<tr>
<td>命令模式</td>
<td><code>键盘下、键盘j</code></td>
<td>向下移动光标</td>
<td>命令模式</td>
<td><code>ndd</code></td>
<td>n是数字,表示删除当前光标向下n行</td>
</tr>
<tr>
<td>命令模式</td>
<td><code>键盘左、键盘h</code></td>
<td>向左移动光标</td>
<td>命令模式</td>
<td><code>dG</code></td>
<td>从当前行开始,向下全部删除</td>
</tr>
<tr>
<td>命令模式</td>
<td><code>键盘右、键盘1</code></td>
<td>向后移动光标</td>
<td>命令模式</td>
<td><code>dgg</code></td>
<td>从当前行开始,向上全部删除</td>
</tr>
<tr>
<td>命令模式</td>
<td><code>0</code></td>
<td>移动光标到当前行的开头</td>
<td>命令模式</td>
<td><code>d$</code></td>
<td>从当前光标开始,删除到本行的结尾</td>
</tr>
<tr>
<td>命令模式</td>
<td><code>$</code></td>
<td>移动光标到当前行的结尾</td>
<td>命令模式</td>
<td><code>de</code></td>
<td>从当前光标开始,删除到本行的开头</td>
</tr>
<tr>
<td>命令模式</td>
<td><code>pageup(PgUp)</code></td>
<td>向上翻页</td>
<td>底线命令模式</td>
<td><code>:wq</code></td>
<td>保存并退出</td>
</tr>
<tr>
<td>命令模式</td>
<td><code>pangdown(PgDn)</code></td>
<td>向下翻页</td>
<td>底线命令模式</td>
<td><code>:q!</code></td>
<td>强制退出</td>
</tr>
<tr>
<td>命令模式</td>
<td><code>/</code></td>
<td>进入搜索模式</td>
<td>底线命令模式</td>
<td><code>:w</code></td>
<td>仅保存</td>
</tr>
<tr>
<td>命令模式</td>
<td><code>n</code></td>
<td>向下继续搜索</td>
<td>底线命令模式</td>
<td><code>:set nu</code></td>
<td>显示行号</td>
</tr>
<tr>
<td>命令模式</td>
<td><code>N</code></td>
<td>向上继续搜索</td>
<td>底线命令模式</td>
<td><code>:set paste</code></td>
<td>设置粘贴模式</td>
</tr>
</tbody></table>
<h3 id="3-root用户"><a href="#3-root用户" class="headerlink" title="3 root用户"></a>3 root用户</h3><h4 id="3-1-root用户和普通用户"><a href="#3-1-root用户和普通用户" class="headerlink" title="3.1 root用户和普通用户"></a>3.1 root用户和普通用户</h4><ul>
<li><code>root用户(超级管理员)</code>：拥有最大的系统操作权限[而普通用户在许多地方的权限是受限的]</li>
<li><code>普通用户</code>：一般在其home目录内是不受限的,而一旦出了home目录，大多数地方普通用户仅有只读和执行权限，无修改权限</li>
</ul>
<h4 id="3-2-su和exit-切换用户"><a href="#3-2-su和exit-切换用户" class="headerlink" title="3.2 su和exit(切换用户)"></a>3.2 su和exit(切换用户)</h4><h5 id="3-2-1-su"><a href="#3-2-1-su" class="headerlink" title="3.2.1 su"></a>3.2.1 su</h5><ul>
<li><code>su</code>：用于账户的切换</li>
<li>用法：<code>su [-] [用户名]</code><br>  <code>-</code>：表示是否在切换用户后加载环境变量，<strong>建议带上</strong><br>  <code>用户名</code>：表示要切换的用户，如果没有填写，默认切换到root用户</li>
</ul>
<h5 id="3-2-2-exit"><a href="#3-2-2-exit" class="headerlink" title="3.2.2 exit"></a>3.2.2 exit</h5><ul>
<li><code>exit</code>：退回上一个用户</li>
<li>用法：切换用户后，可以通过<code>exit</code>命令返回上一个用户，也可以使用快捷键<code>Ctrl + d</code></li>
</ul>
<blockquote><p><strong>注意：</strong></p>
<ul>
<li>使用普通用户，切换到其他用户<strong>需要输入密码</strong>，如切换到root用户(输入的密码要与切换到的用户的密码对应)</li>
<li>使用root用户切换到其他用户，<strong>无需密码</strong>，可以直接切换</li>
</ul>
</blockquote>

<h4 id="3-3-sudo-获得权限"><a href="#3-3-sudo-获得权限" class="headerlink" title="3.3 sudo(获得权限)"></a>3.3 sudo(获得权限)</h4><ul>
<li><code>sudo</code>：可以为普通用户的命令授权，临时以<code>root</code>身份执行</li>
<li>用法：<code>sudo 其它命令</code></li>
</ul>
<blockquote><p><strong>注意：</strong></p>
<ul>
<li>在其它命令之前，带上<code>sudo</code>,即可为这一条命令临时赋予<code>root</code>授权</li>
<li>但并不是所有的用户都有权利使用<code>sudo</code>,<strong>我们需要在此之前为普通用户配置sudo认证</strong></li>
</ul>
</blockquote>
<ul>
<li>配置sudo认证：<ul>
<li>切换<code>root</code>用户</li>
<li>执行<code>visudo</code>命令，会自动通过vi编辑器打开：&#x2F;etc&#x2F;sudoers</li>
<li>在文件的最后添加相关指令[<strong>如下</strong>]</li>
<li>通过<code>wq</code>保存</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>username</code></td>
<td>表示将授权信息添加到指定用户的权限列表中</td>
</tr>
<tr>
<td><code>otheruser</code></td>
<td>指定其他用户的身份。</td>
</tr>
<tr>
<td><code>%groupname</code></td>
<td>指定要授权的用户组。</td>
</tr>
<tr>
<td><code>ALL</code></td>
<td>表示将授权信息添加到所有用户或者组的权限列表中</td>
</tr>
<tr>
<td><code>(ALL)</code></td>
<td>表示可以以任何用户的身份执行命令。</td>
</tr>
<tr>
<td><code>NOPASSWD</code></td>
<td>表示授权用户在执行该命令时无需输入密码</td>
</tr>
<tr>
<td><code>PASSWD</code></td>
<td>表示授权用户在执行该命令时需要输入密码</td>
</tr>
<tr>
<td><code>/path/</code></td>
<td>表示授权用户可以执行的命令路径，必须使用完整的命令路径</td>
</tr>
<tr>
<td><code>/file</code></td>
<td>表示授权用户可以执行的文件路径，必须使用完整的文件路径</td>
</tr>
<tr>
<td><code>!</code></td>
<td>表示阻止用户执行某些命令</td>
</tr>
<tr>
<td><code>#</code></td>
<td>表示注释符号，后面的内容将被视为注释，不起实际作用</td>
</tr>
<tr>
<td><code>Defaults</code></td>
<td>表示设置sudo的默认配置信息，包括日志路径、运行超时时间等</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>用户授权</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">username  ALL=(ALL) [NOPASSWD:] <span class="built_in">command</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>username</code>：指定要授权的用户名。</li>
<li><code>ALL</code>：表示可以在任何主机上执行命令。</li>
<li><code>(ALL)</code>：表示可以以任何用户的身份执行命令。</li>
<li><code>NOPASSWD</code>：表示无需输入密码。</li>
</ul>
<p>例如，允许用户 <code>john</code> 在任何主机上以任何用户的身份执行 <code>/bin/ls</code> 命令，并且无需输入密码：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">john ALL=(ALL) NOPASSWD: /bin/ls</span><br></pre></td></tr></table></figure></div></li>
<li><p><strong>用户组授权</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">%groupname  ALL=(ALL) [NOPASSWD:] <span class="built_in">command</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>%groupname</code>：指定要授权的用户组。</li>
<li>其他参数的含义同上。</li>
</ul>
<p>例如，允许用户组 <code>admins</code> 在任何主机上以任何用户的身份执行 <code>/bin/ls</code> 命令，并且无需输入密码：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">%admins ALL=(ALL) NOPASSWD: /bin/ls</span><br></pre></td></tr></table></figure></div></li>
<li><p><strong>指定可执行文件路径</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">username  ALL=(ALL) [NOPASSWD:] /path/to/command</span><br></pre></td></tr></table></figure></div>

<p>这将限制用户只能执行指定路径下的命令。</p>
</li>
<li><p><strong>禁止某些命令</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">username  ALL=(ALL) !/path/to/command</span><br></pre></td></tr></table></figure></div>

<p>这将阻止用户执行指定的命令。</p>
</li>
<li><p><strong>授权指定用户以其他用户的身份执行命令</strong>：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">username  ALL=(otheruser) [NOPASSWD:] /path/to/command</span><br></pre></td></tr></table></figure></div>

<p>允许用户以 <code>otheruser</code> 用户的身份执行命令。</p>
</li>
<li><p><strong>别名的使用</strong>：</p>
<p>你也可以定义别名来使配置文件更加清晰，例如：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">User_Alias  ADMINS = user1, user2</span><br><span class="line">Cmnd_Alias  SYSTEM_CMDS = /bin/ls, /bin/cat</span><br><span class="line"></span><br><span class="line">ADMINS  ALL=(ALL) SYSTEM_CMDS</span><br></pre></td></tr></table></figure></div>

<p>这样，<code>ADMINS</code> 别名包含了 <code>user1</code> 和 <code>user2</code> 用户，<code>SYSTEM_CMDS</code> 别名包含了 <code>/bin/ls</code> 和 <code>/bin/cat</code> 命令，然后 <code>ADMINS</code> 组可以执行 <code>SYSTEM_CMDS</code> 中的命令。</p>
</li>
</ol>
<blockquote><p><strong>注意：</strong></p>
<ul>
<li><p>在编辑 <code>sudoers</code> 文件时，一定要使用 <code>visudo</code> 命令，这样可以在保存文件时检查语法错误，以免导致系统无法启动。</p>
</li>
<li><p>在 <code>/etc/sudoers</code> 文件中配置了 <code>username  ALL=(ALL) [NOPASSWD:] command</code> 这样的规则时，这意味着当用户 <code>username</code> 尝试执行 <code>command</code> 时，无论命令是否需要超级用户权限，只有在命令前加上 <code>sudo</code> 才会生效。</p>
</li>
<li><p>另一方面，如果配置了阻止用户执行某些命令的规则，比如 <code>username ALL=(ALL) !/path/to/command</code>，即使用户尝试执行该命令时没有使用 <code>sudo</code>，系统也会阻止命令的执行。</p>
</li>
</ul>
<p>所以，在配置了 <code>sudoers</code> 文件后：</p>
<ul>
<li>如果某个用户有权限执行某个命令，并且该命令不需要特权，那么用户可以在执行时不加 <code>sudo</code>。</li>
<li>如果某个用户有权限执行某个命令，但是该命令需要特权，那么用户必须在执行时加上 <code>sudo</code>。</li>
<li>如果某个用户被明确阻止执行某个命令，那么无论是否使用 <code>sudo</code>，该命令都不会被执行。</li>
</ul>
</blockquote>	
<h4 id="3-4-用户组管理"><a href="#3-4-用户组管理" class="headerlink" title="3.4 用户组管理"></a>3.4 用户组管理</h4><p>对一个用户组进行创建和删除操作，都需要<code>root</code>用户的权限[下图是用户与用户组中间的关系图]</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-19%20222538.png"
                      alt='' style="float: right; margin-right: 150px; margin-top: -5px;width: 350px; height: auto;"
                >

<h5 id="3-4-1-创建用户组"><a href="#3-4-1-创建用户组" class="headerlink" title="3.4.1 创建用户组"></a>3.4.1 创建用户组</h5><ul>
<li>命令：<code>groupadd 用户组名</code></li>
</ul>
<h5 id="3-4-2-删除用户组"><a href="#3-4-2-删除用户组" class="headerlink" title="3.4.2 删除用户组"></a>3.4.2 删除用户组</h5><ul>
<li>命令：<code>groupdel 用户组名</code></li>
</ul>
<h4 id="3-5-用户管理"><a href="#3-5-用户管理" class="headerlink" title="3.5 用户管理"></a>3.5 用户管理</h4><h5 id="3-5-1-创建用户"><a href="#3-5-1-创建用户" class="headerlink" title="3.5.1 创建用户"></a>3.5.1 创建用户</h5><ul>
<li>命令：<code>useradd 用户名 [-g 用户组名 -d Linux路径]</code><br>  <code>-g</code>：指定用户的组，不指定-g，会创建一个同名组并自动加入，指定-g需要组已经存在，如已存在同名组，必须使用-g<br>  <code>-d</code>：指定用户home路径，不指定，home目录默认在：&#x2F;home&#x2F;用户名</li>
</ul>
<h5 id="3-5-2-删除用户"><a href="#3-5-2-删除用户" class="headerlink" title="3.5.2 删除用户"></a>3.5.2 删除用户</h5><ul>
<li>命令：<code>userdel [-r] 用户名</code><br>  <code>-r</code>：删除用户的home路径，不是用<code>-r</code>,删除用户时，home目录会被保留</li>
</ul>
<h5 id="3-5-3-查看用户所属组"><a href="#3-5-3-查看用户所属组" class="headerlink" title="3.5.3 查看用户所属组"></a>3.5.3 查看用户所属组</h5><ul>
<li>命令：<code>id [用户名]</code><br>  <code>[用户名]</code>：被查看的用户，如果不提供则查看自身</li>
</ul>
<h5 id="3-5-4-修改用户所属组"><a href="#3-5-4-修改用户所属组" class="headerlink" title="3.5.4 修改用户所属组"></a>3.5.4 修改用户所属组</h5><ul>
<li>命令：<code>usermod -aG 用户组 用户名</code><br>  将指定用户加入指定用户组</li>
</ul>
<blockquote><p><strong>注意：</strong><br>原有的所属组也会保留，如要将用户从所属组删除，可以通过下面的命令</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> gpasswd -d 用户名 用户组名</span><br></pre></td></tr></table></figure></div></blockquote>
<h4 id="3-6-查看用户-用户组"><a href="#3-6-查看用户-用户组" class="headerlink" title="3.6 查看用户&#x2F;用户组"></a>3.6 查看用户&#x2F;用户组</h4><ul>
<li>命令：<code>getent passwd</code><br>  用于查看当前系统中有哪些用户<br>  共有7份信息,分别是:<br>  用户名:密码(x):用户ID:组ID:描述信息(无用):HOME目录:执行终端(默认bash)</li>
<li>命令：<code>getent group</code><br>  用于查看当前系统中有哪些用户组<br>  共有3份信息,分别是:<br>  组名称：组认证(显示为x)：组ID</li>
</ul>
<h4 id="3-7-认知权限信息"><a href="#3-7-认知权限信息" class="headerlink" title="3.7 认知权限信息"></a>3.7 认知权限信息</h4><p>可以通过<code>ls -l</code>或者<code>ll</code>命令，以列表的形式查看内容，并显示权限细节<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-20%20130750.png"
                     
                ></p>
<ul>
<li>序号1：表示文件&#x2F;文件夹的权限控制信息</li>
<li>序号2：表示文件&#x2F;文件夹所属用户</li>
<li>序号3：表示文件&#x2F;文件夹所属用户组</li>
</ul>
<blockquote><p>序号1的权限细节总共分为10个槽位<br>第一个槽位表示所属类型：<code>d</code>表示文件夹，<code>-</code>表示文件，<code>l</code>表示软连接<br>后9个槽位分为3组，每组3个槽位，这三组依次是：<code>所属用户权限</code>,<code>所属用户组权限</code>,<code>其他用户权限</code><br>每一组的三个槽位中，每个槽位依次是：<code>r</code>可读[查看文件夹内容]，<code>w</code>可写[创建，删除，改名]，<code>x</code>可执行[可更改工作目录到此文件夹]，<code>-</code>没有这个功能的权限<br><strong>举例：</strong><br><strong>drwxr-xr-x</strong></p>
<ul>
<li>这是一个文件夹，首字母<code>d</code>表示</li>
<li>所属用户的权限是：<code>rwx</code></li>
<li>所属用户组的权限是：<code>r-x</code>,表示有r无w有x</li>
<li>其他用户的权限是：<code>r-x</code></li>
</ul>
</blockquote>

<h4 id="3-8-chmod-修改权限"><a href="#3-8-chmod-修改权限" class="headerlink" title="3.8 chmod(修改权限)"></a>3.8 chmod(修改权限)</h4><ul>
<li><code>chmod</code>：修改文件、文件夹的权限信息[<strong>注意</strong>：只有文件、文件夹的所属用户或root用户可以修改]</li>
<li>用法：<code>chomd [-R] 权限 文件/文件夹</code><br>  <code>-R</code>：对文件夹内的全部内容应用同样的操作<br>  <code>权限</code>：<code>u=___,g=___,o=___</code><br>  其中<code>u</code>表示user所属用户权限，<code>g</code>表示group组权限，<code>o</code>表示other其他用户权限。可以根据自己的需要修改相应权限</li>
</ul>
<blockquote><p><strong>举例：</strong><br><strong>chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x hello.txt</strong><br>将hello.txt这个文件修改为所属<strong>用户</strong>可读可写可执行，所属<strong>用户组</strong>可读可执行，<strong>其他用户</strong>只能执行，没有读写权限。</p>
</blockquote>
<p><strong>快捷写法：</strong><br>    <code>chmod u=rwx,g=rx,o=x hello.txt</code>可以改写成<code>chomd 751 hello.txt</code><br>    在书写权限的<strong>可读、可写、可执行</strong>时，可以把<code>r</code>记为4,<code>w</code>记为2，<code>x</code>记为1。<br>    所以rwx可以记为7，rx可以记为5，x可以记为1</p>
<h4 id="3-9-chown-修改所属用户-用户组"><a href="#3-9-chown-修改所属用户-用户组" class="headerlink" title="3.9 chown(修改所属用户&#x2F;用户组)"></a>3.9 chown(修改所属用户&#x2F;用户组)</h4><ul>
<li><code>chown</code>：修改文件、文件夹的所属用户和用户组[<strong>普通用户无法修改所属为其他用户或组，所以此命令只适用于root用户</strong>]</li>
<li>用法：<code>chown [-R] [用户][:][用户组] 文件或文件夹</code><br>  <code>-R</code>：对文件夹内的全部内容应用同样的操作<br>  <code>用户</code>：修改所属用户<br>  <code>用户组</code>：修改所属用户组<br>  <code>:</code>：用于分隔用户和用户组[<strong>只有填写了用户组，才需要加上冒号，如果只是修改所属用户，不需要添加</strong>]</li>
</ul>
<h3 id="4-快捷键"><a href="#4-快捷键" class="headerlink" title="4 快捷键"></a>4 快捷键</h3><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>ctrl+c</code></td>
<td>强制停止程序，退出命令输入</td>
</tr>
<tr>
<td><code>ctrl+d</code></td>
<td>退出或登出（不能用于vi&#x2F;vim）</td>
</tr>
<tr>
<td><code>history</code></td>
<td>查看历史命令</td>
</tr>
<tr>
<td><code>history ｜grep ch</code></td>
<td>在历史记录中过滤带有<code>ch</code>命令[<code>ch</code>可换成自己想要过滤的关键词]</td>
</tr>
<tr>
<td><code>！+命令的前缀</code></td>
<td>自动匹配上一次匹配的前缀命令</td>
</tr>
<tr>
<td><code>ctrl+r</code></td>
<td>输入内容去匹配历史命令</td>
</tr>
<tr>
<td><code>ctrl+a</code></td>
<td>调到命令开头</td>
</tr>
<tr>
<td><code>ctrl+e</code></td>
<td>跳到命令结尾</td>
</tr>
<tr>
<td><code>ctrl+键盘左键</code></td>
<td>向左跳一个单词</td>
</tr>
<tr>
<td><code>ctrl+键盘右键</code></td>
<td>向右跳一个单词</td>
</tr>
<tr>
<td><code>ctrl+l或者clear</code></td>
<td>清空终端内容（清屏）</td>
</tr>
</tbody></table>
<h3 id="5-基础操作"><a href="#5-基础操作" class="headerlink" title="5 基础操作"></a>5 基础操作</h3><h4 id="5-1-yum-软件安装"><a href="#5-1-yum-软件安装" class="headerlink" title="5.1 yum(软件安装)"></a>5.1 yum(软件安装)</h4><ul>
<li><code>yum</code>：RPM包软件管理器，用于自动化安装配置Linux软件，并可以自动解决依赖问题</li>
<li>用法：<code>yum [-y] [install | remove | search] 软件名称</code><br>  <code>-y</code>：自动确认，无需动手确认安装或卸载过程<br>  <code>install</code>：安装<br>  <code>remove</code>：卸载<br>  <code>search</code>：搜索</li>
</ul>
<blockquote><p><strong>注意：</strong></p>
<ul>
<li>yum命令需要<code>root</code>权限</li>
<li>yum命令需要<strong>联网</strong></li>
</ul>
</blockquote>

<h4 id="5-2-systemctl-管理软件"><a href="#5-2-systemctl-管理软件" class="headerlink" title="5.2 systemctl(管理软件)"></a>5.2 systemctl(管理软件)</h4><ul>
<li><code>systemctl</code>：启动、停止、开机自启能够被syatemctl管理的软件，一般也称之为服务</li>
<li>用法：<code>systemctl start | stop | status | enable | disable 服务名</code><br>  <code>start</code>：启动<br>  <code>stop</code>：关闭<br>  <code>status</code>：查看状态<br>  <code>enable</code>：开启开机自启<br>  <code>disable</code>：关闭开机自启</li>
</ul>
<blockquote><p><strong>常见的服务</strong></p>
<ul>
<li><code>NetworkManager</code>：主网络服务</li>
<li><code>network</code>：副网络服务</li>
<li><code>firewalld</code>：防火墙服务</li>
<li><code>sshd</code>：ssh服务(FinalShell远程登录Linux使用的就是这个服务)</li>
</ul>
</blockquote>

<h4 id="5-3-ln-软链接"><a href="#5-3-ln-软链接" class="headerlink" title="5.3 ln(软链接)"></a>5.3 ln(软链接)</h4><ul>
<li><code>ln</code>：在系统中创建软链接，可以将文件、文件夹链接到其它位置[类似于Windows中的”快捷方式”]</li>
<li>用法：<code>ln -s 参数1 参数2</code><br>  <code>-s</code>：创建软链接<br>  <code>参数1</code>：被链接的文件或文件夹<br>  <code>参数2</code>：要链接去的目的地</li>
</ul>
<blockquote><p><strong>删除软链接</strong><br>要删除 Linux 中的软链接，可以使用<code>rm</code>命令，其语法为：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> 软链接文件名</span><br></pre></td></tr></table></figure></div></blockquote>

<p><strong>图例</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-21%20223032.png"
                     
                ><br>[<code>注意</code>：如果软链接出现爆红现象，那可能是被链接的文件或文件夹并不存在]</p>
<h4 id="5-4-网络请求和下载"><a href="#5-4-网络请求和下载" class="headerlink" title="5.4 网络请求和下载"></a>5.4 网络请求和下载</h4><h5 id="5-4-1-ping-检查服务器是否可联通"><a href="#5-4-1-ping-检查服务器是否可联通" class="headerlink" title="5.4.1 ping(检查服务器是否可联通)"></a>5.4.1 ping(检查服务器是否可联通)</h5><ul>
<li><code>ping</code>：检查指定的网络服务器是否是可联通状态</li>
<li>用法：<code>ping [-c num] ip或主机名</code><br>  <code>-c num</code>：检查的num次，如果不使用<code>-c</code>，将无限次持续检查[<strong>可用<code>Ctrl + c</code>退出</strong>]<br>  <code>ip或主机名</code>：被检查的服务器的IP地址或主机名地址</li>
</ul>
<h5 id="5-4-2-wget-文件下载-要先下载过wget插件，若之前没有下载，可用yum命令下载"><a href="#5-4-2-wget-文件下载-要先下载过wget插件，若之前没有下载，可用yum命令下载" class="headerlink" title="5.4.2 wget(文件下载)[要先下载过wget插件，若之前没有下载，可用yum命令下载]"></a>5.4.2 wget(文件下载)[要先下载过wget插件，若之前没有下载，可用yum命令下载]</h5><ul>
<li><code>wget</code>：是一个非交互式的文件下载器，可以在命令行内下载网络文件</li>
<li>用法：<code>wget [-b] url</code><br>  <code>-b</code>：后台下载，会将日志写入到当前工作目录的wget-log文件<br>  <code>url</code>：下载链接</li>
</ul>
<blockquote><p><strong>在Linux中，yum 和 wget 是两个不同的工具，用途也不同：</strong></p>
<ul>
<li><code>yum</code>：<br>yum 是一个包管理器，通常用于在基于 RPM 的发行版（如 CentOS、Fedora、Red Hat Enterprise Linux 等）上安装、更新和删除软件包。<br>它可以自动解决软件包之间的依赖关系，并下载并安装所有必需的软件包。<br>yum 通常用于管理系统上的软件包，包括安装新软件包、更新已安装的软件包、删除不再需要的软件包等。</li>
<li><code>wget</code>：<br>wget 是一个命令行工具，用于从网络上下载文件。它支持下载 HTTP、HTTPS 和 FTP 等协议下的文件。<br>wget 可以下载单个文件，也可以通过递归下载整个网站的内容。<br>它是一个简单而强大的工具，通常用于从命令行下载文件，比如下载软件包、下载网站内容、下载备份等。<br>简而言之，yum 是一个软件包管理器，用于管理系统上的软件包，而 wget 则是一个下载工具，用于从网络上下载文件。它们在功能和用途上有很大的区别，但在某些情况下可能会一起使用，比如使用 wget 下载软件包文件，然后使用 yum 安装这些软件包。</li>
</ul>
</blockquote>
<h5 id="5-4-3-curl-网络请求"><a href="#5-4-3-curl-网络请求" class="headerlink" title="5.4.3 curl(网络请求)"></a>5.4.3 curl(网络请求)</h5><ul>
<li><code>curl</code>：可以发送http网络请求，可以用于：下载文件，获取信息等</li>
<li>用法：<code>curl [-O] url</code><br>  <code>-O</code>：用于下载文件，当url是下载链接时，可以用此选项进行保存文件<br>  <code>url</code>：要发起请求的网络地址</li>
</ul>
<p><strong>图例：</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-22%20223228.png"
                     
                ></p>
<h4 id="5-5-端口"><a href="#5-5-端口" class="headerlink" title="5.5 端口"></a>5.5 端口</h4><p><strong>Linux系统是一个超大号小区,可以支持65535个端口,这6万多个端口分为3类进行使用:</strong></p>
<ul>
<li>公认端口:1~1023,通常用于一些系统内置或知名程序的预留使用[如SSH服务的22端口,HTTPS服务的443端口]，非特殊需要,不要占用这个范围的端口</li>
<li>注册端口:1024~49151,通常可以随意使用,用于松散的绑定一些程序&#x2F;服务</li>
<li>动态端口:49152~65535,通常不会固定绑定程序,而是当程序对外进行网络链接时,用于临时使用。[如发起访问时，发起方的临时端口]</li>
</ul>
<h5 id="5-5-1-nmap-查看暴露端口-插件，需要yum命令下载"><a href="#5-5-1-nmap-查看暴露端口-插件，需要yum命令下载" class="headerlink" title="5.5.1 nmap(查看暴露端口)[插件，需要yum命令下载]"></a>5.5.1 nmap(查看暴露端口)[插件，需要yum命令下载]</h5><ul>
<li><code>nmap</code>：可以查看指定IP的<strong>对外暴露端口</strong></li>
<li>用法：<code>nmap 被查看的ip地址</code></li>
</ul>
<h5 id="5-5-2-netstat-查看端口占用-插件，yum-y-install-net-tools"><a href="#5-5-2-netstat-查看端口占用-插件，yum-y-install-net-tools" class="headerlink" title="5.5.2 netstat(查看端口占用)[插件，yum -y install net-tools]"></a>5.5.2 netstat(查看端口占用)[插件，<code>yum -y install net-tools</code>]</h5><ul>
<li><code>netstat</code>：查看指定端口的占用情况</li>
<li>用法：<code>netstat -anp [ | grep 端口号]</code><br>  <code>| grep 端口号</code>：用来筛选端口<br><strong>图例：</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-22%20230843.png"
                     
                ></li>
</ul>
<h4 id="5-6-进程管理"><a href="#5-6-进程管理" class="headerlink" title="5.6 进程管理"></a>5.6 进程管理</h4><blockquote>
<p>程序运行在操作系统中,是被操作系统所管理的。<br>为管理运行的程序,每一个程序在运行的时候,便被操作系统注册为系统中的一个:进程<br>并会为每一个进程都分配一个独有的:进程ID(进程号)</p>
</blockquote>
<h5 id="5-6-1-ps-查看进程"><a href="#5-6-1-ps-查看进程" class="headerlink" title="5.6.1 ps(查看进程)"></a>5.6.1 ps(查看进程)</h5><ul>
<li><code>ps</code>：查看Linux系统中的进程信息</li>
<li>用法：<code>ps [-e -f]</code><br>  <code>-e</code>：显示出全部的进程<br>  <code>-f</code>：以完全格式化的形式展开信息<br>  一般来说，固定用法是：<code>ps -ef</code>列出全部进程的全部信息，并配合<code>| grep 关键词</code>使用。</li>
</ul>
<span style="display: inline-block; margin-left: 400px;">

<ul>
<li>UID：进程所属的用户ID</li>
<li>PID：进程的进程号ID</li>
<li>PPID：进程的父ID(启用此进程的其它进程)</li>
<li>C：此进程的CPU占用率(百分比)</li>
<li>STIME：进程的启动时间</li>
<li>TTY：启动此进程的终端序号，如显示？，表示非终端启动</li>
<li>TIME：进程占用CPU的时间(累计使用CPU的时间)</li>
<li>CMD：该进程对应的名字或启动路径或启动命令。</li>
</ul>
</span>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-22%20232150.png"
                      alt='' style="float: left; margin-top: -270px;width: 400px; height: 250px;"
                >

<h5 id="5-6-2-kill-关闭进程"><a href="#5-6-2-kill-关闭进程" class="headerlink" title="5.6.2 kill(关闭进程)"></a>5.6.2 kill(关闭进程)</h5><ul>
<li><code>kill</code>：关闭指定进程</li>
<li>用法：<code>kill [-9] 进程ID</code><br>  <code>-9</code>：表示强制关闭进程</li>
</ul>
<h4 id="5-7-主机状态监控"><a href="#5-7-主机状态监控" class="headerlink" title="5.7 主机状态监控"></a>5.7 主机状态监控</h4><h5 id="5-7-1-top-查看任务管理器"><a href="#5-7-1-top-查看任务管理器" class="headerlink" title="5.7.1 top(查看任务管理器)"></a>5.7.1 top(查看任务管理器)</h5><ul>
<li><code>top</code>：查看CPU、内存使用情况，类似windows的任务管理器</li>
<li>用法：<code>top</code><br>  默认<strong>每5秒刷新一次</strong>，可以按<code>q</code>或<code>Ctrl + c</code>退出</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-23%20204148.png"
                     
                >  </p>
<ul>
<li>第一行： <code>top</code>：命令名称，<code>20：41：40</code>：当前系统时间，<code>up 1：29</code>：启动了1小时29分钟，<code>2 users</code>：2个用户登录，<code>load average：0.26，0.39，0.40</code>：表示1，5，15分钟的平均负载</li>
<li>第二行：<code>Tasks</code>：<code>174 total</code>：一共有174个进程，<code>4 running</code>：4个进程在运行，<code>170 sleeping</code>：170个进程睡眠，<code>0 stopped</code>：0个停止进程，<code>0 zombie</code>：-个僵尸进程</li>
<li>第三行：<code>%Cpu(s)</code>：CPU使用率，<code>us</code>：用户CPU使用率，<code>sy</code>：系统CPU使用率，<code>ni</code>：高优先级进程占用CPU时间百分比，<code>id</code>：空闲CPU率，<code>wa</code>：IO等待CPU占用率，<code>hi</code>：CPU硬件中断率，<code>si</code>：CPU软件中断率，<code>st</code>：强制等待CPU占用率</li>
<li>第四、五行：<code>Kib Mem</code>:物理内存,<code>total</code>:总量,<code>free</code>:空闲,<code>used</code>:使用,<code>buff/cache</code>:buff和cache占用<br><code>KibSwap</code>:虚拟内存(交换空间),<code>total</code>:总量,<code>free</code>:空闲,<code>used</code>:使用,<code>buff/cache</code>:buff和cache占用</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-23%20210150.png"
                     
                ></p>
<ul>
<li>PID:进程id</li>
<li>USER:进程所属用户</li>
<li>PR:进程优先级,越小越高</li>
<li>NI:负值表示高优先级,正表示低优先级</li>
<li>VIRT:进程使用虚拟内存,单位KB</li>
<li>RES:进程使用物理内存,单位KB</li>
<li>SHR:进程使用共享内存,单位KB</li>
<li>S:进程状态(S休眠,R运行,Z僵死状态,N负数优先级,l空闲状态)</li>
<li>%CPU:进程占用CPU率</li>
<li>%MEM:进程占用内存率</li>
<li>TIME+:进程使用CPU时间总计,单位10毫秒</li>
<li>COMMAND:进程的命令或名称或程序文件路径</li>
</ul>
<p><strong>以下是<code>top</code>命令的常用选项及其功能：</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>-p</code></td>
<td>只显示某个进程的信息</td>
</tr>
<tr>
<td><code>-d</code></td>
<td>设置刷新时间，默认是5秒</td>
</tr>
<tr>
<td><code>-c</code></td>
<td>显示产生进程的完整命令，而不是进程名</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>指定刷新次数，例如<code>top -n 3</code>刷新输出3次后退出</td>
</tr>
<tr>
<td><code>-b</code></td>
<td>以非交互非全屏模式运行，以批次的方式执行<code>top</code>，一般配合<code>-n</code>指定输出几次统计信息，将输出重定向到指定文件，例如<code>top -b -n 3 &gt; /tmp/top.tmp</code></td>
</tr>
<tr>
<td><code>-i</code></td>
<td>不显示任何闲置(idle)或无用(zombie)的进程</td>
</tr>
<tr>
<td><code>-u</code></td>
<td>查找特定用户启动的进程</td>
</tr>
</tbody></table>
<p><strong>以下是<code>top</code>交互式模式(非-b选项启动)中常用的按键及其功能：</strong></p>
<table>
<thead>
<tr>
<th>按键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>h</td>
<td>显示帮助画面</td>
</tr>
<tr>
<td>c</td>
<td>显示产生进程的完整命令，等同于<code>-c</code>参数。再次按下<code>c</code>键，变为默认显示。</td>
</tr>
<tr>
<td>f</td>
<td>选择需要展示的项目</td>
</tr>
<tr>
<td>M</td>
<td>根据驻留内存大小(RES)排序</td>
</tr>
<tr>
<td>P</td>
<td>根据CPU使用百分比大小进行排序</td>
</tr>
<tr>
<td>T</td>
<td>根据时间&#x2F;累计时间进行排序</td>
</tr>
<tr>
<td>E</td>
<td>切换顶部内存显示单位</td>
</tr>
<tr>
<td>e</td>
<td>切换进程内存显示单位</td>
</tr>
<tr>
<td>1</td>
<td>切换显示平均负载和启动时间信息</td>
</tr>
<tr>
<td>i</td>
<td>不显示闲置或无用的进程，等同于<code>-i</code>参数。再次按下，变为默认显示。</td>
</tr>
<tr>
<td>t</td>
<td>切换显示CPU状态信息</td>
</tr>
<tr>
<td>m</td>
<td>切换显示内存信息</td>
</tr>
</tbody></table>
<h5 id="5-7-2-df-磁盘信息监控"><a href="#5-7-2-df-磁盘信息监控" class="headerlink" title="5.7.2 df(磁盘信息监控)"></a>5.7.2 df(磁盘信息监控)</h5><ul>
<li><code>df</code>：可以查看磁盘的使用情况</li>
<li>用法：<code>df [-h]</code><br>  <code>-h</code>：以更加人性化的单位显示</li>
</ul>
<h5 id="5-7-3-iostat-CPU-磁盘信息监控"><a href="#5-7-3-iostat-CPU-磁盘信息监控" class="headerlink" title="5.7.3 iostat(CPU,磁盘信息监控)"></a>5.7.3 iostat(CPU,磁盘信息监控)</h5><ul>
<li><code>iostat</code>：查看CPU、磁盘的相关信息</li>
<li>用法：<code>iostat [-x] [num1] [num2]</code><br>  <code>-x</code>: 显示更多信息<br>  [常用：<code>rKB/s</code>:每秒发送到设备的读取请求数，<code>wKB/s</code>:每秒发送到设备的写入请求数， <code>%utill</code>:磁盘利用率]<br>  <code>num1</code>: 刷新间隔<br>  <code>num2</code>: 刷新次数</li>
</ul>
<h5 id="5-7-4-sar-网络状态监控-sar命令非常复杂，这里仅简单用于统计网络"><a href="#5-7-4-sar-网络状态监控-sar命令非常复杂，这里仅简单用于统计网络" class="headerlink" title="5.7.4 sar(网络状态监控)[sar命令非常复杂，这里仅简单用于统计网络]"></a>5.7.4 sar(网络状态监控)[sar命令非常复杂，这里仅简单用于统计网络]</h5><ul>
<li><code>sar</code>:查看网络的相关统计</li>
<li>用法：<code>sar -n DEV num1 num2</code><br>  <code>-n</code> 查看网络<br>  <code>DEV</code> 查看网络接口<br>  <code>num1</code> 刷新间隔<br>  <code>num2</code> 查看次数</li>
<li>[常用信息：<code>IFACE</code>：本地网卡接口的名称，<code>rxKB/s</code>：每秒接收的数据包大小，<code>txKB/s</code>：每秒发送的数据包大小]</li>
</ul>
<h4 id="5-8环境变量"><a href="#5-8环境变量" class="headerlink" title="5.8环境变量"></a>5.8环境变量</h4><h5 id="5-8-1-env-查看环境变量"><a href="#5-8-1-env-查看环境变量" class="headerlink" title="5.8.1 env(查看环境变量)"></a>5.8.1 env(查看环境变量)</h5><ul>
<li><code>env</code>：查看当前系统中记录的环境变量</li>
<li>用法：<code>env</code><br><strong>PATH(环境变量)：</strong></li>
<li><code>PATH</code>：记录了系统执行任何命令的搜索路径<br>  [当在终端输入命令的时候，他会先从PATH中找这条命令所对应的程序，找不到就从当前路径下找]</li>
</ul>
<h5 id="5-8-2-取”变量”的值"><a href="#5-8-2-取”变量”的值" class="headerlink" title="5.8.2 $(取”变量”的值)"></a>5.8.2 $(取”变量”的值)</h5><ul>
<li><code>$</code>：用于取”变量”的值</li>
<li>用法：<code>echo $环境变量名</code></li>
</ul>
<blockquote><p><strong>举例：</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-23%20113912.png"
                     
                ><br>如果要在环境变量后面追加上打印的信息，环境变量要用花括号包围起来</p>
</blockquote>
<h5 id="5-8-3-export-设置环境变量"><a href="#5-8-3-export-设置环境变量" class="headerlink" title="5.8.3 export(设置环境变量)"></a>5.8.3 export(设置环境变量)</h5><ul>
<li><code>export</code>：可以自行设置环境变量</li>
<li>用法:<ul>
<li><p>临时生效：<br>  <code>export 变量名=变量值</code></p>
</li>
<li><p>永久生效：<br>  <code>export 变量名=变量值</code>    </p>
<ul>
<li>针对<strong>当前用户</strong>生效，配置在当前用户的 <code>~/bashrc</code>文件中</li>
<li>针对<strong>所有用户</strong>生效，配置在系统的 <code>/etc/profile</code>文件中</li>
</ul>
<p>  并通过语法：<code>source 配置文件(~/bashrc或者/etc/profile)</code>，进行立即生效，或者重新启动系统</p>
</li>
</ul>
</li>
</ul>
<h5 id="5-8-4-自定义环境变量PATH"><a href="#5-8-4-自定义环境变量PATH" class="headerlink" title="5.8.4 自定义环境变量PATH"></a>5.8.4 自定义环境变量PATH</h5><ul>
<li>创建一个可以执行的文件[自定义想要添加的文件]</li>
<li><code>vim /etc/profile</code>[编写这个文件]</li>
<li>在最后面加上 <code>export PATH=$PATH:自己要添加的搜索路径</code></li>
<li><code>source 配置文件(/etc/profile)</code>，进行立即生效，或者重新启动系统</li>
</ul>
<h4 id="5-9-上传-下载"><a href="#5-9-上传-下载" class="headerlink" title="5.9 上传&#x2F;下载"></a>5.9 上传&#x2F;下载</h4><p>可以通过<strong>FinalShell</strong>的下方窗体进行文件的传输，<br>也可以通过<code>rz</code>,<code>sz</code>命令进行文件的传输[插件，<code>yum -y install lrzsz</code>]</p>
<h5 id="5-9-1-rz-上传"><a href="#5-9-1-rz-上传" class="headerlink" title="5.9.1 rz(上传)"></a>5.9.1 rz(上传)</h5><ul>
<li><code>rz</code>：进行上传</li>
<li>用法：<code>rz</code>[会弹出可视窗口]</li>
</ul>
<h5 id="5-9-2-sz-下载"><a href="#5-9-2-sz-下载" class="headerlink" title="5.9.2 sz(下载)"></a>5.9.2 sz(下载)</h5><ul>
<li><code>sz</code>：进行下载</li>
<li>用法：<code>sz 要下载的文件</code><br>[文件会自动下载到桌面的：<strong>fsdownload</strong>文件夹中]</li>
</ul>
<h4 id="5-10-压缩-解压"><a href="#5-10-压缩-解压" class="headerlink" title="5.10 压缩&#x2F;解压"></a>5.10 压缩&#x2F;解压</h4><ul>
<li>Linux和Mac系统常用的2种压缩方式<ul>
<li><code>.tar</code>：称为<code>tarball</code>，归档文件，简单的将文件组装成一个<code>.tar</code>的文件内，并没有太多文件体积的减少，仅仅是简单的封装</li>
<li><code>.gz</code>：也称为<code>.tar.gz</code>,<code>gzip</code>格式压缩文件，即使用<strong>gzip</strong>压缩算法将文件压缩到一个文件内可以极大的减少压缩后的体积</li>
</ul>
</li>
</ul>
<h5 id="5-10-1-tar-压缩-解压"><a href="#5-10-1-tar-压缩-解压" class="headerlink" title="5.10.1 tar(压缩&#x2F;解压)"></a>5.10.1 tar(压缩&#x2F;解压)</h5><ul>
<li><code>tar</code>：可以针对上述的两种格式进行压缩和解压操作</li>
<li>用法：<code>tar [-c -x -v -f -z -C] 参数1 参数2 …… 参数N</code><br>  <code>-c</code>：创建归档文件，用于压缩模式<br>  <code>-x</code>：解压模式<br>  <code>-v</code>：显示压缩，解压过程，用于查看进度<br>  <code>-f</code>：指定要创建的文件名或要解压的文件名，<code>-f</code>必须处于选项位最后一个(后面必须紧跟要创建的文件名或要解压的文件名)<br>  <code>-z</code>：gzip模式，不使用<code>-z</code>则是普通的tarball格式(如果要用的话，一般放在选项位第一位)<br>  <code>-C</code>：选择解压的目的地，用于解压模式。如果没有使用<code>-C</code>,默认解压到当前目录(建议单独使用，和解压所需的其它参数分开)</li>
</ul>
<blockquote><p><strong>tar的常用组合：</strong></p>
<ul>
<li><code>tar -cvf 压缩的文件名 要压缩的文件</code><ul>
<li>eg: <strong>tar -cvf test.tar 1.txt 2.txt 3.txt</strong><br>  将1.txt 2.txt 3.txt压缩到test.tar文件内</li>
</ul>
</li>
<li><code>tar -zcvf 压缩的文件名 要压缩的文件</code><ul>
<li>eg: <strong>tar -zcvf test.tar.gz 1.txt 2.txt 3.txt</strong><br>  将1.txt 2.txt 3.txt压缩到test.tar.gz文件内,使用gzip模式</li>
</ul>
</li>
<li><code>tar -xvf 解压的文件名</code></li>
<li><code>tar -xvf 解压的文件名 -C Linux路径</code></li>
<li><code>tar -zxvf 解压的文件名 -C Linux路径</code></li>
</ul>
</blockquote>

<h5 id="5-10-2-zip-unzip-压缩-解压"><a href="#5-10-2-zip-unzip-压缩-解压" class="headerlink" title="5.10.2 zip&#x2F;unzip(压缩&#x2F;解压)"></a>5.10.2 zip&#x2F;unzip(压缩&#x2F;解压)</h5><ul>
<li><code>zip</code>：压缩为zip压缩包</li>
<li>用法：<code>zip [-r] 参数1 参数2 …… 参数N</code><br>  <code>-r</code>：被压缩的包含文件夹时，需要使用<br>  <code>参数</code>：包含创建的压缩文件名 + 要压缩的文件</li>
<li><code>unzip</code>：解压zip文件</li>
<li>用法：<code>zip [-d] 参数1 参数2 …… 参数N</code><br>  <code>-d</code>：指定要解压去的位置，同<code>tar</code>的<code>-C</code>文件</li>
</ul>
<blockquote><p><strong>注意：</strong><br>以上的解压操作如果指定的解压文件名存在，原来文件中的内容会直接被替换(覆盖)，要注意是否文件名已经存在或文件中的内容是否重要</p>
</blockquote>

<h3 id="补充命令-scp"><a href="#补充命令-scp" class="headerlink" title="补充命令 - scp"></a>补充命令 - scp</h3><ul>
<li><code>scp</code>：是cp命令的升级版，即：ssh cp，通过SSH协议完成文件的复制。<br>其主要的功能就是：在不同的Linux服务器之间，通过<code>SSH</code>协议互相传输文件。<br>只要知晓服务器的账户和密码（或密钥），即可通过SCP互传文件。<br>语法：</li>
<li>用法：<code>scp [-r] 参数1 参数2</code><br>  <code>-r</code>：选项用于复制文件夹使用，如果复制文件夹，必须使用-r<br>  <code>参数1</code>：本机路径 或 远程目标路径<br>  <code>参数2</code>：远程目标路径 或 本机路径</li>
</ul>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r /export/server/jdk root@node2:/export/server/</span><br><span class="line">将本机上的jdk文件夹， 以root的身份复制到node2的/export/server/内</span><br><span class="line">同SSH登陆一样，账户名可以省略（使用本机当前的同名账户登陆）</span><br><span class="line"></span><br><span class="line">scp -r node2:/export/server/jdk /export/server/</span><br><span class="line">将远程node2的jdk文件夹，复制到本机的/export/server/内</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">scp命令的高级用法</span></span><br><span class="line">cd /export/server</span><br><span class="line">scp -r jdk node2:`pwd`/    # 将本机当前路径的jdk文件夹，复制到node2服务器的同名路径下</span><br><span class="line">scp -r jdk node2:$PWD      # 将本机当前路径的jdk文件夹，复制到node2服务器的同名路径下</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringRedisTemplate 使用</title>
    <url>/2024/07/16/StringRedisTemplate/</url>
    <content><![CDATA[<h2 id="SpringRedisTemplate-使用"><a href="#SpringRedisTemplate-使用" class="headerlink" title="SpringRedisTemplate 使用"></a>SpringRedisTemplate 使用</h2><h3 id="导入Maven依赖"><a href="#导入Maven依赖" class="headerlink" title="导入Maven依赖"></a>导入Maven依赖</h3><div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="配置Redis数据源"><a href="#配置Redis数据源" class="headerlink" title="配置Redis数据源"></a>配置Redis数据源</h3><div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<h3 id="编写配置类"><a href="#编写配置类" class="headerlink" title="编写配置类"></a>编写配置类</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许Object类型的key-value，都可以被转为json进行存储。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisConnectionFactory 自动配置好了连接工厂</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//把对象转为json字符串的序列化工具</span></span><br><span class="line">        template.setDefaultSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411101347560.png"
                      alt="image-20241110134704456"
                ></p>
<p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p>
<h3 id="StringRedisTemplate-手动序列化"><a href="#StringRedisTemplate-手动序列化" class="headerlink" title="StringRedisTemplate + 手动序列化"></a>StringRedisTemplate + 手动序列化</h3><p>为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。</p>
<p>为了减少内存的消耗，我们可以采用手动序列化的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入一条String数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;verify:phone:13600527634&quot;</span>, <span class="string">&quot;124143&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取string数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;虎哥&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="comment">// 手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">        <span class="comment">// 手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411101346894.png"
                      alt="image-20241110134623832"
                ></p>
<h3 id="redis客户端"><a href="#redis客户端" class="headerlink" title="redis客户端"></a>redis客户端</h3><p>RedisTemplate、StringRedisTemplate： 操作redis的工具类</p>
<ul>
<li><p>要从redis的连接工厂获取链接才能操作redis</p>
</li>
<li><p><strong>Redis客户端</strong></p>
<ul>
<li><p>Lettuce： 默认</p>
</li>
<li><p>Jedis：可以使用以下切换</p>
</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--切换 jedis 作为操作redis的底层客户端--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>配置参考</strong></p>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">8.138</span><span class="number">.192</span><span class="number">.185</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="string">1000ms</span></span><br><span class="line"><span class="comment">#      jedis:</span></span><br><span class="line"><span class="comment">#        pool:</span></span><br><span class="line"><span class="comment">#          enabled: true</span></span><br><span class="line"><span class="comment">#          max-active: 8</span></span><br><span class="line"><span class="comment">#          max-idle: 8</span></span><br><span class="line"><span class="comment">#          min-idle: 0</span></span><br><span class="line"><span class="comment">#          max-wait: 1000ms</span></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>工具集</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java IO流</title>
    <url>/2024/06/01/JavaWeb/</url>
    <content><![CDATA[<h1 id="JavaWeb学习"><a href="#JavaWeb学习" class="headerlink" title="JavaWeb学习"></a>JavaWeb学习</h1><h2 id="1-初识web前端"><a href="#1-初识web前端" class="headerlink" title="1.初识web前端"></a>1.初识web前端</h2><p><strong>Web标准</strong><br>Web标准也称为网页标准，由一系列的标准组成，大部分由W3C（World Wide Web Consortium，万维网联盟）组织制定。</p>
<ul>
<li>三个组成部分：<ul>
<li><strong>HTML</strong>：负责<strong>网页的结构</strong>（页面元素和内容）</li>
<li><strong>CSS</strong>：负责<strong>页面的表现</strong>（页面元素的外观，位置等页面样式，如：颜色、大小等）</li>
<li><strong>JavaScript</strong>：负责<strong>页面的行为</strong>（页面元素的交互，如：鼠标点击、滑动等） ^f1dcc5</li>
</ul>
</li>
</ul>
<h3 id="1-1-HTML"><a href="#1-1-HTML" class="headerlink" title="1.1 HTML"></a>1.1 HTML</h3><p>HTML（HyperText Markup Language）：超文本标记语言。</p>
<ul>
<li><strong>超文本</strong>：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容。</li>
<li><strong>标记语言</strong>：由标签构成的语言。<ul>
<li>HTML标签都是<strong>预定义</strong>好的。例如：使用&lt;a&gt;展示超链接，使用&lt;img&gt;展示图片、&lt;video&gt;展示视频等。</li>
<li>HTML代码直接在浏览器中运行，HTML标签由浏览器解析。</li>
</ul>
</li>
</ul>
<p><strong>HTML结构标签</strong>：</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里设置了HTML文档的基本结构，包括文档类型、语言、字符编码和视口设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里是网页的主体部分，内容将显示在这里 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p><strong>语言特点</strong>：</p>
<ul>
<li>HTML标签不区分大小写</li>
<li>HTML标签属性值单双引号都可以</li>
<li>HTML语法松散</li>
<li>在HTML中无论输入多少个空格，只会显示一个，可以使用空格占位符：<code>&amp;nbsp;</code></li>
</ul>
<h4 id="1-1-1-标题标签"><a href="#1-1-1-标题标签" class="headerlink" title="1.1.1 标题标签"></a>1.1.1 标题标签</h4><ul>
<li><strong>标签</strong>：&lt;h1&gt;…&lt;h1&gt; (h1 -&gt; h6 重要程度依次降低)</li>
<li><strong>示例</strong>：<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>标题3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="1-1-2-水平线标签"><a href="#1-1-2-水平线标签" class="headerlink" title="1.1.2 水平线标签"></a>1.1.2 水平线标签</h4><ul>
<li><strong>标签</strong>：&lt;hr&gt;</li>
</ul>
<h4 id="1-1-3-换行标签"><a href="#1-1-3-换行标签" class="headerlink" title="1.1.3 换行标签"></a>1.1.3 换行标签</h4><ul>
<li><strong>标签</strong>：&lt;br&gt;</li>
</ul>
<h4 id="1-1-4-段落标签"><a href="#1-1-4-段落标签" class="headerlink" title="1.1.4 段落标签"></a>1.1.4 段落标签</h4><ul>
<li><strong>标签</strong>：&lt;p&gt;…&lt;p&gt;</li>
</ul>
<h4 id="1-1-5-文本加粗标签"><a href="#1-1-5-文本加粗标签" class="headerlink" title="1.1.5 文本加粗标签"></a>1.1.5 文本加粗标签</h4><ul>
<li><strong>标签</strong>：&lt;b&gt;…&lt;&#x2F;b&gt; 或者 &lt;strong&gt;…&lt;&#x2F;strong&gt;</li>
</ul>
<h4 id="1-1-6-图片标签"><a href="#1-1-6-图片标签" class="headerlink" title="1.1.6 图片标签"></a>1.1.6 图片标签</h4><ul>
<li><strong>标签</strong>：&lt;img src&#x3D;”图片路径” width&#x3D;”宽度” height&#x3D;”高度” alt&#x3D;”替代文本”&gt;<ul>
<li><code>src</code>：指定图像的路径url（绝对路径&#x2F;相对路径）</li>
<li><code>width</code>：指定图像的宽度（像素&#x2F;相对于父元素的百分比）</li>
<li><code>height</code>：指定图像的高度（像素&#x2F;相对于父元素的百分比）</li>
<li><code>alt</code>：指定图像的替代文本<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808220223.png"
                     
                ></li>
</ul>
</li>
</ul>
<h4 id="1-1-7-视频标签"><a href="#1-1-7-视频标签" class="headerlink" title="1.1.7 视频标签"></a>1.1.7 视频标签</h4><ul>
<li><strong>标签</strong>：&lt;video src&#x3D;”视频路径” controls width&#x3D;”宽度” height&#x3D;”高度”&gt;<ul>
<li><code>src</code>：指定视频文件的路径url（绝对路径&#x2F;相对路径）</li>
<li><code>controls</code>：指定是否显示播放控件</li>
<li><code>width</code>：指定视频的宽度（像素&#x2F;相对于父元素的百分比）</li>
<li><code>height</code>：指定视频的高度（像素&#x2F;相对于父元素的百分比）</li>
</ul>
</li>
</ul>
<h4 id="1-1-8-音频标签"><a href="#1-1-8-音频标签" class="headerlink" title="1.1.8 音频标签"></a>1.1.8 音频标签</h4><ul>
<li><strong>标签</strong>：&lt;audio src&#x3D;”音频路径” controls&gt;<ul>
<li><code>src</code>：指定音频文件的路径url（绝对路径&#x2F;相对路径）</li>
<li><code>controls</code>：指定是否显示播放控件</li>
</ul>
</li>
</ul>
<h4 id="1-1-9-超链接标签"><a href="#1-1-9-超链接标签" class="headerlink" title="1.1.9 超链接标签"></a>1.1.9 超链接标签</h4><ul>
<li><strong>标签</strong>：&lt;a href&#x3D;”链接地址” target&#x3D;”…”&gt;链接文本&lt;&#x2F;a&gt;<ul>
<li><code>href</code>：指定链接地址url（绝对路径&#x2F;相对路径）</li>
<li><code>target</code>：指定链接打开方式（_self：默认值，当前窗口打开；_blank：新窗口打开）</li>
</ul>
</li>
</ul>
<h4 id="1-1-10-布局标签"><a href="#1-1-10-布局标签" class="headerlink" title="1.1.10 布局标签"></a>1.1.10 布局标签</h4><p>实际开发网页中，会大量频繁的使用div和span这两个没有<strong>语义</strong>的布局标签。</p>
<ul>
<li><strong>标签</strong>：&lt;div&gt;…&lt;&#x2F;div&gt; 或者 &lt;span&gt;…&lt;&#x2F;span&gt;</li>
<li><strong>特点</strong>：<ul>
<li><code>div标签</code>:<ul>
<li>一行只显示一个（独占一行）</li>
<li>宽度默认是父元素的宽度，高度默认由内容撑开</li>
<li>可以设置宽高（width、height）</li>
</ul>
</li>
<li><code>span标签</code>：<ul>
<li>一行可以显示多个（不独占一行）</li>
<li>宽度和高度默认由内容撑开</li>
<li>可以设置宽高（width、height）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-1-11-表格标签"><a href="#1-1-11-表格标签" class="headerlink" title="1.1.11 表格标签"></a>1.1.11 表格标签</h4><ul>
<li><strong>标签</strong>：<ul>
<li>&lt;table&gt;…&lt;&#x2F;table&gt;：定义表格</li>
<li>&lt;tr&gt;…&lt;&#x2F;tr&gt;：定义表格中的行，一个&lt;tr&gt;表示一行</li>
<li>&lt;th&gt;…&lt;&#x2F;th&gt;：表示表头单元格，具有加粗居中效果</li>
<li>&lt;td&gt;…&lt;&#x2F;td&gt;：表示普通单元格</li>
</ul>
</li>
<li><strong>场景</strong>：在网页中以表格（行、列）形式整齐展示数据，如：班级表。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808222416.png"
                     
                ></li>
</ul>
<h4 id="1-1-12-表单标签"><a href="#1-1-12-表单标签" class="headerlink" title="1.1.12 表单标签"></a>1.1.12 表单标签</h4><ul>
<li><strong>标签</strong>：&lt;form action&#x3D;”提交地址” method&#x3D;”提交方式”&gt;<ul>
<li><code>action</code>：指定表单提交的地址url（绝对路径&#x2F;相对路径）</li>
<li><code>method</code>：指定表单提交的方式（get&#x2F;post）<ul>
<li><code>get</code>：表单数据拼接在url后面，大小有限制。eg：?username&#x3D;java</li>
<li><code>post</code>：表单数据放在请求体中，大小无限制。eg：username&#x3D;java</li>
</ul>
</li>
</ul>
</li>
<li><strong>表单项</strong>：<ul>
<li><code>&lt;input type=&quot;…&quot;&gt;</code>：定义表单项，通过type属性控制输入形式</li>
<li><code>&lt;select&gt;…&lt;/select&gt;</code>：定义下拉列表，&lt;option&gt;定义列表项</li>
<li><code>&lt;textarea&gt;…&lt;/textarea&gt;</code>：定义多行文本输入框<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808223456.png"
                     
                ><blockquote>
<p><strong>注意</strong>：表单项必须有name属性才可以提交。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808224516.png"
                     
                ></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="1-2-CSS"><a href="#1-2-CSS" class="headerlink" title="1.2 CSS"></a>1.2 CSS</h3><p>CSS（Cascading Style Sheets）：层叠样式表，用于控制页面的样式（表现）。</p>
<h4 id="1-2-1-盒子模型"><a href="#1-2-1-盒子模型" class="headerlink" title="1.2.1 盒子模型"></a>1.2.1 盒子模型</h4><ul>
<li><strong>盒子</strong>：页面中的所有元素（标签），都可以看做是一个<span style="color: red;"><strong>盒子</strong></span>，由盒子将页面中的元素包含在一个矩形区域内，通过盒子的视角更方便的进行页面布局</li>
<li><strong>盒子模型</strong>：盒子由<span style="color: red;"><strong>内容区域（content）</strong>、<strong>内边距区域（padding）</strong>、<strong>边框区域（border）</strong>、<strong>外边距区域（margin）</strong></span>组成。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808230724.png"
                     
                ></li>
<li><strong>属性</strong>：<ul>
<li><code>width</code>：设置盒子的宽度</li>
<li><code>height</code>：设置盒子的高度</li>
<li><code>border</code>：设置盒子的边框属性，如：border: 1px solid red&#x2F;#000&#x2F;……;</li>
<li><code>padding</code>：设置盒子的内边距</li>
<li><code>margin</code>：设置盒子的外边距<blockquote>
<p><strong>注意</strong>：如果只需要设置某一个方位的边框、内边距、外边距，可以在属性名后加上 -位置，如：border-top、padding-left、margin-right。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="1-2-2-CSS引入方式"><a href="#1-2-2-CSS引入方式" class="headerlink" title="1.2.2 CSS引入方式"></a>1.2.2 CSS引入方式</h4><ul>
<li><strong>行内样式</strong>：写在标签的style属性中（不推荐）<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span>…<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong>内嵌模式</strong>：写在style标签中（可以写在页面任何位置，但通常约定写在head标签中）<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="language-css">        &lt;--!属性名：属性值;--&gt;</span></span><br><span class="line"><span class="language-css">        xxx: xxx; </span></span><br><span class="line"><span class="language-css">        xxx: xxx;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong>外联模式</strong>：写在外部一个单独的.css文件中（需要通过 link 标签在网页中引入）<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/style.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="1-2-3-CSS选择器"><a href="#1-2-3-CSS选择器" class="headerlink" title="1.2.3 CSS选择器"></a>1.2.3 CSS选择器</h4><ul>
<li>元素选择器：标签名 {…}</li>
<li>id选择器：#id属性值 {…}</li>
<li>类选择器：.class属性值 {…}<br><strong>优先级</strong>：id选择器 &gt; 类选择器 &gt; 元素选择器<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808234246.png"
                     
                ></li>
</ul>
<h4 id="1-2-4-CSS属性"><a href="#1-2-4-CSS属性" class="headerlink" title="1.2.4 CSS属性"></a>1.2.4 CSS属性</h4><ul>
<li><p><strong>颜色和背景</strong></p>
<ul>
<li><code>color</code>：设置文本颜色。</li>
<li><code>background-color</code>：设置背景颜色。</li>
<li><code>background-image</code>：设置背景图片。</li>
<li><code>background-repeat</code>：设置背景图片的重复方式。</li>
<li><code>background-size</code>：设置背景图片的大小。</li>
</ul>
</li>
<li><p><strong>字体和文本</strong></p>
<ul>
<li><code>font-family</code>：设置字体系列。</li>
<li><code>font-size</code>：设置字体大小（记得加px）</li>
<li><code>font-weight</code>：设置字体粗细。</li>
<li><code>font-style</code>：设置字体样式（例如：italic）。</li>
<li><code>text-transform</code>：设置文本的大小写（uppercase, lowercase, capitalize）。</li>
<li><code>text-decoration</code>：设置文本的装饰（underline, overline, line-through, none）。</li>
<li><code>letter-spacing</code>：设置字母间距。</li>
<li><code>word-spacing</code>：设置单词间距。</li>
</ul>
</li>
<li><p><strong>边距和填充</strong></p>
<ul>
<li><code>margin</code>：设置外边距。</li>
<li><code>padding</code>：设置内边距。</li>
</ul>
</li>
<li><p><strong>边框</strong></p>
<ul>
<li><code>border</code>：设置边框。</li>
<li><code>border-width</code>：设置边框宽度。</li>
<li><code>border-style</code>：设置边框样式（solid, dashed, dotted）。</li>
<li><code>border-color</code>：设置边框颜色。</li>
<li><code>border-radius</code>：设置圆角边框。</li>
</ul>
</li>
<li><p><strong>布局</strong></p>
<ul>
<li><code>display</code>：设置元素的显示类型（block, inline, flex, grid, none）。</li>
<li><code>position</code>：设置元素的定位类型（static, relative, absolute, fixed, sticky）。</li>
<li><code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code>：设置定位偏移。</li>
<li><code>z-index</code>：设置元素的堆叠顺序。</li>
<li><code>overflow</code>：设置溢出内容的处理方式（visible, hidden, scroll, auto）。</li>
</ul>
</li>
<li><p><strong>尺寸</strong></p>
<ul>
<li><code>width</code>：设置元素的宽度。</li>
<li><code>height</code>：设置元素的高度。</li>
<li><code>max-width</code>：设置元素的最大宽度。</li>
<li><code>max-height</code>：设置元素的最大高度。</li>
<li><code>min-width</code>：设置元素的最小宽度。</li>
<li><code>min-height</code>：设置元素的最小高度。</li>
</ul>
</li>
<li><p><strong>浮动和清除</strong></p>
<ul>
<li><code>float</code>：设置元素的浮动（left, right, none）。</li>
<li><code>clear</code>：设置浮动的清除（left, right, both, none）。</li>
</ul>
</li>
<li><p><strong>表格</strong></p>
<ul>
<li><code>border-collapse</code>：设置是否合并表格边框。</li>
<li><code>border-spacing</code>：设置表格单元之间的边框间距。</li>
<li><code>caption-side</code>：设置表格标题的位置（top, bottom）。</li>
<li><code>empty-cells</code>：设置是否显示空单元格（show, hide）。</li>
</ul>
</li>
<li><p><strong>其它</strong></p>
<ul>
<li><code>line-height</code>：设置行高</li>
<li><code>text-indent</code>：设置首行的缩进</li>
<li><code>text-align</code>：设置元素中文本的水平对齐方式（left&#x2F;center&#x2F;right&#x2F;justify）</li>
</ul>
</li>
</ul>
<h3 id="1-3-JavaScript"><a href="#1-3-JavaScript" class="headerlink" title="1.3 JavaScript"></a>1.3 JavaScript</h3><ul>
<li>JavaScript（简称：JS）是一门跨平台、面向对象的脚本语言。是用来控制网页行为的语言，它能使网页可交互。</li>
<li>JavaScript和Java是完全不同的语言，不论是概念还是设计，但是基础语法类似。</li>
<li>JavaScript在1995年由Brendan Eich发明，并于1997年成为ECMA标准。</li>
<li>ECMAScript 6（ES6）是最新的JavaScript版本。</li>
</ul>
<blockquote>
<p><strong>ECMA</strong>：ECMA国际（前身为欧洲计算机制造商协会），制定了标准化的脚本程序设计语言 ECMAScript，这种语言得到广泛应用。而JavaScript是遵守ECMAScript标准的脚本语言。</p>
</blockquote>
<h4 id="1-3-1-JS引入方式"><a href="#1-3-1-JS引入方式" class="headerlink" title="1.3.1 JS引入方式"></a>1.3.1 JS引入方式</h4><ul>
<li><strong>内部脚本</strong>：将JS代码定义在HTML页面中<ul>
<li>JavaScript代码必须位于<code>&lt;script&gt;……&lt;/script&gt;</code>标签之间</li>
<li>在HTML文档中，可以在任意地方，放置任意数量的&lt;script&gt;标签</li>
<li>一般会把脚本置于&lt;body&gt;标签中，这样，脚本会在页面加载后执行，改善显示速度。</li>
</ul>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="string">&quot;Hello JavaScript!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong>外部脚本</strong>：将JS代码定义在外部单独的JS文件中，然后引入到HTML页面中<ul>
<li>外部JS文件中，只包含JS代码，不包含&lt;script&gt;标签,也不包含HTML代码</li>
<li>&lt;script&gt;标签不能自闭合</li>
</ul>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/demo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo.js文件</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;Hello JavaScript!&quot;</span>);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="1-3-2-基础语法"><a href="#1-3-2-基础语法" class="headerlink" title="1.3.2 基础语法"></a>1.3.2 基础语法</h4><p><strong>1.书写语法</strong>:</p>
<ul>
<li><strong>区分大小写</strong>：JavaScript区分大小写，变量名、函数名、关键字等必须使用正确的大小写。</li>
<li>每行结尾的分号可有可无</li>
<li><strong>注释</strong>：<ul>
<li>单行注释：&#x2F;&#x2F; 注释内容</li>
<li>多行注释：&#x2F;* 注释内容 *&#x2F;</li>
</ul>
</li>
<li><strong>大括号表示代码块</strong>：<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="title function_">alter</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<strong>2.输出语句</strong>：</li>
<li>使用 <code>window.alert()</code> 函数输出警告框【window可以省略】</li>
<li>使用<code>document.write()</code> 函数输出到页面</li>
<li>使用 <code>console.log()</code> 函数输出到浏览器控制台</li>
</ul>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot;Hello JavaScript!&quot;</span>); <span class="comment">// 浏览器弹出警告框</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;Hello JavaScript!&quot;</span>); <span class="comment">// 写入HTML，在浏览器中显示</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello JavaScript!&quot;</span>); <span class="comment">// 写入浏览器控制台</span></span><br></pre></td></tr></table></figure></div>
<p><strong>3.变量</strong>：</p>
<ul>
<li>JavaScript中用 <code>var</code> 关键字（variable的缩写）声明变量。<ul>
<li>var 声明的变量在其所在的函数或全局范围内有效，具有<strong>函数作用域</strong>，而不是块级作用域。这意味着即使 var 声明在块（如 if 或 for 循环）内部，变量仍然在函数范围内或全局范围内有效。</li>
<li>var声明的变量可以被重复声明，这可能导致意外的行为，因此在现代JavaScript中通常不推荐使用。</li>
</ul>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">&quot;A&quot;</span>; <span class="comment">// 允许重复声明</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出 &quot;A&quot;</span></span><br></pre></td></tr></table></figure></div></li>
<li>JavaScript是一门<strong>弱类型</strong>语言，变量<font color="red">可以存放不同类型的值</font>。<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="string">&quot;张三&quot;</span>;<span class="comment">// 变量 `a` 的类型从数字变成了字符串</span></span><br></pre></td></tr></table></figure></div></li>
<li>变量名需要遵循如下规则：<ul>
<li>组成字符可以是任何字母、下划线、$符号</li>
<li>不能以数字开头</li>
<li>建议使用驼峰命名</li>
</ul>
</li>
</ul>
<blockquote>
<p> <strong>注意</strong>：</p>
<ul>
<li>ECMAScript 6（ES6）中，新增了<code>let</code>关键字来定义变量。它的作用类似于var，但是所声明的变量具有<strong>块级作用域</strong>，只在let关键字所在的代码块中有效，且不能重复声明。</li>
</ul>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// let b = 20; // 会抛出错误，因为 `b` 已经在同一块级作用域中声明过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>ECMAScript 6（ES6）中，新增了<code>const</code>关键字，用来声明一个只读的常量，常量的值一旦声明就不能改变。<font color="red">【但是，const 并不意味着所引用的对象是不可变的。如果 const 引用的是一个对象（包括数组），对象的内容是可以改变的】</font></li>
</ul>
 <div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// c = 20; // 会抛出错误，因为 `c` 是常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span> &#125;;</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;李四&quot;</span>; <span class="comment">// 允许改变对象内部属性的值</span></span><br></pre></td></tr></table></figure></div></blockquote>
<p><strong>4.数据类型</strong>：<br>JavaScript中的数据类型分为：<strong>原始类型</strong>和<strong>引用类型</strong>。</p>
<ul>
<li><strong>原始类型</strong>：<ul>
<li><code>number</code>：表示数字类型，可以是整数、浮点数和 NaN（Not a Number）。</li>
<li><code>string</code>：表示字符串类型，单引号和双引号都可以。</li>
<li><code>boolean</code>：表示布尔类型，只能是 true 或 false。</li>
<li><code>null</code>：表示空值，表示一个空对象。</li>
<li><code>undefined</code>：表示未定义的值，表示一个未初始化的变量。</li>
</ul>
</li>
<li><strong>引用类型</strong>：<ul>
<li><code>object</code>：用于存储键值对的集合。对象的键（属性）可以是字符串或符号，值可以是任何类型的数据，包括其它对象。</li>
<li><code>array</code>：用于存储有序列表的集合。数组的元素可以是任何类型的数据，包括其它数组。可以通过索引（从0开始）访问数组的元素。</li>
<li><code>function</code>：表示函数类型。函数在JavaScript中是”一等公民”，意味着函数可以作为变量的值，作为参数传递给其他函数，也可以作为返回值。</li>
<li>……</li>
</ul>
</li>
</ul>
<blockquote>
<p>使用<code>typeof</code>关键字可以获取变量的类型。</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="title function_">alter</span>(<span class="keyword">typeof</span> a);</span><br></pre></td></tr></table></figure></div></blockquote>
<p><strong>5.运算符</strong>：</p>
<ul>
<li><strong>算术运算符</strong>：+，-，*，&#x2F;，%，++，–</li>
<li><strong>赋值运算符</strong>：&#x3D;，+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;，%&#x3D;</li>
<li><strong>比较运算符</strong>：<mark>，!&#x3D;，<code>&lt;/mark&gt;=</code>，<code>!==</code>，&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;</li>
<li><strong>逻辑运算符</strong>：&amp;&amp;，||，!</li>
<li><strong>三元运算符</strong>：条件表达式? true_value: false_value，</li>
</ul>
<blockquote>
<p><code>&lt;mark&gt;</code>与<code>&lt;/mark&gt;=</code>的区别：</p>
<ul>
<li><code>==</code>：比较两个值是否相等，忽略类型。【会进行类型转换】</li>
<li><code>===</code>：比较两个值是否相等，同时比较类型。【不会进行类型转换】</li>
</ul>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="title function_">alter</span>(a == <span class="string">&quot;10&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alter</span>(a === <span class="string">&quot;10&quot;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="title function_">alter</span>(a == <span class="number">10</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
<p><strong>类型转换</strong>：</p>
<ul>
<li><strong>字符串类型转为数字</strong>：<ul>
<li>将字符串面值转为数字。如果字面值不是数字，则返回NaN。</li>
</ul>
</li>
<li><strong>其它类型转为boolean</strong>：<ul>
<li>Number：0和NAN为false，其它为true。</li>
<li>String：空字符串为false，其它为true。</li>
<li>Null和Undefined为false。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>parseInt()</strong>：将字符串转为整数的函数。它的语法如下：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(string, radix)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>string</strong>: 你想要解析的字符串。这个字符串的开头可以包含空格，但在遇到第一个无法转换为数字的字符时，<code>parseInt</code> 会停止解析并返回已经解析的部分。字符串中的非数字字符会导致解析停止。</p>
</li>
<li><p><strong>radix</strong>: 可选参数，表示进制数。它的值可以在 2 到 36 之间。如果不指定 <code>radix</code>，<code>parseInt</code> 会根据字符串的内容自动确定进制：</p>
<ul>
<li>如果字符串以 “0x” 或 “0X” 开头，<code>parseInt</code> 会将其视为 16 进制。</li>
<li>如果字符串以 “0” 开头，<code>parseInt</code> 会将其视为 8 进制（在老版本的 JavaScript 中，现代浏览器已经不再这么处理）。</li>
<li>否则，<code>parseInt</code> 会将其视为 10 进制。</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;42&quot;</span>);           <span class="comment">// 返回 42</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;101&quot;</span>, <span class="number">2</span>);       <span class="comment">// 返回 5 (二进制的 101 为十进制的 5)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;0xF&quot;</span>, <span class="number">16</span>);      <span class="comment">// 返回 15 (16 进制的 F 为十进制的 15)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">8</span>);        <span class="comment">// 返回 8 (8 进制的 10 为十进制的 8)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">10</span>);       <span class="comment">// 返回 10 (十进制的 10 为十进制的 10)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;abc123&quot;</span>);       <span class="comment">// 返回 NaN (因为 &quot;abc&quot; 不是数字)</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>注意事项</strong></p>
<ul>
<li>如果 <code>string</code> 的第一个字符无法转换为数字，那么 <code>parseInt</code> 将返回 <code>NaN</code>。</li>
<li><code>NaN</code> (Not a Number) 是 JavaScript 中表示一个非数字的特殊值。</li>
<li>你可以使用 <code>isNaN()</code> 函数来检查 <code>parseInt</code> 的返回值是否是 <code>NaN</code>。</li>
</ul>
</blockquote>
<p><strong>6.流程控制语句</strong>：</p>
<ul>
<li><strong>if…else</strong>：用于条件判断。</li>
<li><strong>switch</strong>：用于多分支判断。</li>
<li><strong>for</strong>：用于循环。</li>
<li><strong>while</strong>：用于循环。</li>
<li><strong>do…while</strong>：用于循环。</li>
</ul>
<p><a class="link"   href="https://www.w3school.com.cn/jsref/jsref_statements.asp" >参考官方文档<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h4 id="1-3-3-JS函数"><a href="#1-3-3-JS函数" class="headerlink" title="1.3.3 JS函数"></a>1.3.3 JS函数</h4><ul>
<li><strong>介绍</strong>：函数（方法）是被设计为执行特定任务的代码块。</li>
<li><strong>定义</strong>：JavaScript 函数通过 <code>function</code> 关键字来定义。语法为：<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">parameter1, parameter2, ...</span>) &#123;</span><br><span class="line">  <span class="comment">// 要执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式二：</span></span><br><span class="line"><span class="keyword">var</span> functionName = <span class="keyword">function</span>(<span class="params">parameter1, parameter2, ...</span>) &#123;</span><br><span class="line">  <span class="comment">// 要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>注意</strong>：<ul>
<li>形式参数不需要类型。因为JavaScript 是弱类型语言，参数类型由调用者决定。</li>
<li>函数可以返回值。如果函数没有返回值 或者 return 后没有跟随任何值，则返回 <code>undefined</code>。</li>
<li>返回值也不需要定义类型，可以在函数内部直接使用return返回值即可</li>
</ul>
</li>
<li><strong>调用</strong>：函数名称（实际参数列表）</li>
</ul>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>注意事项</strong>：<br>JS中，函数调用可以传递任意个数的参数。<font color="red">但只会截取需要的前几个</font></p>
</blockquote>
<h4 id="1-3-4-JS对象"><a href="#1-3-4-JS对象" class="headerlink" title="1.3.4 JS对象"></a>1.3.4 JS对象</h4><p><strong>1.Array</strong></p>
<ul>
<li><strong>介绍</strong>：JavaScript 数组是一种特殊的对象，用于存储多个值。</li>
<li><strong>定义</strong>：<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：</span></span><br><span class="line"><span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="title class_">Array</span>(元素列表);</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 方式二：</span></span><br><span class="line"><span class="keyword">var</span> 变量名 = [元素列表];</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></div></li>
<li><strong>赋值&#x2F;访问</strong>：<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">arr[索引] = 值;</span><br><span class="line">arr[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="title function_">alter</span>(arr[<span class="number">10</span>]);<span class="comment">// 警告框输出hello</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<blockquote>
<p><strong>注意事项</strong>：<br>JavaScript 中的数组相当于 Java 中的集合，数组的长度是可变的，而JavaScript是弱类型，所以可以存储任意的类型的数据。</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">9</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">10</span>]); <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">9</span>] = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">arr[<span class="number">8</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); </span><br></pre></td></tr></table></figure></div>
</blockquote>
<ul>
<li><strong>属性</strong>：<ul>
<li><strong><code>length</code></strong>：表示数组中元素的数量。你可以读取这个属性来获取数组的长度，也可以设置它来改变数组的长度。<ul>
<li><strong>设置 <code>length</code></strong>：如果设置 <code>length</code> 为比当前长度小的值，数组将被截断。如果设置为更大的值，数组会用 <code>undefined</code> 填充新的位置。</li>
</ul>
</li>
</ul>
</li>
<li><strong>方法</strong>：<ul>
<li><strong><code>toString()</code></strong>：将数组转换为字符串，元素之间用逗号分隔。</li>
<li><strong><code>join(separator)</code></strong>：将数组转换为字符串，元素之间用指定的 <code>separator</code> 分隔。如果不提供 <code>separator</code>，则使用逗号作为默认分隔符。</li>
<li><strong><code>forEach(callback)</code></strong>：对数组中的每个元素执行一次提供的函数 <code>callback</code>。<code>callback</code> 接受三个参数：当前元素值、当前元素的索引、整个数组。<code>forEach</code> 不会改变原数组。</li>
<li><strong><code>push(element1, ..., elementN)</code></strong>：将一个或多个新元素添加到数组的末尾，并返回数组的新长度。</li>
<li><strong><code>splice(start, deleteCount, item1, ..., itemN)</code></strong>：用于在数组中添加或删除元素。<code>start</code> 是开始位置的索引，<code>deleteCount</code> 指定要删除的元素数量，<code>item1, ..., itemN</code> 是要添加的新元素。这个方法会直接修改原数组，并返回被删除的元素。</li>
</ul>
</li>
</ul>
<p><strong>代码示例：</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// length 属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">length</span>);  <span class="comment">// 输出: 3</span></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">5</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);  <span class="comment">// 输出: [1, 2, 3, undefined, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// toString() 方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">toString</span>());  <span class="comment">// 输出: &quot;1,2,3,,&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// join() 方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>));  <span class="comment">// 输出: &quot;1-2-3--&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach() 方法</span></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Index <span class="subst">$&#123;index&#125;</span>: <span class="subst">$&#123;element&#125;</span>`</span>); <span class="comment">// 或者 console.log(&quot;Index &quot; + index + &quot;: &quot; + element);</span></span><br><span class="line">  <span class="comment">// $&#123;&#125; 是模板字符串（template literals）中的一种语法，用于在字符串中插入变量或表达式的值。模板字符串使用反引号（`）括起来，并允许在字符串中嵌入表达式。</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// Index 0: 1</span></span><br><span class="line"><span class="comment">// Index 1: 2</span></span><br><span class="line"><span class="comment">// Index 2: 3</span></span><br><span class="line"><span class="comment">// Index 3: undefined</span></span><br><span class="line"><span class="comment">// Index 4: undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// push() 方法</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">6</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);  <span class="comment">// 输出: [1, 2, 3, undefined, undefined, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// splice() 方法</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);  <span class="comment">// 输出: [1, 2, &quot;a&quot;, &quot;b&quot;, undefined, 6]</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>箭头函数(ES6)：是用来简化函数定义语法的，具体形式为：(……) &#x3D;&gt; {…}，如果需要给箭头函数起名字：var func &#x3D; (……) &#x3D;&gt; {…}</p>
</blockquote>
<p><strong>2.String</strong></p>
<ul>
<li><p><strong>介绍</strong>：JavaScript 字符串是一种特殊类型的对象，用于存储和操作文本。</p>
</li>
<li><p><strong>定义</strong>：</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：</span></span><br><span class="line"><span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;……&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line"><span class="comment">// 方式二：</span></span><br><span class="line"><span class="keyword">var</span> 变量名 = <span class="string">&quot;……&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>属性</strong>：</p>
<ul>
<li><strong><code>length</code></strong>：返回字符串的长度，表示字符串中字符的个数。</li>
</ul>
</li>
<li><p><strong>方法</strong>：</p>
<ul>
<li><strong><code>charAt(index)</code></strong>：返回指定位置的字符。<code>index</code> 从 0 开始计算。</li>
<li><strong><code>indexOf(substring)</code></strong>：返回子字符串在字符串中第一次出现的位置，如果没有找到，则返回 <code>-1</code>。</li>
<li><strong><code>trim()</code></strong>：去除字符串两边的空格（包括换行符和制表符）。</li>
<li><strong><code>substring(startIndex, endIndex)</code></strong>：提取字符串中从 <code>startIndex</code> 到 <code>endIndex</code> 之间的字符，<code>endIndex</code> 处的字符不包括在内。【包左不包右】</li>
</ul>
</li>
</ul>
<p><strong>代码示例：</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// length 属性</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">length</span>);  <span class="comment">// 输出: 13</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// charAt() 方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">7</span>));  <span class="comment">// 输出: &quot;w&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// indexOf() 方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;world&quot;</span>));  <span class="comment">// 输出: 7</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;foo&quot;</span>));    <span class="comment">// 输出: -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// trim() 方法</span></span><br><span class="line"><span class="keyword">let</span> strWithSpaces = <span class="string">&quot;   Hello, world!   &quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strWithSpaces.<span class="title function_">trim</span>());  <span class="comment">// 输出: &quot;Hello, world!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// substring() 方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">5</span>));  <span class="comment">// 输出: &quot;Hello&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substring</span>(<span class="number">7</span>, <span class="number">12</span>)); <span class="comment">// 输出: &quot;world&quot;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>3.自定义对象</strong></p>
<ul>
<li><strong>介绍</strong>：JavaScript 中的对象是一种复杂的数据类型，可以包含多个属性和方法。</li>
<li><strong>定义</strong>：<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* var 对象名 = &#123;</span></span><br><span class="line"><span class="comment">    属性名1: 值1,</span></span><br><span class="line"><span class="comment">    属性名2: 值2,</span></span><br><span class="line"><span class="comment">    属性名3: 值3,</span></span><br><span class="line"><span class="comment">    函数名称：function(参数列表) &#123;&#125; ,可以省略&quot;：function&quot;</span></span><br><span class="line"><span class="comment">&#125;; */</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;Male&quot;</span>,</span><br><span class="line">  <span class="attr">eat</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;             <span class="title function_">eat</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Eating...&quot;</span>);   ==      <span class="title function_">alert</span>(<span class="string">&quot;Eating...&quot;</span>);</span><br><span class="line">  &#125;                             &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>调用</strong>：<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对象名.属性名;</span></span><br><span class="line"><span class="comment">对象名.方法名(); */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);</span><br><span class="line">person.<span class="title function_">eat</span>();</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>4.JSON</strong></p>
<ul>
<li><strong>介绍</strong>：<ul>
<li>JSON是通过JavaScript对象标记法书写的文本。</li>
<li>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，主要用于在网络传输数据。</li>
</ul>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&quot;Male&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810004428.png"
                     
                ></p>
</li>
<li><strong>定义</strong>：<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="string">&#x27;&#123;&quot;属性名1&quot;:&quot;值1&quot;,&quot;属性名2&quot;:&quot;值2&quot;,&quot;属性名3&quot;:&quot;值3&quot;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> person = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:30,&quot;gender&quot;:&quot;Male&quot;,&quot;addr&quot;:[&quot;北京&quot;,&quot;上海&quot;,&quot;广州&quot;]&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure></div>
值的数据类型为：<ul>
<li>数字（整数或浮点数）</li>
<li>字符串（在双引号中）</li>
<li>逻辑值（true 或 false）</li>
<li>数组（在方括号中）</li>
<li>对象（在花括号中）</li>
<li>null</li>
</ul>
</li>
<li><strong>方法</strong>：<ul>
<li><strong><code>JSON.parse(json)</code></strong>：将 JSON 字符串转换为 JavaScript 对象。</li>
<li><strong><code>JSON.stringify(obj)</code></strong>：将 JavaScript 对象转换为 JSON 字符串。</li>
</ul>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsObject = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(person);</span><br><span class="line"><span class="keyword">var</span> jsonStr = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(jsObject);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>5.BOM</strong></p>
<ul>
<li><strong>介绍</strong>：BOM（Browser Object Model）是浏览器对象模型的缩写，它提供了与浏览器窗口交互的接口。JavaScript 将浏览器的各个组成部分封装为对象。</li>
<li><strong>组成</strong>：<ul>
<li><strong><code>Window</code></strong>：浏览器窗口对象</li>
<li><strong><code>Navigator</code></strong>：浏览器信息对象</li>
<li><strong><code>Screen</code></strong>：屏幕信息对象</li>
<li><strong><code>History</code></strong>：历史记录对象</li>
<li><strong><code>Location</code></strong>：地址栏对象</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810005713.png"
                     
                ></p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot;Hello BOM&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;Hello BOM Window&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="comment">// confirm - 对话框 -- 确认: true，取消: false</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="title function_">confirm</span>(<span class="string">&quot;您确认删除该记录吗？&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(flag);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器 - setInterval -- 周期性地执行某个函数</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;定时器执行了&quot;</span> + i + <span class="string">&quot;次&quot;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器 - setTimeout -- 延迟指定时间执行一次</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;JS&quot;</span>);</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810005918.png"
                     
                ></p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// location</span></span><br><span class="line"><span class="title function_">alter</span>(location.<span class="property">href</span>);</span><br><span class="line">location.<span class="property">href</span> = <span class="string">&quot;https://www.baidu.com&quot;</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>6.DOM</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810010120.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810010134.png"
                     
                ></p>
<ul>
<li>HTML中的Element对象可以通过<code>Document</code>对象获取，而<code>Document</code>对象可以通过<code>window</code>对象获取。</li>
<li><code>Document</code>对象中提供了以下获取Element元素对象的函数：<ul>
<li><strong><code>getElementById(id)</code></strong>：根据元素的id属性值获取元素对象，返回单个Element对象。</li>
<li><strong><code>getElementsByTagName(tagName)</code></strong>：根据元素的标签名获取元素对象，返回一个Element对象的<font color="red">数组</font>。</li>
<li><strong><code>getElementsByName(name)</code></strong>：根据元素的name属性值获取元素对象，返回一个Element对象的<font color="red">数组</font>。</li>
<li><strong><code>getElementsByClassName(className)</code></strong>：根据元素的class属性值获取元素对象，返回一个Element对象的<font color="red">数组</font>。</li>
</ul>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据元素的id属性值</span></span><br><span class="line"><span class="keyword">var</span> h1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;h1&#x27;</span>);</span><br><span class="line"><span class="comment">// 根据元素的标签名</span></span><br><span class="line"><span class="keyword">var</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="comment">// 根据元素的name属性值</span></span><br><span class="line"><span class="keyword">var</span> hobbys = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&#x27;hobby&#x27;</span>);</span><br><span class="line"><span class="comment">// 根据元素的class属性值</span></span><br><span class="line"><span class="keyword">var</span> clss = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;cls&#x27;</span>);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>7.事件监听</strong></p>
<ul>
<li><strong>介绍</strong>：JavaScript 事件是发生在 HTML 元素上的交互行为，如鼠标点击、键盘按键等。</li>
<li><strong>事件监听</strong>：JavaScript可以在事件被侦测到时<strong>执行代码</strong>。</li>
<li><strong>事件绑定</strong>：<ul>
<li>方式一：通过HTML标签中的事件属性进行绑定</li>
</ul>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;on()&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">on</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;按钮被点击了&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>方式二：通过DOM元素属性绑定</li>
</ul>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;按钮被点击了&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810011318.png"
                     
                ></p>
<h3 id="1-4-Vue"><a href="#1-4-Vue" class="headerlink" title="1.4 Vue"></a>1.4 Vue</h3><ul>
<li>Vue是一套<strong>前端框架</strong>，，免除原生JavaScript中的DOM操作，简化书写。</li>
<li>基于<strong>MVVM</strong>（Model-View-ViewModel）思想，实现数据的<strong>双向绑定</strong>，将编程的关注点放在数据上。</li>
<li>官网：<a class="link"   href="https://cn.vuejs.org/" >https://cn.vuejs.org/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810121232.png"
                     
                ><blockquote>
<p>框架：是一个半成品软件，是一套可重用的、通用的、软件基础代码模型。基于框架进行开发，更加快捷，高效。</p>
</blockquote>
</li>
</ul>
<h4 id="1-4-1-快速入门"><a href="#1-4-1-快速入门" class="headerlink" title="1.4.1 快速入门"></a>1.4.1 快速入门</h4><ul>
<li>新建HTML文件，引入Vue.js文件：<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
<li>在JS代码区域，创建Vue核心对象，定义数据类型<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
<li>编写视图<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<blockquote>
<p><strong>插值表达式：</strong></p>
<ul>
<li><strong>形式</strong>：<code>&#123;&#123; 表达式 &#125;&#125;</code></li>
<li><strong>作用</strong>：将数据绑定到视图中</li>
<li><strong>内容</strong>：变量、三元运算符、函数调用 或 算术运算</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="1-4-2-常用指令"><a href="#1-4-2-常用指令" class="headerlink" title="1.4.2 常用指令"></a>1.4.2 常用指令</h4><ul>
<li><strong>指令</strong>：HTML标签上带有<code>v-</code>前缀的特殊属性，不同指令具有不同含义。</li>
<li><strong>常用指令</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>用途</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td><code>v-bind</code></td>
<td>动态地绑定一个或多个特性（attributes）到一个元素上，如设置href、css样式等</td>
<td><code>v-bind:attribute=&quot;expression&quot;</code> （简写：<code>:</code>）</td>
</tr>
<tr>
<td><code>v-model</code></td>
<td>创建一个双向数据绑定，通常用于表单元素</td>
<td><code>v-model=&quot;dataProperty&quot;</code></td>
</tr>
<tr>
<td><code>v-if</code></td>
<td>条件渲染，根据表达式的真假条件<code>有选择地渲染元素</code></td>
<td><code>v-if=&quot;condition&quot;</code></td>
</tr>
<tr>
<td><code>v-else-if</code></td>
<td>条件渲染，用于在 <code>v-if</code> 之外添加条件</td>
<td><code>v-else-if=&quot;condition&quot;</code></td>
</tr>
<tr>
<td><code>v-else</code></td>
<td>条件渲染，当所有 <code>v-if</code> 和 <code>v-else-if</code> 的条件都不满足时渲染元素</td>
<td><code>v-else</code></td>
</tr>
<tr>
<td><code>v-show</code></td>
<td>基于条件展示元素，<code>元素总是被渲染</code>，只是简单地控制元素的显示和隐藏（<code>display: none</code>）</td>
<td><code>v-show=&quot;condition&quot;</code></td>
</tr>
<tr>
<td><code>v-for</code></td>
<td>基于一个数组或对象的迭代渲染一个列表。对于数组，可以获取每个元素的值和下标；对于对象，可以获取每个键值对的键和值。</td>
<td><code>v-for=&quot;item in items&quot;</code></td>
</tr>
<tr>
<td><code>v-on</code></td>
<td>监听DOM事件，并在事件发生时执行指定的JavaScript表达式或方法</td>
<td><code>v-on:event=&quot;handler&quot;</code>（简写：<code>@</code>）</td>
</tr>
<tr>
<td><code>v-cloak</code></td>
<td>避免Vue实例接管模板前闪烁的内容（通常配合CSS使用）</td>
<td>无表达式</td>
</tr>
<tr>
<td><code>v-pre</code></td>
<td>跳过这个元素和它的所有子元素的编译过程，以加快初次渲染速度</td>
<td>无表达式</td>
</tr>
<tr>
<td><code>v-once</code></td>
<td>只渲染元素和组件一次，之后就不会再更新</td>
<td>无表达式</td>
</tr>
<tr>
<td><code>v-html</code></td>
<td>输出原始的HTML，不进行HTML转义（小心XSS攻击）</td>
<td><code>v-html=&quot;htmlContent&quot;</code></td>
</tr>
</tbody></table>
<p><strong>代码示例</strong></p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-bind 示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 简写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- v-model 示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter something&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- v-if / v-else-if / v-else 示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;age &lt;= 35&quot;</span>&gt;</span>年轻人<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else-if</span>=<span class="string">&quot;age &gt; 35 &amp;&amp; age &lt;= 60&quot;</span>&gt;</span>中年人<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>老年人<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- v-show 示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">&quot;age &lt;= 35&quot;</span>&gt;</span>年轻人<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- v-for 示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.text &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in items&quot;</span> &gt;</span>&#123;&#123; index+1 &#125;&#125; : &#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- v-on 示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 简写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;Button clicked!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- v-cloak 示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-attr">[v-cloak]</span> &#123; <span class="attribute">display</span>: none; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- v-pre 示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123; raw &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- v-once 示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- v-html 示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>注意事项</strong>：</p>
<ul>
<li>通过<code>v-bind</code>或者<code>v-model</code>绑定的变量，必须在数据模型中声明</li>
</ul>
</blockquote>
<h4 id="1-4-3-生命周期"><a href="#1-4-3-生命周期" class="headerlink" title="1.4.3 生命周期"></a>1.4.3 生命周期</h4><ul>
<li><strong>生命周期</strong>：指一个对象从创建到销毁的整个过程。</li>
<li><strong>八个阶段</strong>：每触发一个生命周期事件，会自动执行一个生命周期方法(钩子)。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810134011.png"
                     
                ></li>
<li><strong>mounted</strong>：挂载完成，Vue初始化成功，HTML页面渲染成功。（发送请求到服务端，加载数据）<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810133326.png"
                     
                ></li>
</ul>
<h3 id="1-5-Ajax"><a href="#1-5-Ajax" class="headerlink" title="1.5 Ajax"></a>1.5 Ajax</h3><ul>
<li><p><strong>概念</strong>：<code>Ajax</code> 是 <code>Asynchronous JavaScript and XML</code> 的缩写，表示异步的 JavaScript 和 XML。它是一种用于在不重新加载整个网页的情况下，进行数据交换并更新网页部分内容的技术。Ajax 通常利用 <code>XMLHttpRequest</code> 对象来发送和接收数据，但它并不仅限于 XML，现代应用中也常用 JSON 格式进行数据交换。</p>
</li>
<li><p><strong>作用</strong>：</p>
<ul>
<li><strong>数据交换</strong>：通过 Ajax 可以与服务器进行数据交互，发送请求并接收响应数据，而不需要刷新整个页面。</li>
<li><strong>异步交互</strong>：Ajax 允许网页在后台与服务器进行数据交换，从而在不刷新整个页面的情况下动态更新页面的部分内容。常见的应用场景包括：搜索联想、表单验证（如用户名是否可用）、自动加载更多内容等。</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810153628.png"
                     
                ></p>
<blockquote>
<p><strong>进一步说明</strong></p>
<ul>
<li>虽然 <code>Ajax</code> 中的 <code>XML</code> 表示可使用 XML 进行数据交换，但现代开发中更多使用 JSON 作为数据交换格式，因为 JSON 更轻量且更易于 JavaScript 解析。</li>
<li>Ajax 的核心是 <code>XMLHttpRequest</code> 对象，但在现代开发中，<code>fetch</code> API 也经常用来实现类似的异步数据交互功能。</li>
</ul>
</blockquote>
<ul>
<li><p><strong>异步VS同步</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810153824.png"
                     
                ></p>
</li>
<li><p><strong>Ajax请求流程</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810153934.png"
                     
                ></p>
</li>
<li><p><strong>XMLHttpRequest对象属性</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810154050.png"
                     
                ></p>
</li>
</ul>
<h3 id="1-6-Axios"><a href="#1-6-Axios" class="headerlink" title="1.6 Axios"></a>1.6 Axios</h3><ul>
<li><p><strong>概念</strong>：Axios对原生的Ajax进行了封装，简化书写，快速开发。</p>
</li>
<li><p><strong>官网</strong>：<a class="link"   href="https://www.axios-http.cn/" >https://www.axios-http.cn/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</li>
<li><p><strong>请求方式别名</strong>：</p>
<ul>
<li><code>axios.get(url [,config])</code></li>
<li><code>axios.delete(url [,config])</code></li>
<li><code>axios.post(url [,data[,config]])</code></li>
<li><code>axios.put(url [,data[,config]])</code></li>
</ul>
</li>
<li><p><strong>入门示例</strong>：</p>
<ul>
<li><strong>1.引入Axios的js文件</strong></li>
</ul>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>2.使用Axios发送请求，并获取响应结果</strong></li>
</ul>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">axios.get(&quot;https://api.example.com/data&quot;).then((result) =&gt; &#123;</span><br><span class="line">  console.log(result.data);</span><br><span class="line">&#125;)// 处理响应结果</span><br><span class="line"></span><br><span class="line">axios.post(&quot;https://api.example.com/data&quot;,&quot;id=1&quot;).then((result) =&gt; &#123;</span><br><span class="line">  console.log(result.data);</span><br><span class="line">&#125;)// 处理响应结果     </span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="1-7-Vue项目"><a href="#1-7-Vue项目" class="headerlink" title="1.7 Vue项目"></a>1.7 Vue项目</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810155548.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810155629.png"
                     
                ></p>
<h3 id="1-8-Element组件"><a href="#1-8-Element组件" class="headerlink" title="1.8 Element组件"></a>1.8 Element组件</h3><ul>
<li><strong>概念</strong>：是饿了么团队开发的，一套为开发者、设计师和产品经理准备的基于Vue2.0的桌面端组件库。</li>
<li><strong>组件</strong>：组成网页的部件，例如 超链接、按钮、图片、表格、表单、分页条等。</li>
<li><strong>官网</strong>：<a class="link"   href="https://element.eleme.cn/" >https://element.eleme.cn/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<p><strong>快速入门</strong>：</p>
<ul>
<li>安装ElementUI组件库（在当前工程的目录下），在命令行执行指令：<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install element-ui@<span class="number">2</span>.<span class="number">15</span>.<span class="number">6</span> </span><br></pre></td></tr></table></figure></div></li>
<li>引入ElementUI组件库<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">// main.js文件中引入</span><br><span class="line">import ElementUI from &#x27;element-ui&#x27;;</span><br><span class="line">import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;</span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI);</span><br></pre></td></tr></table></figure></div></li>
<li>访问官网，复制组件代码并调整。</li>
</ul>
<h2 id="2-Maven"><a href="#2-Maven" class="headerlink" title="2.Maven"></a>2.Maven</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><ul>
<li><strong>概念</strong>：Apache Maven 是一个项目管理和构建工具，用于管理项目的构建、报告和文档。它基于项目对象模型（POM）的概念，通过一小段描述信息来管理项目的构建。</li>
<li><strong>作用</strong>：<ul>
<li>方便的依赖管理</li>
<li>统一的项目结构</li>
<li>标准的项目构建流程</li>
</ul>
</li>
<li><strong>官网</strong>：<a class="link"   href="https://maven.apache.org/" >https://maven.apache.org/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810204935.png"
                     
                ></p>
<h3 id="2-2-Maven坐标"><a href="#2-2-Maven坐标" class="headerlink" title="2.2 Maven坐标"></a>2.2 Maven坐标</h3><ul>
<li><strong>概念</strong>：<ul>
<li>Maven中的坐标是<font color="red">资源的唯一标识，通过该坐标可以唯一定位资源位置</font>。</li>
<li>使用坐标来定义项目或者引入项目中需要的依赖。</li>
</ul>
</li>
<li><strong>主要组成</strong>：<ul>
<li><strong><code>groupId</code></strong>：定义当前Maven项目隶属组织名称（通常是域名反写，例如：ink.lusy）</li>
<li><strong><code>artifactId</code></strong>：定义当前Maven项目名称（通常是模块名，例如：order-service、goods-service）</li>
<li><strong><code>version</code></strong>：定义当前Maven项目版本号（例如：1.0.0）</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ink.lusy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project01<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-依赖配置"><a href="#2-3-依赖配置" class="headerlink" title="2.3 依赖配置"></a>2.3 依赖配置</h3><ul>
<li><strong>依赖</strong>：指当前项目运行所需要的jar包，一个项目中可以引入多个依赖。</li>
<li><strong>配置</strong>：<ul>
<li>在pom.xml文件中编写<code>&lt;dependencies&gt;</code>标签</li>
<li>在<code>&lt;dependencies&gt;</code>标签中使用<code>&lt;dependency&gt;</code>引入坐标</li>
<li>定义坐标的<code>groupId</code>、<code>artifactId</code>、<code>version</code></li>
<li>点击刷新按钮，引入最新加入的坐标<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810210505.png"
                     
                ></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意事项</strong>：</p>
<ul>
<li>如果引入的依赖，在本地仓库不存在，将会连接远程仓库&#x2F;中央仓库，然后下载依赖。</li>
<li>如果不知道依赖的坐标信息，可以到<a class="link"   href="https://mvnrepository.com/" >https://mvnrepository.com/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>中搜索。</li>
</ul>
</blockquote>
<h3 id="2-4-依赖传递"><a href="#2-4-依赖传递" class="headerlink" title="2.4 依赖传递"></a>2.4 依赖传递</h3><ul>
<li><strong>依赖具有传递性</strong><ul>
<li><strong>直接依赖</strong>：在当前项目中通过依赖配置建立的依赖关系</li>
<li><strong>间接依赖</strong>：被依赖的资源如果依赖其它资源，当前项目间接依赖了被依赖的资源<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810211620.png"
                     
                ></li>
</ul>
</li>
<li><strong>依赖冲突</strong>：当依赖传递时，如果存在多个依赖，且依赖的版本号不同，则存在依赖冲突。<br>当直接引用或者间接引用出现了相同的jar包! 这时呢，一个项目就会出现相同的重复jar包，这就算作冲突！依赖冲突避免出现重复依赖，并且终止依赖传递！<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240819174427.png"
                     
                ><br>maven自动解决依赖冲突问题能力，会按照自己的原则，进行重复依赖选择。同时也提供了手动解决的冲突的方式，不过不推荐！<br><strong>解决依赖冲突（如何选择重复依赖）方式：</strong><ul>
<li>短路优先原则（第一原则）<br>  A—&gt;B—&gt;C—&gt;D—&gt;E—&gt;X(version 0.0.1)<br>  A—&gt;F—&gt;X(version 0.0.2)<br>  则A依赖于X(version 0.0.2)。</li>
<li>依赖路径长度相同情况下，则“先声明优先”（第二原则）<br>  A—&gt;E—&gt;X(version 0.0.1)<br>  A—&gt;F—&gt;X(version 0.0.2)<br>  在&lt;depencies&gt;\……</depencies>中，先声明的，路径相同，会优先选择！</li>
</ul>
</li>
</ul>
<p><strong>小测试</strong>：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line">前提：</span><br><span class="line">   A 1.1 -&gt; B 1.1 -&gt; C 1.1 </span><br><span class="line">   F 2.2 -&gt; B 2.2 </span><br><span class="line">   </span><br><span class="line">pom声明：</span><br><span class="line">   F 2.2</span><br><span class="line">   A 1.1 </span><br><span class="line">   B 2.2 </span><br><span class="line">   C不会被引入</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>排除依赖</strong>：当依赖传递时，如果存在依赖冲突，可以通过<code>&lt;exclusions&gt;</code>标签，排除依赖。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810211807.png"
                     
                ></li>
<li><strong>依赖范围</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810211843.png"
                     
                ></li>
</ul>
<h3 id="2-5-生命周期"><a href="#2-5-生命周期" class="headerlink" title="2.5 生命周期"></a>2.5 生命周期</h3><p>Maven的生命周期就是为了对所有的maven项目构建过程进行抽象和统一。<br>Maven中有3套<font color="red">相互独立</font>的生命周期：</p>
<ul>
<li><strong>clean</strong>：清理项目</li>
<li><strong>default</strong>：核心工作，包含编译、测试、打包、部署等操作</li>
<li><strong>site</strong>：生成报告、发布站点等。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810212415.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810212739.png"
                     
                ><br><strong>执行指定生命周期的两种方式</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240810212837.png"
                     
                ></li>
</ul>
<h3 id="2-6-项目结构"><a href="#2-6-项目结构" class="headerlink" title="2.6 项目结构"></a>2.6 项目结构</h3><p>Maven 是一个强大的构建工具，它提供一种标准化的项目结构，可以帮助开发者更容易地管理项目的依赖、构建、测试和发布等任务。以下是 Maven Web 程序的文件结构及每个文件的作用：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line">|-- pom.xml                               # Maven 项目管理文件 </span><br><span class="line">|-- src</span><br><span class="line">    |-- main                              # 项目主要代码</span><br><span class="line">    |   |-- java                          # Java 源代码目录</span><br><span class="line">    |   |   `-- com/example/myapp         # 开发者代码主目录</span><br><span class="line">    |   |       |-- controller            # 存放 Controller 层代码的目录</span><br><span class="line">    |   |       |-- service               # 存放 Service 层代码的目录</span><br><span class="line">    |   |       |-- dao                   # 存放 DAO 层代码的目录</span><br><span class="line">    |   |       `-- model                 # 存放数据模型的目录</span><br><span class="line">    |   |-- resources                     # 资源目录，存放配置文件、静态资源等</span><br><span class="line">    |   |   |-- log4j.properties          # 日志配置文件</span><br><span class="line">    |   |   |-- spring-mybatis.xml        # Spring Mybatis 配置文件</span><br><span class="line">    |   |   `-- static                    # 存放静态资源的目录</span><br><span class="line">    |   |       |-- css                   # 存放 CSS 文件的目录</span><br><span class="line">    |   |       |-- js                    # 存放 JavaScript 文件的目录</span><br><span class="line">    |   |       `-- images                # 存放图片资源的目录</span><br><span class="line">    |   `-- webapp                        # 存放 WEB 相关配置和资源</span><br><span class="line">    |       |-- WEB-INF                   # 存放 WEB 应用配置文件</span><br><span class="line">    |       |   |-- web.xml               # Web 应用的部署描述文件</span><br><span class="line">    |       |   `-- classes               # 存放编译后的 class 文件</span><br><span class="line">    |       `-- index.html                # Web 应用入口页面</span><br><span class="line">    `-- test                              # 项目测试代码</span><br><span class="line">        |-- java                          # 单元测试目录</span><br><span class="line">        `-- resources                     # 测试资源目录</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>pom.xml</strong>：Maven 项目管理文件，用于描述项目的依赖和构建配置等信息。</li>
<li><strong>src&#x2F;main&#x2F;java</strong>：存放项目的 Java 源代码。</li>
<li><strong>src&#x2F;main&#x2F;resources</strong>：存放项目的资源文件，如配置文件、静态资源等。</li>
<li><strong>src&#x2F;main&#x2F;webapp&#x2F;WEB-INF</strong>：存放 Web 应用的配置文件。</li>
<li><strong>src&#x2F;main&#x2F;webapp&#x2F;index.html</strong>：Web 应用的入口页面。</li>
<li><strong>src&#x2F;test&#x2F;java</strong>：存放项目的测试代码。</li>
<li><strong>src&#x2F;test&#x2F;resources</strong>：存放测试相关的资源文件，如测试配置文件等。</li>
</ul>
<h2 id="3-HTTP"><a href="#3-HTTP" class="headerlink" title="3.HTTP"></a>3.HTTP</h2><h3 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h3><p>HTTP（Hypertext Transfer Protocol，超文本传输协议）是一种用于传输超文本信息的协议。规定了浏览器和服务器之间数据传输的规则。</p>
<h3 id="3-2特点"><a href="#3-2特点" class="headerlink" title="3.2特点"></a>3.2特点</h3><ul>
<li><strong>基于TCP协议</strong>：面向连接，安全。</li>
<li><strong>基于请求-响应模型</strong>：一次请求对应一次响应。</li>
<li><strong>无状态</strong>：对于事务处理没有记忆能力。每次请求-响应都独立的，没有保存信息。<ul>
<li>缺点：多次请求间不能共享数据。</li>
<li>优点：速度快</li>
</ul>
</li>
</ul>
<h3 id="3-2-请求数据格式"><a href="#3-2-请求数据格式" class="headerlink" title="3.2 请求数据格式"></a>3.2 请求数据格式</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811142141.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811142211.png"
                     
                ></p>
<h3 id="3-3响应数据格式"><a href="#3-3响应数据格式" class="headerlink" title="3.3响应数据格式"></a>3.3响应数据格式</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811142427.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811142452.png"
                     
                ></p>
<p><strong>常见的响应状态码</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>英文描述</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>客户端请求成功。即<strong>处理成功</strong>，这是我们最想看到的状态码</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>指示所请求的资源已移动到由<code>Location</code>响应头给定的 URL，浏览器会自动重新访问到这个页面</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>告诉客户端，你请求的资源至上次取得后，服务器并未改。你直接用你本地缓存吧。隐式重定向</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>客户端请求有<strong>语法错误</strong>，不能被服务器所理解</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器收到请求，但是<strong>拒绝提供服务</strong>，比如：没有权限访问相关资源</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td><strong>请求资源不存在</strong>。一般是URL输入有误，或者网站资源被删除了</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>请求方法有误，比如本应用GET请求方式的资源，用了POST</td>
</tr>
<tr>
<td>428</td>
<td>Precondition Required</td>
<td><strong>服务器要求有条件的请求</strong>，告诉客户端需要访问该资源，必须携带特定的请求头</td>
</tr>
<tr>
<td>429</td>
<td>Too Many Requests</td>
<td>用户在给定时间内发送了<strong>太多请求</strong>（“限速”），配合<code>Retry-After</code>（多长时间后可以请求）响应头一起使用</td>
</tr>
<tr>
<td>431</td>
<td>Request Header Fields Too Large</td>
<td><strong>请求头太大</strong>。服务器不愿意处理请求，因为它的头字段太大。请求可以在减少请求头域的大小后重新提交。</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td><strong>服务器发生不可预期的错误</strong>。服务器出异常了，赶紧看日志去吧</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td><strong>服务器尚未准备好处理请求</strong>。服务器刚启动，还未初始化好</td>
</tr>
</tbody></table>
<h3 id="3-4-接收请求头数据"><a href="#3-4-接收请求头数据" class="headerlink" title="3.4 接收请求头数据"></a>3.4 接收请求头数据</h3><p>可以使用<b><code>@RequestHeader</code></b>注解将请求标头绑定到控制器中的方法参数。</p>
<p>请考虑以下带有标头的请求：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Host                    localhost:<span class="number">8080</span></span><br><span class="line">Accept                  text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span></span><br><span class="line">Accept-Language         fr,en-gb;q=<span class="number">0.7</span>,en;q=<span class="number">0.3</span></span><br><span class="line">Accept-Encoding         gzip,deflate</span><br><span class="line">Accept-Charset          ISO-<span class="number">8859</span>-<span class="number">1</span>,utf-<span class="number">8</span>;q=<span class="number">0.7</span>,*;q=<span class="number">0.7</span></span><br><span class="line">Keep-Alive              <span class="number">300</span></span><br></pre></td></tr></table></figure></div>

<p>下面的示例获取 <code>Accept-Encoding</code> 和 <code>Keep-Alive</code> 标头的值：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(</span></span><br><span class="line"><span class="params">  // encoding: gzip,deflate</span></span><br><span class="line"><span class="params">  // keepAlive: <span class="number">300</span></span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String encoding, </span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(&quot;Keep-Alive&quot;)</span> <span class="type">long</span> keepAlive)</span> &#123; </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="4-Tomcat"><a href="#4-Tomcat" class="headerlink" title="4.Tomcat"></a>4.Tomcat</h2><h3 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h3><ul>
<li>Tomcat是Apache软件基金会一个核心项目，是一个开源免费的轻量级Web服务器，支持Servlet&#x2F;JSP和少量JavaEE规范。</li>
<li>Tomcat也称为Web容器、Servlet容器。Servlet程序需要tomcat才能运行。</li>
<li><a class="link"   href="https://tomcat.apache.org/" >https://tomcat.apache.org/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<blockquote>
<p>JavaEE：Java企业级应用环境,指Java企业级开发的技术规范总和。包含13项技术规范：JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、JavaMail、JAF</p>
</blockquote>
<h3 id="4-2-基本使用"><a href="#4-2-基本使用" class="headerlink" title="4.2 基本使用"></a>4.2 基本使用</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811144025.png"
                     
                ></p>
<ul>
<li>配置Tomcat端口号 (conf&#x2F;server.xml)</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=<span class="string">&quot;8080&quot;</span> protocol=<span class="string">&quot;HTTP/1.1&quot;</span></span><br><span class="line">             connectionTimeout=<span class="string">&quot;20000&quot;</span></span><br><span class="line">             redirectPort=<span class="string">&quot;8443&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。</p>
</blockquote>
<ul>
<li>Tomcat部署项目：<br>将项目放置到webapps目录下，即部署完成</li>
</ul>
<blockquote>
<p>基于SpringBoot开发的web应用程序，内置了Tomcat服务器，当启动类运行时，会自动启动内嵌的Tomcat服务器，无需手动配置。</p>
</blockquote>
<h2 id="5-请求响应"><a href="#5-请求响应" class="headerlink" title="5.请求响应"></a>5.请求响应</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811145530.png"
                     
                ></p>
<blockquote>
<p>请求响应：</p>
<ul>
<li>请求（HttpServletRequest）：获取请求数据</li>
<li>响应（HttpServletResponse）：设置响应数据<br><strong>BS架构</strong>：Browser-Server架构，浏览器向服务器发送请求，服务器处理请求，返回响应，浏览器接收响应，解析响应数据。客户端只需要浏览器，应用程序的逻辑和数据都存储在服务端。（维护方便 ，体验一般）<br><strong>CS架构</strong>：Client-Server架构，客户端向服务器发送请求，服务器处理请求，返回响应，客户端接收响应，解析响应数据。客户端需要浏览器和应用程序，应用程序的逻辑和数据都存储在客户端。（维护难，体验好）</li>
</ul>
</blockquote>
<h3 id="5-1-请求"><a href="#5-1-请求" class="headerlink" title="5.1 请求"></a>5.1 请求</h3><h4 id="5-1-1-简单参数"><a href="#5-1-1-简单参数" class="headerlink" title="5.1.1 简单参数"></a>5.1.1 简单参数</h4><ul>
<li><strong>原始方式</strong>：<br>在原始的web程序中，获取请求参数，需要通过<code>HttpServletRequest</code>对象手动获取。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811180928.png"
                     
                ><blockquote>
<p>通过<code>HttpServletRequest</code>对象获取请求参数，需要通过<code>getParameter()</code>方法获取，且获取到的请求参数都是字符串类型，需要手动转换为其他类型。</p>
</blockquote>
</li>
<li><strong>SpringBoot方式</strong><ul>
<li><font color="red"><strong>参数名与形参变量名相同</strong></font>，定义形参即可接收参数,且会自动进行类型转换。【可以不传递，不会报错】<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811183255.png"
                     
                ></li>
<li>如果方法形参名称与请求参数名称不匹配，可以使用<code>@RequestParam</code>注解，指定请求参数的名称。【默认情况下必须传递，否则会报错】<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811183613.png"
                     
                ><blockquote>
<p><strong>注意事项</strong>：<br><code>@RequestParam</code>中的<code>required</code>属性默认值为true，代表该请求参数必须传递，如果不传递将会报错。如果该参数是可选的，可以将<code>required</code>属性设置为false。<br><code>@RequestParam</code>中有三个属性：<code>name</code>、<code>required</code>、<code>defaultValue</code>，分别代表请求参数的名称、是否必须传递、默认值。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="5-1-2-实体参数"><a href="#5-1-2-实体参数" class="headerlink" title="5.1.2 实体参数"></a>5.1.2 实体参数</h4><ul>
<li><strong>简单实体参数</strong>：<br>请求参数名与形参对象属性名相同，定义POJO即可<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811184320.png"
                     
                ></li>
<li><strong>复杂实体参数</strong>：<br>请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811184552.png"
                     
                ></li>
</ul>
<blockquote>
<p><strong>注意事项</strong>：<br>可以在实体类中直接给定默认值，如果请求参数没有传递，则使用默认值。</p>
</blockquote>
<h4 id="5-1-3-数组集合参数"><a href="#5-1-3-数组集合参数" class="headerlink" title="5.1.3 数组集合参数"></a>5.1.3 数组集合参数</h4><ul>
<li><strong>数组参数</strong>：<br>请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收数组参数。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811201852.png"
                     
                ></li>
<li><strong>集合参数</strong>：<br>请求参数名与形参集合名称相同且请求参数为多个，<code>@RequestParam</code>绑定参数关系<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811202303.png"
                     
                ></li>
</ul>
<blockquote>
<p><strong>数组</strong>：请求参数名与形参中数组变量名相同，可以直接使用数组封装<br><strong>集合</strong>：请求参数名与形参中集合变量名相同，可以使用<code>@RequestParam</code>绑定参数关系</p>
</blockquote>
<h4 id="5-1-4-日期参数"><a href="#5-1-4-日期参数" class="headerlink" title="5.1.4 日期参数"></a>5.1.4 日期参数</h4><ul>
<li><strong>日期参数</strong>：<br>使用<code>@DateTimeFormat</code>注解，指定日期格式。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811202903.png"
                     
                ></li>
</ul>
<h4 id="5-1-5-JSON参数"><a href="#5-1-5-JSON参数" class="headerlink" title="5.1.5 JSON参数"></a>5.1.5 JSON参数</h4><ul>
<li><strong>JSON参数</strong>：<br>JSON数据<strong>键名</strong>与形参对象<strong>属性名</strong>相同，定义POJO类型形参即可接收参数，需要使用<code>@RequestBody</code>注解标识。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811203406.png"
                     
                ></li>
</ul>
<h4 id="5-1-6-路径参数"><a href="#5-1-6-路径参数" class="headerlink" title="5.1.6 路径参数"></a>5.1.6 路径参数</h4><ul>
<li><strong>路径参数</strong>：<br>通过请求URL直接传递参数，使用{……}来标识该路径参数，需要使用<code>@PathVariable</code>注解获取路径参数。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811203721.png"
                     
                ></li>
</ul>
<h4 id="5-1-7-小结"><a href="#5-1-7-小结" class="headerlink" title="5.1.7 小结"></a>5.1.7 小结</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811203929.png"
                     
                ></p>
<h3 id="5-2-响应"><a href="#5-2-响应" class="headerlink" title="5.2 响应"></a>5.2 响应</h3><h4 id="5-2-1-响应数据"><a href="#5-2-1-响应数据" class="headerlink" title="5.2.1 响应数据"></a>5.2.1 响应数据</h4><p><strong><code>@ResponseBody</code></strong>：</p>
<ul>
<li>类型：<strong>方法注解</strong>、<strong>类注解</strong></li>
<li>位置：Controller方法上&#x2F;类上</li>
<li>作用：将方法返回值直接响应，如果返回值是 实体对象&#x2F;集合，将会转换为JSON格式响应。</li>
<li>说明：<strong><code>@RestController</code></strong> &#x3D;&#x3D; <strong><code>@Controller</code></strong>+<strong><code>@ResponseBody</code></strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811204403.png"
                     
                ></p>
<blockquote>
<p>如果不添加<code>@ResponseBody</code>注解，Spring会认为返回值是一个视图名称。</p>
</blockquote>
<h4 id="5-2-2-统一响应结果"><a href="#5-2-2-统一响应结果" class="headerlink" title="5.2.2 统一响应结果"></a>5.2.2 统一响应结果</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811204521.png"
                     
                ></p>
<h2 id="6-分层解耦"><a href="#6-分层解耦" class="headerlink" title="6.分层解耦"></a>6.分层解耦</h2><h3 id="6-1-三层架构"><a href="#6-1-三层架构" class="headerlink" title="6.1 三层架构"></a>6.1 三层架构</h3><ul>
<li><strong><code>controller</code></strong>：控制层，接收前端发送的请求，对请求进行处理，并响应数据</li>
<li><strong><code>service</code></strong>：业务逻辑层，处理具体的业务逻辑，调用DAO层进行数据访问</li>
<li><strong><code>dao</code></strong>：数据访问层（持久层），负责数据访问操作，包括数据的增删改查</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811212617.png"
                     
                ></p>
<h3 id="6-2-分层解耦"><a href="#6-2-分层解耦" class="headerlink" title="6.2 分层解耦"></a>6.2 分层解耦</h3><ul>
<li><strong>内聚</strong>：软件中各个功能模块内部的功能联系。</li>
<li><strong>耦合</strong>：衡量软件中各个层&#x2F;模块之间的依赖、关联的程度。</li>
<li><strong>软件设计原则</strong>：高内聚低耦合。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811212945.png"
                     
                ></p>
<h3 id="6-3-IOC-DI-入门"><a href="#6-3-IOC-DI-入门" class="headerlink" title="6.3 IOC &amp; DI 入门"></a>6.3 IOC &amp; DI 入门</h3><h4 id="6-3-1-Bean的声明"><a href="#6-3-1-Bean的声明" class="headerlink" title="6.3.1 Bean的声明"></a>6.3.1 Bean的声明</h4><p>要把某个对象交给IOC容器管理，需要先在对应的类上加上如下注解之一：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Component</code></td>
<td>声明Bean的基础注解</td>
<td>不属于以下三类时，使用此注解</td>
</tr>
<tr>
<td><code>@Controller</code></td>
<td>@Component的衍生注解</td>
<td>标注在控制器类上</td>
</tr>
<tr>
<td><code>@Service</code></td>
<td>@Component的衍生注解</td>
<td>标注在业务类上</td>
</tr>
<tr>
<td><code>@Repository</code></td>
<td>@Component的衍生注解</td>
<td>标注在数据访问类上 (由于与mybatis整合，用的少)</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意事项</strong>：</p>
<ul>
<li>声明Bean的时候，可以通过value属性指定Bean的名称，如果没有指定，默认为类名首字母小写。</li>
<li>使用以上四个注解都可以声明Bean，但在SpringBoot集成web开发中，声明控制器Bean只能使用<code>@Controller</code>注解。</li>
</ul>
</blockquote>
<h4 id="6-3-2-Bean组件扫描"><a href="#6-3-2-Bean组件扫描" class="headerlink" title="6.3.2 Bean组件扫描"></a>6.3.2 Bean组件扫描</h4><ul>
<li>前面声明Bean的四大注解，要想生效，还需要被组件扫描<code>@ComponentScan</code>扫描。</li>
<li><code>@ComponentScan</code>注解虽然没有显示配置，但是实际上已经包含在了启动类声明注解<code>SpringBootApplication</code>中。</li>
<li>默认扫描的范围是启动类所在包及其子包。</li>
</ul>
<h4 id="6-3-3-Bean的依赖注入"><a href="#6-3-3-Bean的依赖注入" class="headerlink" title="6.3.3 Bean的依赖注入"></a>6.3.3 Bean的依赖注入</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240811214504.png"
                     
                ></p>
<ol>
<li>依赖注入的注解<ul>
<li><code>@Autowired</code>：默认按照类型自动装配。</li>
<li>如果同类型的Bean存在多个：<ul>
<li><code>@Primary</code>：指定Bean的优先级。</li>
<li><code>@Autowired + @Qualifier(&quot;Bean的名称&quot;)</code>：</li>
<li><code>@Resource(name = &quot;Bean的名称&quot;)</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>@Resource</strong>与<b>@Autowired</b>区别：<ul>
<li>@Autowired是Spring框架提供的注解，而@Resource是JDK提供的注解</li>
<li>@Autowired默认是按照类型注入，而@Resource默认是按照名称注入</li>
</ul>
</li>
</ol>
<h2 id="7-Lombok"><a href="#7-Lombok" class="headerlink" title="7.Lombok"></a>7.Lombok</h2><ul>
<li>Lombok是一个实用的Java类库，能通过注解的形式自动生成构造器、getter&#x2F;setter、equals、hashCode、toString等方法，并可以自动生成日志变量，简化Java开发、提高效率。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240813114516.png"
                     
                ></li>
</ul>
<blockquote>
<p><strong>注意事项</strong>：<br>Lombok会在编译时，自动生成对应的Java代码。我们使用Lombok时，还需要安装一个lombok插件（idea自带）。</p>
</blockquote>
<h2 id="8-MyBatis"><a href="#8-MyBatis" class="headerlink" title="8.MyBatis"></a>8.MyBatis</h2><ul>
<li>MyBatis是一款优秀的<font color="red">持久层(dao)</font>框架，用于简化JDBC的开发。</li>
<li>MyBatis本是Apache的一个开源项目iBatis，2010年这个项目由Apache迁移到了Google Code，并且改名为MyBatis。2013年11月迁移到Github。</li>
<li>官网：<a class="link"   href="https://mybatis.org/" >https://mybatis.org<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<h3 id="8-1-快速入门"><a href="#8-1-快速入门" class="headerlink" title="8.1 快速入门"></a>8.1 快速入门</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240813104626.png"
                     
                ></p>
<h3 id="8-2-JDBC介绍"><a href="#8-2-JDBC介绍" class="headerlink" title="8.2 JDBC介绍"></a>8.2 JDBC介绍</h3><ul>
<li><strong>JDBC</strong>：<br>Java DataBase Connectivity，就是使用Java语言操作关系型数据库的一套API。</li>
<li><strong>本质</strong>：<ul>
<li>sun公司官方定义的一套操作所有关系型数据库的规范，即接口。</li>
<li>各个数据库厂商去实现这套接口，提供数据库<font color="red">驱动jar包</font>。</li>
<li>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240813105135.png"
                     
                ></p>
<h3 id="8-3-数据库连接池"><a href="#8-3-数据库连接池" class="headerlink" title="8.3 数据库连接池"></a>8.3 数据库连接池</h3><ul>
<li><strong>概念</strong>：<ul>
<li>数据库连接池是一个容器，负责分配，管理数据库连接(Connection)</li>
<li>它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</li>
<li>释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏</li>
</ul>
</li>
<li><strong>优势</strong>：<ul>
<li>资源重用</li>
<li>提升系统响应速度</li>
<li>避免数据库连接遗漏</li>
</ul>
</li>
<li><strong>标准接口</strong>：<code>DataSource</code><ul>
<li>官方(Sun)提供的数据库连接池接口，由第三方组织实现此类接口。</li>
<li>功能：获取连接 <code>Connection getConnection() throws SQLException;</code></li>
</ul>
</li>
<li><strong>常见产品</strong>：<br><strong>C3P0、DBCP、Druid、Hikari（springboot默认）</strong><ul>
<li>Durid(德鲁伊)：是阿里巴巴开源的一个数据库连接池实现，它具有监控功能、SQL防火墙、SQL优化功能等。</li>
</ul>
</li>
<li><strong>切换Druid数据库连接池</strong>：<ul>
<li>官方地址：<a class="link"   href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter" >https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>添加依赖(pom.xml)：<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在pom.xml中添加依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<h3 id="8-4-基础操作"><a href="#8-4-基础操作" class="headerlink" title="8.4 基础操作"></a>8.4 基础操作</h3><h4 id="8-4-1-参数占位符"><a href="#8-4-1-参数占位符" class="headerlink" title="8.4.1 参数占位符"></a>8.4.1 参数占位符</h4><ul>
<li><strong><code>#&#123;……&#125;</code></strong>：<ul>
<li>在执行SQL时，会将<code>#&#123;……&#125;</code>替换为 ? ,生成预编译SQL，会自动设置参数值。</li>
<li>使用时机：参数传递，都使用<code>#&#123;……&#125;</code>。</li>
<li><font color="red"><strong>不能直接在引号内使用，因为如果将 #{……} 放在引号内，MyBatis 会将其处理为一个普通的字符串值，而不会进行参数替换。</strong></font><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240813164518.png"
                     
                ></li>
</ul>
</li>
<li><strong><code>$&#123;……&#125;</code></strong>：<ul>
<li>拼接SQL，直接将参数拼接在SQL语句中，存在SQL注入问题。</li>
<li>使用时机：如果对表名、列表进行动态设置时使用。<blockquote>
<p><strong>总结</strong>：</p>
<ul>
<li>动态值 使用 #{key}，动态的列名、容器名、关键字等使用 ${……}。</li>
<li>？只能替代值的位置，不能替代标签、列名、表名、关键字等。emp_id &#x3D; ? ，不能写 ？&#x3D; ?</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//注解方式传入参数！！</span></span><br><span class="line">&gt;<span class="meta">@Select(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)</span></span><br><span class="line">&gt;User <span class="title function_">findByColumn</span><span class="params">(<span class="meta">@Param(&quot;column&quot;)</span> String column, <span class="meta">@Param(&quot;value&quot;)</span> String value)</span>;</span><br></pre></td></tr></table></figure></div></blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="8-4-2-预编译SQL"><a href="#8-4-2-预编译SQL" class="headerlink" title="8.4.2 预编译SQL"></a>8.4.2 预编译SQL</h4><p><strong>优势</strong>：</p>
<ul>
<li>性能更高</li>
<li>更安全(防止SQL注入)<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240813164710.png"
                     
                ></li>
</ul>
<h4 id="8-4-3-日志输出"><a href="#8-4-3-日志输出" class="headerlink" title="8.4.3 日志输出"></a>8.4.3 日志输出</h4><p>可以在application.yml中，打开mybatis的日志，并指定输出到控制台。</p>
<div class="code-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># 配置mybatis的日志, 指定输出到控制台</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">    <span class="comment"># 开启mybatis的驼峰命名自动映射开关 a_column ------&gt; aCloumn</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></div>
<h4 id="8-4-4-删除"><a href="#8-4-4-删除" class="headerlink" title="8.4.4 删除"></a>8.4.4 删除</h4><ul>
<li><strong>SQL语句：</strong><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">17</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>接口方法：</strong><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Delete(&quot;delete from emp where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<blockquote>
<p><strong>注意事项</strong>：<br>如果mapper接口方法形参只有一个普通类型的参数，#{……}里面的属性名可以随便写，如：#{id}、#{value}，但最好和参数名一致。</p>
</blockquote>
<h4 id="8-4-5-添加"><a href="#8-4-5-添加" class="headerlink" title="8.4.5 添加"></a>8.4.5 添加</h4><p><strong>无需主键返回</strong></p>
<ul>
<li><strong>SQL语句：</strong><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert into</span> emp(username, gender, email, dept_id) <span class="keyword">values</span> (<span class="string">&#x27;宋江&#x27;</span>,<span class="number">1</span>,<span class="number">1056985080</span><span class="variable">@qq</span>.com,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></div></li>
<li><strong>接口方法：</strong><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Insert(&quot;insert into emp(username, gender, email, dept_id) values (#&#123;username&#125;,#&#123;gender&#125;,#&#123;email&#125;,#&#123;deptId&#125;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Emp emp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// emp对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> Short gender;</span><br><span class="line">  <span class="keyword">private</span> String email;</span><br><span class="line">  <span class="keyword">private</span> Integer deptId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>主键返回</strong></p>
<ul>
<li><strong>描述</strong>：<br>在数据添加成功后，需要获取插入数据库数据的主键值。（eg：添加套餐数据后，还需要维护套餐菜品关系表数据）</li>
<li><strong>实现</strong>：<br>在接口方法前添加<code>@Options(keyProperty = &quot;id&quot;, useGeneratedKeys = true)</code>注解 &#x3D;&gt; 会自动将生成的主键值，赋值给emp对象的id属性。<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Options(keyProperty = &quot;id&quot;, useGeneratedKeys = true)</span></span><br><span class="line"><span class="meta">@Insert(&quot;insert into emp(username, gender, email, dept_id) values (#&#123;username&#125;,#&#123;gender&#125;,#&#123;email&#125;,#&#123;deptId&#125;&quot;)</span></span><br><span class="line"><span class="meta">public void insert(Emp emp);</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="8-4-6-更新"><a href="#8-4-6-更新" class="headerlink" title="8.4.6 更新"></a>8.4.6 更新</h4><ul>
<li><strong>SQL语句(根据ID更新员工信息)：</strong><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> username <span class="operator">=</span> <span class="string">&#x27;李逵&#x27;</span>, gender <span class="operator">=</span> <span class="number">1</span>, email <span class="operator">=</span> <span class="string">&#x27;1056985080@qq.com&#x27;</span>, dept_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">17</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>接口方法：</strong><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Update(&quot;update emp set username = #&#123;username&#125;, gender = #&#123;gender&#125;, email = #&#123;email&#125;, dept_id = #&#123;deptId&#125; where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Emp emp)</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="8-4-7-查询"><a href="#8-4-7-查询" class="headerlink" title="8.4.7 查询"></a>8.4.7 查询</h4><p><strong>根据ID查询</strong></p>
<ul>
<li><strong>SQL语句：</strong><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">17</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>接口方法：</strong><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from emp where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Emp <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure></div>
<strong>模糊查询</strong></li>
<li><strong>SQL语句：</strong><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">&#x27;%张%&#x27;</span> <span class="keyword">and</span> gender <span class="operator">=</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>接口方法：</strong><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from emp where username like &#x27;%$&#123;name&#125;%&#x27; and gender = #&#123;gender&#125; order by id desc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">getByNameAndGender</span><span class="params">(String name, Short gender)</span>;</span><br><span class="line"><span class="comment">// 性能低、不安全，存在SQL注入问题</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Select(&quot;select * from emp where username like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) and gender = #&#123;gender&#125; order by id desc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">getByNameAndGender</span><span class="params">(String name, Short gender)</span>;</span><br><span class="line"><span class="comment">// 性能高、安全，不会存在SQL注入问题</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><b><code>concat()</code></b>函数：连接字符串，eg：concat(‘%’,#{name},’%’)，解决<code>#&#123;……&#125;</code>不能直接在引号中使用的问题。</p>
<h4 id="8-4-8-参数名说明"><a href="#8-4-8-参数名说明" class="headerlink" title="8.4.8 参数名说明"></a>8.4.8 参数名说明</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240813174439.png"
                     
                ></p>
<h4 id="8-4-9-数据封装"><a href="#8-4-9-数据封装" class="headerlink" title="8.4.9 数据封装"></a>8.4.9 数据封装</h4><ul>
<li>实体类属性名 和 数据库表查询返回的字段名一致，mybatis会自动封装。</li>
<li>如果实体类属性名 和 数据库表查询返回的字段名不一致，不能自动封装。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240813174948.png"
                     
                ></li>
</ul>
<p>解决方式：</p>
<ul>
<li><p><strong>起别名</strong>：在SQL语句中，对不一样的列名器别名，别名和实体类中的属性名一致。(<code>as</code>可以省略)</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select id, username, gender, email, dept_id as deptId from emp where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Emp <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li><p><strong>手动结果映射</strong>：</p>
<ul>
<li>通过<b><code>@Results</code></b>和<b><code>@Result</code></b>注解，手动映射。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from emp where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">  @Result(column = &quot;dept_id&quot;, property = &quot;deptId&quot;),</span></span><br><span class="line"><span class="meta">  @Result(column = &quot;create_time&quot;, property = &quot;createTime&quot;),</span></span><br><span class="line"><span class="meta">  @Result(column = &quot;update_time&quot;, property = &quot;updateTime&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> Emp <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>通过<b><code>&lt;resultMap&gt;</code></b>标签定义对应关系，再在后面的SQL语句中引用这个对应关系</li>
</ul>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 专门声明一个resultMap设定column到property之间的对应关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByRMResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 使用id标签设置主键列和主键属性之间的对应关系 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- column属性用于指定字段名；property属性用于指定Java实体类属性名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;emp_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empId&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 使用result标签设置普通字段和Java实体类属性之间的关系 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_salary&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empSalary&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Employee selectEmployeeByRM(Integer empId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByRM&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;selectEmployeeByRMResultMap&quot;</span>&gt;</span></span><br><span class="line">select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
<li><p><strong>开启驼峰命名</strong>：如果字段名与属性名符合驼峰命名法则，mybatis会自动通过驼峰命名规则映射。<br>主要用于单层级的字段映射。它不能自动处理更复杂的场景，例如多层级的嵌套对象或深层次的属性名转换。</p>
<div class="code-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在application.yml中，开启驼峰命名自动映射开关。即从数据库字段名a_column映射到实体类属性名aCloumn。</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="attr">configuration:</span></span><br><span class="line">  <span class="comment"># 配置mybatis的日志, 指定输出到控制台</span></span><br><span class="line">  <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="comment"># 开启mybatis的驼峰命名自动映射开关 a_column ------&gt; aCloumn</span></span><br><span class="line">  <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>开启自动映射</strong>：<code>autoMappingBehavior</code> 是 MyBatis 中的一个全局配置项，用于控制 MyBatis 如何自动映射查询结果中的列到 Java 实体类的属性上。根据配置的不同，<code>autoMappingBehavior</code> 可以影响映射的自动化程度，从而减少或增加手动配置的需求。它有以下三个配置选项：</p>
<div class="code-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># 配置MyBatis的日志, 指定输出到控制台</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">    <span class="comment"># 设置MyBatis的自动映射行为</span></span><br><span class="line">    <span class="attr">auto-mapping-behavior:</span> <span class="string">NONE</span> <span class="comment"># 可选值：NONE, PARTIAL, FULL</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong><code>NONE</code></strong>：MyBatis 不会自动映射任何列到实体类属性。所有的映射关系必须手动配置，通常通过 <code>@Result</code> 注解或 <code>&lt;resultMap&gt;</code> 标签来指定。这种模式适合需要对映射关系进行严格控制的场景，以避免意外的映射错误。</li>
<li><strong><code>PARTIAL</code></strong>（默认值）：MyBatis 会自动映射查询结果中的列到实体类属性，但只限于那些没有在 <code>ResultMap</code> 中明确定义过的列。如果在 <code>ResultMap</code> 中已经定义了某列的映射关系，则 MyBatis 不会再次自动映射该列。<code>PARTIAL</code> 是大多数情况下的推荐设置，能够在保持映射控制的同时，自动处理简单的映射任务。</li>
<li><strong><code>FULL</code></strong>：MyBatis 会尝试自动映射所有查询结果中的列到实体类属性，无论这些列是否在 <code>ResultMap</code> 中定义。<code>FULL</code> 设置适合简单对象的映射，能够减少手动配置的工作量。但在复杂映射场景中，可能导致意外的映射错误，因此需要谨慎使用。</li>
<li><strong>应用场景与注意事项</strong>：<code>autoMappingBehavior</code> 的设置直接影响 MyBatis 的自动映射能力。设置为 <code>FULL</code> 时，MyBatis 可以帮助自动处理简单的<strong>嵌套对象映射</strong>，但对于复杂的嵌套结构，手动映射依然是必不可少的。即使设置为 <code>FULL</code> 或 <code>PARTIAL</code>，在复杂或关键场景下，建议依然手动配置映射，以确保映射的准确性和可控性。此外，在处理大数据量或复杂对象映射时，<code>FULL</code> 的自动映射可能增加系统负担，因此在性能敏感的应用中应谨慎选择。</li>
</ul>
</li>
</ul>
<h4 id="8-4-10-多表映射"><a href="#8-4-10-多表映射" class="headerlink" title="8.4.10 多表映射"></a>8.4.10 多表映射</h4><ul>
<li><p><strong>一对一映射</strong>：<br>在一对一关联中，一个实体对象包含另一个实体对象，通常通过外键关系实现。使用 <strong><code>@One</code></strong> 注解、**<code>@Result</code><strong>注解、</strong><code>&lt;association&gt;</code>**标签均可以帮助 MyBatis 自动处理这种关系的查询和映射。</p>
<p><strong>示例</strong>：<br>假设我们有两个表：<code>user</code> 和 <code>address</code>，它们之间存在一对一关系。</p>
<ul>
<li><p><code>user</code> 表：</p>
<ul>
<li><code>id</code>（用户ID）</li>
<li><code>name</code>（用户名）</li>
<li><code>address_id</code>（外键，指向 <code>address</code> 表的 ID）</li>
</ul>
</li>
<li><p><code>address</code> 表：</p>
<ul>
<li><code>id</code>（地址ID）</li>
<li><code>street</code>（街道）</li>
<li><code>city</code>（城市）</li>
</ul>
</li>
</ul>
<p><strong>实体类</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address; <span class="comment">// 一对一关系</span></span><br><span class="line">    <span class="comment">// Getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="comment">// Getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<ol>
<li><p><strong>注解方式 (<code>@One</code> 注解)</strong><br>  在 <code>UserMapper</code> 中，使用 <code>@One</code> 注解来配置一对一关联。在这种方式中，<code>@One</code> 注解用于指定如何从主查询的结果集中加载一个单一的关联对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT u.id, u.name, a.id AS address_id, a.street, a.city &quot; +</span></span><br><span class="line"><span class="meta">             &quot;FROM user u &quot; +</span></span><br><span class="line"><span class="meta">             &quot;LEFT JOIN address a ON u.address_id = a.id &quot; +</span></span><br><span class="line"><span class="meta">             &quot;WHERE u.id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;name&quot;, property = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;address_id&quot;, property = &quot;address&quot;,</span></span><br><span class="line"><span class="meta">                one = @One(select = &quot;com.example.mapper.AddressMapper.findById&quot;))</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>@Result(column = &quot;address_id&quot;, property = &quot;address&quot;, one = @One(select = &quot;com.example.mapper.AddressMapper.findById&quot;))</code>：<ul>
<li><code>column</code>：数据库字段名。</li>
<li><code>property</code>：实体类中的属性名。</li>
<li><code>one</code>：指定一个方法来查询 <code>Address</code> 对象，<code>select</code> 属性指向了 <code>AddressMapper</code> 中的方法 <code>findById</code>。</li>
</ul>
</li>
</ul>
 <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AddressMapper</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Select(&quot;SELECT id, street, city FROM address WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">   Address <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>注解方式 (<code>@Result</code> 注解)</strong><br>  在 <code>UserMapper</code> 中，使用 <code>@Result</code> 注解来直接映射数据库字段到实体类的属性。如果关联对象的属性在主查询中被直接包含，则可以通过 <code>@Result</code> 注解来映射。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT u.id, u.name, a.id AS address_id, a.street, a.city &quot; +</span></span><br><span class="line"><span class="meta">            &quot;FROM user u &quot; +</span></span><br><span class="line"><span class="meta">            &quot;LEFT JOIN address a ON u.address_id = a.id &quot; +</span></span><br><span class="line"><span class="meta">            &quot;WHERE u.id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;name&quot;, property = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;address_id&quot;, property = &quot;address.id&quot;), // 自动映射到 Address 对象</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;street&quot;, property = &quot;address.street&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;city&quot;, property = &quot;address.city&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>@Result(column = &quot;address_id&quot;, property = &quot;address.id&quot;)</code>：自动将 <code>address_id</code> 映射到 <code>Address</code> 对象的 <code>id</code> 属性。</li>
<li><code>@Result(column = &quot;street&quot;, property = &quot;address.street&quot;)</code>：将 <code>street</code> 映射到 <code>Address</code> 对象的 <code>street</code> 属性。</li>
</ul>
</li>
<li><p><strong>XML 配置方式 (<code>&lt;association&gt;</code> 标签)</strong><br>在 <code>UserMapper.xml</code> 中，通过 <code>&lt;association&gt;</code> 标签指定如何查询和映射关联对象。</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT u.id, u.name, a.id AS address_id, a.street, a.city</span><br><span class="line">    FROM user u</span><br><span class="line">    LEFT JOIN address a ON u.address_id = a.id</span><br><span class="line">    WHERE u.id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.example.pojo.Address&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;address_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;street&quot;</span> <span class="attr">property</span>=<span class="string">&quot;street&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;city&quot;</span> <span class="attr">property</span>=<span class="string">&quot;city&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>&lt;association&gt;</code> 标签</strong>：用于指定如何加载和映射关联对象。<ul>
<li><code>property</code>：在主对象中用来表示关联对象的属性名。</li>
<li><code>javaType</code>：被关联的实体类的全类名。</li>
<li><code>&lt;id&gt;</code>：映射主键字段。</li>
<li><code>&lt;result&gt;</code>：映射其他字段。</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>总结</strong></p>
<ul>
<li><strong><code>@One</code> 注解</strong>：用于在注解方式中配置一对一关系，通过指定 <code>select</code> 属性来查询关联对象。</li>
<li><strong><code>@Result</code> 注解</strong>：直接映射查询结果到实体对象的属性，包括嵌套对象的属性。</li>
<li><strong><code>&lt;association&gt;</code> 标签</strong>：在 XML 配置中定义一对一关系，通过指定 <code>property</code> 和 <code>javaType</code> 来配置如何映射关联对象。</li>
</ul>
</blockquote>
<ul>
<li><p><strong>一对多映射</strong>：<br>假设我们有两个表：<code>user</code> 和 <code>orders</code>，其中一个用户 (<code>user</code>) 可以有多个订单 (<code>orders</code>)。我们将展示如何在 <code>User</code> 对象中使用 <code>@Many</code> 注解以及在 XML 配置中使用 <code>&lt;collection&gt;</code> 标签来处理一对多关系。</p>
<p><strong>实体类</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orders; <span class="comment">// 一对多关系</span></span><br><span class="line">    <span class="comment">// Getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String product;</span><br><span class="line">    <span class="keyword">private</span> Integer userId; <span class="comment">// 外键</span></span><br><span class="line">    <span class="comment">// Getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<ol>
<li><p><strong>使用 <code>@Many</code> 注解</strong><br>在这种方式中，我们在 <code>UserMapper</code> 接口中使用 <code>@Many</code> 注解来定义一对多关系。<br><strong>Mapper 接口</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;SELECT u.id, u.name, o.id AS order_id, o.product &quot; +</span></span><br><span class="line"><span class="meta">            &quot;FROM user u &quot; +</span></span><br><span class="line"><span class="meta">            &quot;LEFT JOIN orders o ON u.id = o.user_id &quot; +</span></span><br><span class="line"><span class="meta">            &quot;WHERE u.id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;name&quot;, property = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;id&quot;, property = &quot;orders&quot;, </span></span><br><span class="line"><span class="meta">                many = @Many(select = &quot;com.example.mapper.OrderMapper.findByUserId&quot;))</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>OrderMapper 接口</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;SELECT id, product, user_id FROM orders WHERE user_id = #&#123;userId&#125;&quot;)</span></span><br><span class="line">    List&lt;Order&gt; <span class="title function_">findByUserId</span><span class="params">(Integer userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong><code>@Many</code> 注解</strong>：在 <code>UserMapper</code> 中，<code>@Result</code> 注解的 <code>many</code> 属性指定了如何加载 <code>orders</code> 属性。<code>select</code> 属性指向 <code>OrderMapper</code> 中的 <code>findByUserId</code> 方法，该方法返回<br>与  <code>userId</code> 相关的所有订单。</li>
</ul>
</li>
<li><p><strong>使用 XML 配置中的 <code>&lt;collection&gt;</code> 标签</strong><br>在这种方式中，我们使用 XML 配置文件来定义一对多关系。</p>
<p><strong>UserMapper.xml</strong></p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT u.id, u.name, o.id AS order_id, o.product</span><br><span class="line">        FROM user u</span><br><span class="line">        LEFT JOIN orders o ON u.id = o.user_id</span><br><span class="line">        WHERE u.id = #&#123;id&#125;</span><br><span class="line">        <span class="comment">&lt;!-- 使用 `&lt;collection&gt;` 标签定义一对多关系 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.example.pojo.Order&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;product&quot;</span> <span class="attr">property</span>=<span class="string">&quot;product&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong><code>&lt;collection&gt;</code> 标签</strong>：用于定义 <code>User</code> 对象中的 <code>orders</code> 集合属性。<code>property</code> 属性指定集合属性的名称，<code>ofType</code> 属性指定集合中元素的类型。在查询结果中，MyBatis 会自动 将结果集中的多个订单映射到 <code>User</code> 对象的 <code>orders</code> 属性中。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>总结</strong></p>
<ul>
<li><strong><code>@Many</code> 注解</strong>：在 <code>UserMapper</code> 中通过 <code>@Many</code> 注解指定如何查询与 <code>User</code> 相关的多个 <code>Order</code> 对象。这种方式简洁明了，并且适用于注解方式的配置。</li>
<li><strong>XML 配置中的 <code>&lt;collection&gt;</code> 标签</strong>：在 <code>UserMapper.xml</code> 中使用 <code>&lt;collection&gt;</code> 标签来定义一对多关系。通过这种方式，你可以在 XML 文件中清晰地配置如何将多个结果映射到 <code>User</code> 对象的集合属性中。这种方式适用于 XML 配置文件，并允许你在查询中定义更复杂的映射逻辑。</li>
</ul>
</blockquote>
<ul>
<li><p><strong>三表查询</strong>：<br> 在 MyBatis 中处理三表关联时，通常涉及到多对多或更复杂的多级关联关系。我们可以通过多对一和一对多的组合来实现三表关联。下面我将展示一个处理三表关联的完整示例，包括使用注解和 XML 配置两种方式。</p>
<p> <strong>示例</strong><br> 假设我们有以下三张表：</p>
</li>
<li><p><strong><code>user</code> 表</strong>：存储用户信息。</p>
<ul>
<li><code>id</code>（用户ID）</li>
<li><code>name</code>（用户名）</li>
</ul>
</li>
<li><p><strong><code>orders</code> 表</strong>：存储订单信息，关联到 <code>user</code> 表。</p>
<ul>
<li><code>id</code>（订单ID）</li>
<li><code>product</code>（产品名）</li>
<li><code>user_id</code>（外键，指向 <code>user</code> 表的 ID）</li>
</ul>
</li>
<li><p><strong><code>order_items</code> 表</strong>：存储订单项信息，关联到 <code>orders</code> 表。</p>
<ul>
<li><code>id</code>（订单项ID）</li>
<li><code>order_id</code>（外键，指向 <code>orders</code> 表的 ID）</li>
<li><code>item_name</code>（订单项名）</li>
</ul>
<p><strong>实体类</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orders; <span class="comment">// 一对多关系：用户 -&gt; 订单</span></span><br><span class="line">    <span class="comment">// Getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String product;</span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderItem&gt; orderItems; <span class="comment">// 一对多关系：订单 -&gt; 订单项</span></span><br><span class="line">    <span class="comment">// Getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderItem</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String itemName;</span><br><span class="line">    <span class="comment">// Getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>目标</strong><br>我们要查询 <code>User</code> 对象，并且包含用户的订单 (<code>Order</code>)，以及每个订单下的订单项 (<code>OrderItem</code>)。</p>
</li>
</ul>
<ol>
<li><p><strong>使用注解的方式</strong>：<br><strong>UserMapper 接口</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT u.id, u.name, o.id AS order_id, o.product &quot; +</span></span><br><span class="line"><span class="meta">            &quot;FROM user u &quot; +</span></span><br><span class="line"><span class="meta">            &quot;LEFT JOIN orders o ON u.id = o.user_id &quot; +</span></span><br><span class="line"><span class="meta">            &quot;WHERE u.id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;name&quot;, property = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;order_id&quot;, property = &quot;orders&quot;, </span></span><br><span class="line"><span class="meta">                many = @Many(select = &quot;com.example.mapper.OrderMapper.findByUserId&quot;))</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> <strong>OrderMapper 接口</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT id, product FROM orders WHERE user_id = #&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;product&quot;, property = &quot;product&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;id&quot;, property = &quot;orderItems&quot;, </span></span><br><span class="line"><span class="meta">                many = @Many(select = &quot;com.example.mapper.OrderItemMapper.findByOrderId&quot;))</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    List&lt;Order&gt; <span class="title function_">findByUserId</span><span class="params">(Integer userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>OrderItemMapper 接口</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderItemMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT id, item_name FROM order_items WHERE order_id = #&#123;orderId&#125;&quot;)</span></span><br><span class="line">    List&lt;OrderItem&gt; <span class="title function_">findByOrderId</span><span class="params">(Integer orderId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个配置中：</p>
<ul>
<li><strong><code>UserMapper</code></strong>：负责查询 <code>User</code> 信息及其关联的 <code>Order</code> 列表。<code>@Many</code> 注解指向 <code>OrderMapper</code> 中的 <code>findByUserId</code> 方法，该方法进一步加载每个订单的详细信息。</li>
<li><strong><code>OrderMapper</code></strong>：负责查询 <code>Order</code> 信息及其关联的 <code>OrderItem</code> 列表。<code>@Many</code> 注解指向 <code>OrderItemMapper</code> 中的 <code>findByOrderId</code> 方法。</li>
<li><strong><code>OrderItemMapper</code></strong>：负责查询 <code>OrderItem</code> 列表。</li>
</ul>
</li>
<li><p><strong>使用 XML 配置的方式</strong>：<br><strong>UserMapper.xml</strong></p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT u.id, u.name</span><br><span class="line">        FROM user u</span><br><span class="line">        WHERE u.id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.example.pojo.Order&quot;</span>&gt;</span></span><br><span class="line">            SELECT o.id AS order_id, o.product</span><br><span class="line">            FROM orders o</span><br><span class="line">            WHERE o.user_id = #&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orderItems&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.example.pojo.OrderItem&quot;</span>&gt;</span></span><br><span class="line">                SELECT oi.id AS item_id, oi.item_name</span><br><span class="line">                FROM order_items oi</span><br><span class="line">                WHERE oi.order_id = #&#123;order_id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>&lt;collection&gt;</code> 标签</strong>：用于定义一对多关系，首先映射 <code>User</code> 与 <code>Order</code> 之间的关系，然后在 <code>Order</code> 与 <code>OrderItem</code> 之间再次使用 <code>&lt;collection&gt;</code> 标签。</li>
<li><strong>多级映射</strong>：在 <code>UserMapper.xml</code> 中，我们嵌套使用 <code>&lt;collection&gt;</code> 标签来处理多级关联。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>总结</strong></p>
<ul>
<li><strong>注解方式</strong>：<code>@Many</code> 注解在三表关联中非常有效，可以简化代码，特别是在分布式项目中，但在复杂查询中可能不如 XML 配置灵活。</li>
<li><strong>XML 配置方式</strong>：<code>&lt;collection&gt;</code> 标签在处理复杂关联时更直观，尤其是当查询需要多级嵌套或复杂的结果映射时。</li>
</ul>
</blockquote>
<h3 id="8-5-XML映射文件"><a href="#8-5-XML映射文件" class="headerlink" title="8.5 XML映射文件"></a>8.5 XML映射文件</h3><ul>
<li><strong>规范</strong>：<ul>
<li>XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放在同一个包下(同包同名)。</li>
<li>XML映射文件的namespace属性与Mapper接口全限定名一致。</li>
<li>XML映射文件中的SQL语句的id属性与Mapper接口方法名一致，并保持返回类型一致。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240813183451.png"
                     
                ><blockquote>
<p>使用Mybatis的注解，主要是来完成一些简单的增删改查功能，如果需要实现复杂的SQL功能，建议使用XML来配置映射语句。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="8-5-1-if标签"><a href="#8-5-1-if标签" class="headerlink" title="8.5.1 if标签"></a>8.5.1 if标签</h4><ul>
<li><strong>&lt;if&gt;</strong>：<ul>
<li>用于判断条件是否成立，如果条件为true，则拼接SQL。</li>
<li>形式：&lt;if test&#x3D;”条件”&gt;……&lt;&#x2F;if&gt;。<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">&quot;gender != null&quot;</span>&gt;……&lt;/<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<h4 id="8-5-2-where标签"><a href="#8-5-2-where标签" class="headerlink" title="8.5.2 where标签"></a>8.5.2 where标签</h4><ul>
<li><strong>&lt;where&gt;</strong>：<ul>
<li>where元素只会在子元素有内容的情况下才能插入where子句，而且会自动去除子句开头的and或or</li>
<li>形式：&lt;where&gt;……&lt;&#x2F;where&gt;。<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;findUsers&quot;</span> resultType=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">  select * from user</span><br><span class="line">  &lt;where&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">          name = #&#123;name&#125;</span><br><span class="line">      &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">&quot;age != null&quot;</span>&gt;</span><br><span class="line">          <span class="type">and</span> <span class="variable">age</span> <span class="operator">=</span> #&#123;age&#125;</span><br><span class="line">      &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">&quot;gender != null and gender != &#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">          <span class="type">and</span> <span class="variable">gender</span> <span class="operator">=</span> #&#123;gender&#125;</span><br><span class="line">      &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">  &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<h4 id="8-5-3-set标签"><a href="#8-5-3-set标签" class="headerlink" title="8.5.3 set标签"></a>8.5.3 set标签</h4><ul>
<li><strong>&lt;set&gt;</strong>：<ul>
<li>动态地在行首插入set关键字，并会删除掉额外的逗号。（用在update语句中）</li>
<li>形式：&lt;set&gt;……&lt;&#x2F;set&gt;。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240813190655.png"
                     
                ></li>
</ul>
</li>
</ul>
<h4 id="8-5-4-foreach标签"><a href="#8-5-4-foreach标签" class="headerlink" title="8.5.4 foreach标签"></a>8.5.4 foreach标签</h4><ul>
<li>SQL语句：<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure></div></li>
<li>接口方法：<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 批量删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteByIds</span><span class="params">(List&lt;Integer&gt; ids)</span>;</span><br></pre></td></tr></table></figure></div></li>
<li>XML映射文件：<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 从 emp 表中删除满足条件的记录 --&gt;</span></span><br><span class="line">    delete from emp where id in</span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        使用 &lt;foreach&gt; 标签遍历传入的集合 ids</span></span><br><span class="line"><span class="comment">        collection=&quot;ids&quot; 表示传入的集合参数名称是 ids</span></span><br><span class="line"><span class="comment">        item=&quot;id&quot; 表示遍历集合中的每个元素，并将当前元素赋值给 id</span></span><br><span class="line"><span class="comment">        open=&quot;(&quot; 表示在遍历元素之前，SQL 语句中添加一个左括号 (</span></span><br><span class="line"><span class="comment">        separator=&quot;,&quot; 表示在每个元素之间，用逗号 , 作为分隔符</span></span><br><span class="line"><span class="comment">        close=&quot;)&quot; 表示在遍历元素之后，SQL 语句中添加一个右括号 )</span></span><br><span class="line"><span class="comment">        原SQL：delete from emp where id in (1,2,3,4,5)</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">            将当前遍历到的 id 以 #&#123;id&#125; 的形式插入到 SQL 语句中</span></span><br><span class="line"><span class="comment">            #&#123;id&#125; 是 MyBatis 的占位符，用于安全地传递参数，防止 SQL 注入</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
<li>属性：<ul>
<li><code>collection</code>：集合属性名。</li>
<li><code>item</code>：集合遍历出来的元素&#x2F;项的名称。</li>
<li><code>open</code>：遍历集合元素前的前缀。【在遍历元素之前需要往SQL语句中添加什么内容】</li>
<li><code>separator</code>：遍历集合元素间的分隔符。【在遍历元素之间需要往SQL语句中添加什么内容】</li>
<li><code>close</code>：遍历集合元素后的后缀。【在遍历元素之后需要往SQL语句中添加什么内容】</li>
</ul>
</li>
</ul>
<h4 id="8-5-5-sql片段"><a href="#8-5-5-sql片段" class="headerlink" title="8.5.5 sql片段"></a>8.5.5 sql片段</h4><ul>
<li><strong>&lt;sql&gt;</strong>：定义可重用的SQL片段。</li>
<li><strong>&lt;include&gt;</strong>：通过属性refid，指定包含的sql片段的id。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240813191643.png"
                     
                ></li>
</ul>
<h4 id="8-5-6-trim标签"><a href="#8-5-6-trim标签" class="headerlink" title="8.5.6 trim标签"></a>8.5.6 trim标签</h4><p>使用trim标签控制条件部分两端是否包含某些字符</p>
<ul>
<li>prefix属性：指定要动态添加的前缀</li>
<li>suffix属性：指定要动态添加的后缀</li>
<li>prefixOverrides属性：指定要动态去掉的前缀，使用”|”分隔有可能的多个值</li>
<li>suffixOverrides属性：指定要动态去掉的后缀，使用”|”分隔有可能的多个值</li>
</ul>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByTrim(Employee employee) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByConditionByTrim&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">    select emp_id,emp_name,emp_age,emp_salary,emp_gender</span><br><span class="line">    from t_emp</span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- prefix属性指定要动态添加的前缀 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- suffix属性指定要动态添加的后缀 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- prefixOverrides属性指定要动态去掉的前缀，使用“|”分隔有可能的多个值 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- suffixOverrides属性指定要动态去掉的后缀，使用“|”分隔有可能的多个值 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当前例子用where标签实现更简洁，但是trim标签更灵活，可以用在任何有需要的地方 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and|or&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span></span><br><span class="line">            emp_name=#&#123;empName&#125; and</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empSalary <span class="symbol">&amp;gt;</span> 3000&quot;</span>&gt;</span></span><br><span class="line">            emp_salary&gt;#&#123;empSalary&#125; and</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empAge <span class="symbol">&amp;lt;</span>= 20&quot;</span>&gt;</span></span><br><span class="line">            emp_age=#&#123;empAge&#125; or</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empGender==&#x27;male&#x27;&quot;</span>&gt;</span></span><br><span class="line">            emp_gender=#&#123;empGender&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="8-5-7-choose-when-otherwise标签"><a href="#8-5-7-choose-when-otherwise标签" class="headerlink" title="8.5.7 choose&#x2F;when&#x2F;otherwise标签"></a>8.5.7 choose&#x2F;when&#x2F;otherwise标签</h4><p>在多个分支条件中，仅执行一个。</p>
<ul>
<li>从上到下依次执行条件判断</li>
<li>遇到的第一个满足条件的分支会被采纳</li>
<li>被采纳分支后面的分支都将不被考虑</li>
<li>如果所有的when分支都不满足，那么就执行otherwise分支</li>
</ul>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByChoose(Employee employee) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByConditionByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">    select emp_id,emp_name,emp_salary from t_emp</span><br><span class="line">    where</span><br><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span>emp_name=#&#123;empName&#125;<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empSalary <span class="symbol">&amp;lt;</span> 3000&quot;</span>&gt;</span>emp_salary <span class="symbol">&amp;lt;</span> 3000<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span>1=1<span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     第一种情况：第一个when满足条件 where emp_name=?</span></span><br><span class="line"><span class="comment">     第二种情况：第二个when满足条件 where emp_salary &lt; 3000</span></span><br><span class="line"><span class="comment">     第三种情况：两个when都不满足 where 1=1 执行了otherwise</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<h2 id="9-项目搭建"><a href="#9-项目搭建" class="headerlink" title="9. 项目搭建"></a>9. 项目搭建</h2><h3 id="9-1-环境搭建"><a href="#9-1-环境搭建" class="headerlink" title="9.1 环境搭建"></a>9.1 环境搭建</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240814223026.png"
                     
                ></p>
<h3 id="9-2-开发规范"><a href="#9-2-开发规范" class="headerlink" title="9.2 开发规范"></a>9.2 开发规范</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240814224344.png"
                     
                ></p>
<blockquote>
<p><strong>注意事项</strong>：</p>
<ul>
<li>REST是风格，是约定方式，约定不是硬性规定，可以打破。</li>
<li>描述模块的功能通常是复数， 也就是加s的格式来描述，表示此类资源，而非单个资源。如：uers、emps、books……</li>
</ul>
</blockquote>
<h3 id="9-3-RequestMapping"><a href="#9-3-RequestMapping" class="headerlink" title="9.3 @RequestMapping"></a>9.3 @RequestMapping</h3><ul>
<li>类级别的<b><code>RequestMapping</code></b>定义了所有该类中处理方法的共同URL前缀。</li>
<li>方法级别的<b><code>RequestMapping</code></b>则在类级别的URL基础上进一步细分，指定具体的处理路径（eg：GET、POST）。可以使用更具体的GetMapping、PostMapping等注解替代。<br>如果不指定，默认情况下任何请求方式都可以访问。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240814232320.png"
                     
                ></li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用方法级别的@RequestMapping注解</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">postHello</span><span class="params">(<span class="meta">@RequestBody</span> String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法级别的@GetMapping、@PostMapping注解</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">postHello</span><span class="params">(<span class="meta">@RequestBody</span> String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<blockquote>
<p><strong>注意事项</strong>：</p>
<ul>
<li><b><code>@RequestMapping</code></b>不用必须使用 &#x2F; 开头</li>
<li><b><code>@RequestMapping</code></b>可以同时指定多个URL路径，用数组表示，如：<code>@RequestMapping(value = &#123;&quot;/hello&quot;, &quot;/hi&quot;&#125;)</code></li>
<li><b><code>@RequestMapping</code></b>可以同时指定多个请求方式，用数组表示，如：<code>@RequestMapping(value = &quot;/hello&quot;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;)</code></li>
<li><b><code>@RequestMapping</code></b>支持模糊匹配，* 表示任意一层字符串，**表示任意层字符串。</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">/hello/* -&gt; /hello/world  /hello/world123 [不可以是 /hello/world/123]</span><br><span class="line">/hello/** -&gt; /hello  /hello/world  /hello/world/123</span><br></pre></td></tr></table></figure></div>
<ul>
<li>方法前必须加上<b><code>@RequestMapping</code></b>注解，就算类上已经添加了<b><code>@RequestMapping</code></b>注解，否则该方法将不会被识别成外部请求。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span> <span class="comment">// 不能省略， url: /hello </span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></blockquote>
<h3 id="9-4-PageHelper分页插件"><a href="#9-4-PageHelper分页插件" class="headerlink" title="9.4 PageHelper分页插件"></a>9.4 PageHelper分页插件</h3><ul>
<li><strong>导入依赖</strong>：<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong>使用方法</strong>：<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">List&lt;Emp&gt; list = empMapper.list();</span><br><span class="line">Page&lt;Emp&gt; page = (Page&lt;Emp&gt;)list;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240814232438.png"
                     
                ></li>
</ul>
<h3 id="9-5-文件上传"><a href="#9-5-文件上传" class="headerlink" title="9.5 文件上传"></a>9.5 文件上传</h3><ul>
<li><strong>简介</strong>：<ul>
<li>文件上传，是指将本地图片、视频、音频等文件上传到服务器，供其它用户浏览或下载的过程。</li>
<li>文件上传在项目中应用非常广泛，我们经常发微博、发微信朋友圈都用到了文件上传功能。</li>
</ul>
</li>
<li><strong>前端页面</strong>：<ul>
<li>表单项 type&#x3D;”file”</li>
<li>表单提交方式 post</li>
<li>表单的enctype属性：multipart&#x2F;form-data<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240815212704.png"
                     
                ></li>
</ul>
</li>
<li><strong>服务端接收文件</strong>：<ul>
<li><b><code>MultipartFile</code></b>接口<ul>
<li>String getOriginalFilename()：获取原始文件名</li>
<li>void transferTo(File dest)：将文件保存到指定位置</li>
<li>long getSize()：获取文件大小,单位：字节</li>
<li>byte[] getBytes()：获取文件内容的字节数组</li>
<li>InputStream getInputStream()：获取接收到的文件内容的输入流</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9-5-1-本地仓库"><a href="#9-5-1-本地仓库" class="headerlink" title="9.5.1 本地仓库"></a>9.5.1 本地仓库</h4>  <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileController</span> &#123;</span><br><span class="line">  <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">upload</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 获取原始文件名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">    <span class="comment">// 构建新的文件名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">newFilename</span> <span class="operator">=</span> UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="comment">// 将文件保存在服务端 本地仓库 E:/images/ 目录下</span></span><br><span class="line">    file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/images/&quot;</span> + newFilename));</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在SpringBoot中，文件上传，默认单个文件允许最大大小为 1M，如果需要上传大文件，可以进行如下配置：</p>
<div class="code-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在application.yml中配置</span></span><br><span class="line"><span class="attr">servlet:</span></span><br><span class="line">  <span class="attr">multipart:</span></span><br><span class="line">    <span class="comment"># 配置单个文件最大上传大小</span></span><br><span class="line">    <span class="attr">max-file-size:</span> <span class="string">10MB</span></span><br><span class="line">    <span class="comment"># 配置单个请求最大上传大小（一次请求可以上传多个文件）</span></span><br><span class="line">    <span class="attr">max-request-size:</span> <span class="string">100MB</span></span><br></pre></td></tr></table></figure></div></blockquote>
<h4 id="9-5-2-阿里云OSS"><a href="#9-5-2-阿里云OSS" class="headerlink" title="9.5.2 阿里云OSS"></a>9.5.2 阿里云OSS</h4><ul>
<li><strong>引入阿里云OSS相关依赖</strong>：<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.17.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- no more than 2.3.3--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.jaxb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong>引入阿里云OSS上传文件工具类（由官方的示例代码改造而来）</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818220917.png"
                     
                ></li>
<li><strong>上传图片接口开发</strong>：<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line">  <span class="comment">/* 本地存储</span></span><br><span class="line"><span class="comment">  @PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="comment">  public Result upload(MultipartFile image) throws IOException &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      // 获取原始文件名</span></span><br><span class="line"><span class="comment">      String originalFilename = image.getOriginalFilename();</span></span><br><span class="line"><span class="comment">      // 构建新的文件名</span></span><br><span class="line"><span class="comment">      String newFileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      // 将文件保存到本地</span></span><br><span class="line"><span class="comment">      image.transferTo(new File(&quot;E:\\Edge下载（定期删除）\\day11-SpringBootWeb案例\\&quot; + newFileName));</span></span><br><span class="line"><span class="comment">      return Result.success();</span></span><br><span class="line"><span class="comment">  &#125;*/</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> AliOSSUtils aliOSSUtils;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestParam</span> MultipartFile image)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      log.info(<span class="string">&quot;文件上传，文件名：&#123;&#125;&quot;</span>,image.getOriginalFilename());</span><br><span class="line">      <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> aliOSSUtils.upload(image);</span><br><span class="line">      log.info(<span class="string">&quot;文件上传完成，文件访问的url：&#123;&#125;&quot;</span>,url);</span><br><span class="line">      <span class="keyword">return</span> Result.success(url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="9-6-配置文件"><a href="#9-6-配置文件" class="headerlink" title="9.6 配置文件"></a>9.6 配置文件</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240816100225.png"
                     
                ></p>
<ul>
<li><strong>yml文件基本语法</strong>：<ul>
<li>大小写敏感</li>
<li>数值前边必须有空格，作为分隔符</li>
<li>使用缩进表示层级关系，缩进时，不允许使用Tab键，只能使用空格（idea中会自动将Tab键转换为空格）</li>
<li>缩进的空格数目不重要，只要相同层级的元素左对齐即可</li>
<li># 表示注解，从这个字符开始到行尾，都是注释，不会被解析</li>
</ul>
</li>
</ul>
<h3 id="9-7-外部配置注入"><a href="#9-7-外部配置注入" class="headerlink" title="9.7 外部配置注入"></a>9.7 外部配置注入</h3><p>在Spring框架中，<code>@Value</code>和<code>@ConfigurationProperties</code>注解用于将外部配置的值注入到Spring管理的Bean中。它们的使用场景和功能有所不同，下面分别讲解它们的作用和使用方法。</p>
<ul>
<li><p><b><code>@Value</code> 注解</b><br><code>@Value</code>注解用于将配置文件中的单个属性值注入到Spring Bean的字段或方法中。它通常用于注入简单的属性值，比如字符串、数值等。</p>
<ol>
<li><strong>基本语法</strong>：</li>
</ol>
 <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;property.key&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String propertyValue;</span><br></pre></td></tr></table></figure></div>
<p> 其中<code>$&#123;property.key&#125;</code>表示从配置文件（如<code>application.properties</code>或<code>application.yml</code>）中读取指定键的值。</p>
<ol start="2">
<li><strong>默认值</strong>：<br> 可以在<code>@Value</code>注解中指定一个默认值，当配置文件中找不到相应的键时，使用默认值：</li>
</ol>
 <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;property.key:defaultValue&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String propertyValue;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><strong>复杂表达式</strong>：<br> <code>@Value</code>也可以使用Spring表达式语言（SpEL）来处理复杂的值：</li>
</ol>
 <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;T(java.lang.Math).random() * 100&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> randomValue;</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li><strong>使用示例</strong><br>假设在<code>application.properties</code>文件中有以下配置：</li>
</ol>
<div class="code-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">app.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="attr">app.version</span>=<span class="string">1.0.0</span></span><br></pre></td></tr></table></figure></div>
<p>可以在Bean中使用<code>@Value</code>注解注入这些值：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.version&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appVersion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><b><code>@ConfigurationProperties</code> 注解 </b><br><code>@ConfigurationProperties</code>用于将<strong>一组相关的配置属性</strong>绑定到一个Java类的属性上。它可以将配置文件中的属性自动映射到类的字段中，尤其适用于需要处理一组复杂或嵌套配置的场景。</p>
<ol>
<li><strong>基本语法</strong>：<br> 定义一个类来对应配置文件中的一组属性：</li>
</ol>
 <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p> <code>prefix = &quot;app&quot;</code>表示这个类将映射<code>application.properties</code>或<code>application.yml</code>中以<code>app</code>开头的属性。</p>
<ol start="2">
<li><strong>启用<code>@ConfigurationProperties</code></strong>：<br> 通常需要使用<code>@EnableConfigurationProperties</code>注解或<code>@Component</code>来让Spring管理这个配置类：</li>
</ol>
 <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(AppProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 其他配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p> 或者在配置类上直接使用<code>@Component</code>：<br> <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 如果已经在配置类中使用了@EnableConfigurationProperties，则不需要再使用@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppProperties</span> &#123;</span><br><span class="line">    <span class="comment">// fields, getters, setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<ol start="3">
<li>使用示例<br>假设在<code>application.properties</code>文件中有以下配置：</li>
</ol>
<div class="code-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">app.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="attr">app.version</span>=<span class="string">1.0.0</span></span><br><span class="line"><span class="attr">app.details.description</span>=<span class="string">This is a demo application.</span></span><br><span class="line"><span class="attr">app.details.author</span>=<span class="string">John Doe</span></span><br></pre></td></tr></table></figure></div>

<p>可以定义一个类来映射这些配置：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Details</span> <span class="variable">details</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Details</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Details</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String description;</span><br><span class="line">        <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getters and setters</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这样，<code>AppProperties</code>类中的字段会自动映射到配置文件中的相应属性值。</p>
</li>
</ul>
<blockquote>
<p> <strong>主要区别</strong></p>
<ul>
<li><strong>粒度</strong>：<code>@Value</code>用于注入单个属性值，而<code>@ConfigurationProperties</code>更适合注入一组相关的属性。</li>
<li><strong>类型安全</strong>：<code>@ConfigurationProperties</code>支持类型安全的配置绑定，并且可以通过构建复杂对象来映射嵌套属性，而<code>@Value</code>只能注入简单的属性值。</li>
<li><strong>可维护性</strong>：<code>@ConfigurationProperties</code>有助于将配置集中管理，并且对属性进行结构化处理，这对大型项目的配置管理更为友好。</li>
<li><strong>@Value的局限性</strong>：<code>@Value</code>只能注入单个属性值，不能注入集合、数组等。<br><strong>选择建议</strong></li>
<li>当需要注入单个或少量的配置值时，使用<code>@Value</code>。</li>
<li>当需要注入大量相关配置或希望将配置分组时，使用<code>@ConfigurationProperties</code>。</li>
</ul>
</blockquote>
<p>在Spring框架中，<code>@PropertySource</code>和<code>@ConfigurationProperties</code>都涉及配置属性的管理，但它们的作用和使用场景有所不同，不能简单地认为它们是类似的。<br><strong><code>@PropertySource</code>的作用</strong></p>
<ul>
<li><strong>用途</strong>：<code>@PropertySource</code>主要用于<strong>加载自定义的属性文件</strong>（如<code>.properties</code>文件）到Spring的<code>Environment</code>中。通过这个注解，Spring能够识别和使用这些属性文件中的键值对。</li>
<li><strong>典型场景</strong>：<ul>
<li><p>当你的配置文件不是默认的<code>application.properties</code>或<code>application.yml</code>，而是自定义的文件时，需要用<code>@PropertySource</code>来加载这个文件。</p>
</li>
<li><p>例如，如果你有一个名为<code>custom.properties</code>的文件，且希望Spring加载其中的配置项，那么可以使用<code>@PropertySource</code>注解：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:custom.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 配置类内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><strong>配合<code>@Value</code>使用</strong>：<code>@PropertySource</code>通常与<code>@Value</code>注解配合使用，从加载的属性文件中读取具体的属性值并注入到Bean的字段中。</li>
</ul>
<p><strong><code>@ConfigurationProperties</code>的作用</strong></p>
<ul>
<li><strong>用途</strong>：<code>@ConfigurationProperties</code>用于将<strong>一组相关的配置属性</strong>绑定到一个Java类的属性上。它可以将配置文件中的属性自动映射到类的字段中，尤其适用于需要处理一组复杂或嵌套配置的场景。</li>
<li><strong>典型场景</strong>：<ul>
<li>当你有一组相关的配置项，比如与应用程序、数据库、消息队列等相关的多个配置项时，可以使用<code>@ConfigurationProperties</code>将这些配置项整合到一个专门的配置类中。</li>
<li>例如，假设有以下配置：<div class="code-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">app.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="attr">app.version</span>=<span class="string">1.0.0</span></span><br><span class="line"><span class="attr">app.details.description</span>=<span class="string">This is a description</span></span><br><span class="line"><span class="attr">app.details.author</span>=<span class="string">John Doe</span></span><br></pre></td></tr></table></figure></div>
可以使用<code>@ConfigurationProperties</code>将这些属性映射到类中：<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Details</span> <span class="variable">details</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Details</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Details</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String description;</span><br><span class="line">        <span class="keyword">private</span> String author;</span><br><span class="line">        <span class="comment">// Getters and Setters</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p><strong><code>@PropertySource</code> vs. <code>@ConfigurationProperties</code></strong></p>
<ul>
<li><strong><code>@PropertySource</code></strong>：负责告诉Spring从哪里加载配置文件，并与<code>@Value</code>结合使用，允许单独注入具体的配置值。<code>@PropertySource</code>只加载属性文件，不负责属性的绑定和注入。</li>
<li><strong><code>@ConfigurationProperties</code></strong>：负责将一组相关的配置属性映射到一个Java类中，通常用于处理结构化的、较复杂的配置。<code>@ConfigurationProperties</code>不仅加载属性，还绑定它们到类的字段上，使配置的管理更加方便和结构化。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><strong>相似点</strong>：两者都与配置属性的处理有关，但<code>@PropertySource</code>更侧重于属性文件的加载，而<code>@ConfigurationProperties</code>侧重于属性值的绑定和管理。</li>
<li><strong>使用场景不同</strong>：<code>@PropertySource</code>用于从自定义的文件加载属性，而<code>@ConfigurationProperties</code>则用于将这些属性整合到Java类中进行统一管理。 ^223021</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="9-8-登录校验"><a href="#9-8-登录校验" class="headerlink" title="9.8 登录校验"></a>9.8 登录校验</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240816154423.png"
                     
                ></p>
<h4 id="9-8-1-会话技术"><a href="#9-8-1-会话技术" class="headerlink" title="9.8.1 会话技术"></a>9.8.1 会话技术</h4><ul>
<li><strong>会话</strong>：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含<strong>多次</strong>请求和响应。</li>
<li><strong>会话跟踪</strong>：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自同一浏览器，以便在同一次会话的多次请求间<strong>共享数据</strong>。</li>
<li><strong>会话跟踪方案</strong>：<ul>
<li>客户端会话跟踪技术：Cookie</li>
<li>服务器会话跟踪技术：Session</li>
<li>令牌技术：Token<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240816161533.png"
                     
                ></li>
</ul>
</li>
</ul>
<p><strong>Cookie</strong>：</p>
<ol>
<li><p><strong>什么是Cookie？</strong><br>Cookie是由服务器生成并发送到客户端（浏览器）的小型文本文件。客户端会将这些Cookie存储在本地，并在每次访问相同服务器时将它们包含在HTTP请求中，发送回服务器。</p>
</li>
<li><p><strong>Cookie的工作原理</strong></p>
</li>
</ol>
<ul>
<li><p><strong>生成和存储</strong>：当用户第一次访问网站时，服务器可以生成一个或多个Cookie，并通过HTTP响应头将它们发送到客户端。客户端浏览器接收到这些Cookie后，会根据服务器指示（如<code>Expires</code>或<code>Max-Age</code>属性）将Cookie存储在本地。</p>
</li>
<li><p><strong>发送Cookie</strong>：在用户的后续请求中，浏览器会自动将与该域名匹配的所有Cookie附加到HTTP请求中，发送给服务器。服务器可以读取这些Cookie的值，以便识别用户的身份或保持会话状态。</p>
</li>
<li><p><strong>Cookie属性</strong>：</p>
<ul>
<li><code>Name=Value</code>：Cookie的名称和值，浏览器会在后续请求中发送这些信息。</li>
<li><code>Domain</code>：指定Cookie属于哪个域名，浏览器只会在访问该域名时发送此Cookie。</li>
<li><code>Path</code>：指定Cookie适用的路径，只有访问此路径或子路径时，Cookie才会被发送。</li>
<li><code>Expires/Max-Age</code>：设置Cookie的过期时间，决定Cookie在客户端存储的时长。</li>
<li><code>HttpOnly</code>：防止客户端脚本访问Cookie，增加安全性。</li>
<li><code>Secure</code>：指示Cookie只能通过HTTPS发送，防止Cookie在传输过程中被截获。</li>
<li><code>SameSite</code>：防止跨站请求伪造攻击（CSRF）。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>Cookie的应用场景</strong></li>
</ol>
<ul>
<li><strong>会话管理</strong>：保存用户登录状态，跟踪用户在网站上的活动。</li>
<li><strong>个性化设置</strong>：保存用户偏好，如主题、语言选择等。</li>
<li><strong>跟踪和分析</strong>：用于广告跟踪、用户行为分析等。</li>
</ul>
<ol start="4">
<li><strong>Cookie的优缺点</strong></li>
</ol>
<ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li>易于使用：可以在客户端和服务器之间简单地传递信息。</li>
<li>跨请求保持状态：允许在多个请求之间保持状态（如用户登录状态）。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>安全性问题：存储在客户端，容易被篡改或窃取。</li>
<li>数据量有限：通常一个Cookie的大小限制为4KB，且总数有限。</li>
<li>性能影响：每次请求都会带上Cookie，可能影响带宽和性能。</li>
<li>不能跨域。</li>
</ul>
</li>
</ul>
<blockquote>
<p>跨域问题只是针对浏览器的，后端不同服务器之间的数据传输不会存在跨域问题</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240816161757.png"
                     
                ></p>
<ul>
<li><strong>样例</strong></li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CookieController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Cookie</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/c1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">cookie1</span><span class="params">(HttpServletResponse response)</span>&#123;</span><br><span class="line">        response.addCookie(<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;login_username&quot;</span>, <span class="string">&quot;itheima&quot;</span>));<span class="comment">// 设置Cookie/响应Cookie</span></span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Cookie 两种方法</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/c2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">cookie2</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">for</span>(Cookie cookie : cookies)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cookie.getName().equals(<span class="string">&quot;login_username&quot;</span>))&#123;</span><br><span class="line">                log.info(<span class="string">&quot;login_username:&#123;&#125;&quot;</span>,cookie.getValue());</span><br><span class="line">                <span class="keyword">return</span> Result.success();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;未找到指定Cookie&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/c3&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">cookie3</span><span class="params">(<span class="meta">@CookieValue(&quot;login_username&quot;)</span> String username)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.success(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>Session</strong>：</p>
<ol>
<li><p><strong>什么是Session？</strong><br>Session是服务器端的一种会话机制，用于跟踪和保存用户的状态和数据。与Cookie不同，Session数据存储在服务器端，客户端只保留一个标识符（通常是Session ID）。</p>
</li>
<li><p><strong>Session的工作原理</strong></p>
</li>
</ol>
<ul>
<li><p><strong>生成Session</strong>：当用户访问服务器时，服务器会创建一个Session，并生成一个唯一的Session ID。这个Session ID会通过Cookie或URL参数传递给客户端。</p>
</li>
<li><p><strong>存储和检索</strong>：服务器将与该Session相关的数据存储在服务器端（如内存、数据库或文件系统）。当客户端再次发送请求时，会带上Session ID，服务器根据这个ID检索相应的Session数据。</p>
</li>
<li><p><strong>Session的生命周期</strong>：</p>
<ul>
<li><strong>创建</strong>：Session在用户首次访问时创建，并分配一个唯一的Session ID。</li>
<li><strong>过期</strong>：Session有一定的有效期（可配置），当用户长时间不活动，Session会自动过期和销毁。</li>
<li><strong>销毁</strong>：用户主动登出或Session过期后，Session数据会从服务器端删除。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>Session的应用场景</strong></li>
</ol>
<ul>
<li><strong>用户认证</strong>：保存用户登录信息，确保用户在会话期间不需要重复登录。</li>
<li><strong>购物车功能</strong>：保存用户的购物车内容，在整个会话期间保持一致。</li>
<li><strong>用户跟踪</strong>：跟踪用户在网站上的操作，并根据这些操作做出响应。</li>
</ul>
<ol start="4">
<li><strong>Session的优缺点</strong></li>
</ol>
<ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>安全性较高</strong>：由于Session数据存储在服务器端，不容易被用户篡改或窃取。</li>
<li><strong>支持复杂数据</strong>：可以在Session中存储复杂的对象和数据结构。</li>
<li><strong>保持状态</strong>：适合需要在多个请求之间保持复杂状态的应用。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>占用服务器资源</strong>：每个用户的Session数据都存储在服务器上，用户数量多时可能导致服务器资源消耗过大。</li>
<li><strong>扩展性问题</strong>：在分布式系统中，Session管理较为复杂，需要采取措施（如Session共享、Session粘性）来保证用户会话的一致性。</li>
</ul>
</li>
<li><p><strong>样例</strong></p>
</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往HttpSession中存储值</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/s1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">session1</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;HttpSession-s1:&#123;&#125;&quot;</span>, session.hashCode());</span><br><span class="line">        session.setAttribute(<span class="string">&quot;loginUser&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>); <span class="comment">// 往session中存储数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往HttpSession中获取值</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">session2</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        log.info(<span class="string">&quot;HttpSession-s2:&#123;&#125;&quot;</span>, session.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">loginUser</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;loginUser&quot;</span>); <span class="comment">// 从session中获取数据</span></span><br><span class="line">        log.info(<span class="string">&quot;loginUser:&#123;&#125;&quot;</span>, loginUser);</span><br><span class="line">        <span class="keyword">return</span> Result.success(loginUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240816164049.png"
                     
                ></p>
<p><strong>JWT</strong>：<br>JWT（JSON Web Token）是一种常用的认证机制，它允许在网络应用中安全地在客户端和服务器之间传递信息。与Cookie和Session相比，JWT有着独特的工作方式和应用场景。</p>
<ol>
<li><strong>什么是JWT？</strong><br>JWT是一种开放标准（RFC 7519），用于在各方之间作为JSON对象安全传输信息。信息可以被验证和信任，因为它是数字签名的。JWT通常用于认证和授权。</li>
<li><strong>JWT的工作原理</strong></li>
</ol>
<ul>
<li><p><strong>生成JWT</strong>：当用户成功登录后，服务器会生成一个JWT。这个Token由三部分组成：<strong>Header（头部）</strong>、<strong>Payload（负载）<strong>和</strong>Signature（签名）</strong>。</p>
<ul>
<li><strong>Header</strong>：指定Token的类型（通常是JWT）和签名算法（如HMAC SHA256或RSA）。例如：{“alg”:”HS256”,”type”:”JWT”}</li>
<li><strong>Payload</strong>：包含声明（Claims），即需要传输的用户信息、默认信息或其他数据。这些数据是公开的，任何人都可以解码查看。例如：{“id”:1,”username”:”Tom”}</li>
<li><strong>Signature</strong>：由Header和Payload通过指定的算法加密生成，用于验证Token的真实性，确保安全性。</li>
</ul>
</li>
<li><p><strong>生成的JWT通常类似这样</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240816174046.png"
                     
                ></p>
</li>
<li><p><strong>测试样例</strong>：  </p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 在pom.xml中添加依赖：</span></span><br><span class="line"> &lt;!--JWT配置--&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;<span class="number">0.9</span><span class="number">.1</span>&lt;/version&gt; &lt;!-- 请检查最新版本号 --&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line"> <span class="comment">// 测试样例</span></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">genjwt</span><span class="params">()</span>&#123;</span><br><span class="line">	Map&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	claims.put(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">	claims.put(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">	<span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">			.setClaims(claims) <span class="comment">// 自定义内容(载荷)</span></span><br><span class="line">			.signWith(SignatureAlgorithm.HS256, <span class="string">&quot;lusy&quot;</span>)<span class="comment">// 签名算法</span></span><br><span class="line">			.setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + <span class="number">12</span> * <span class="number">3600</span> * <span class="number">1000</span>)) <span class="comment">// 有效期 单位 ms</span></span><br><span class="line">			.compact();</span><br><span class="line">	System.out.println(jwt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><p><strong>传递JWT</strong>：JWT生成后，服务器会将其返回给客户端。客户端通常将JWT存储在<code>Local Storage</code>、<code>Session Storage</code>或Cookie中。</p>
</li>
<li><p><strong>验证JWT</strong>：在后续请求中，客户端会将JWT包含在请求头（通常是<code>Authorization: Bearer &lt;token&gt;</code>）中发送给服务器。服务器接收到JWT后，会使用相同的签名算法和密钥验证Token的真实性，并从Payload中提取用户信息。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseJwt</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">			.setSigningKey(<span class="string">&quot;lusy&quot;</span>)<span class="comment">// 指定签名秘钥</span></span><br><span class="line">			.parseClaimsJws(<span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6IjEiLCJleHAiOjE3MjM4NDk2MzIsInVzZXJuYW1lIjoiVG9tIn0.KrQ-8Y4ISZds9DZ_OHaXvrrLM-4By84ngwV8vz9A6bE&quot;</span>)<span class="comment">// 解析令牌</span></span><br><span class="line">			.getBody();</span><br><span class="line">	System.out.println(claims);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p><strong>注意事项</strong>：</p>
<ul>
<li>JWT校验时使用的签名秘钥，必须和生成的JWT令牌时使用的秘钥是配套的。</li>
<li>如果JWT令牌解析校验时报错，则说明JWT令牌被篡改或失效了，令牌非法。</li>
</ul>
</blockquote>
</li>
</ul>
<ol start="3">
<li><strong>JWT的应用场景</strong></li>
</ol>
<ul>
<li><p><strong>用户认证</strong>：在用户登录成功后，服务器生成JWT并返回给客户端。客户端在后续请求中携带这个JWT，以证明自己的身份。</p>
</li>
<li><p><strong>授权</strong>：服务器可以在JWT的Payload中包含用户的权限信息（如角色、权限范围），以决定用户能访问哪些资源。</p>
</li>
<li><p><strong>信息交换</strong>：JWT可以安全地传输信息，因为它是经过签名的，接收方可以验证信息的来源和完整性。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240816191747.png"
                     
                ></p>
<ol start="4">
<li><strong>JWT的优缺点</strong></li>
</ol>
<ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>无状态</strong>：JWT是无状态的，不需要在服务器端存储会话信息，这使得它非常适合分布式系统。</li>
<li><strong>跨域支持</strong>：JWT不依赖于Cookie，因此可以在不同域名之间轻松传递。</li>
<li><strong>可扩展性</strong>：JWT的Payload部分可以包含自定义的声明，灵活性高。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>安全性风险</strong>：JWT的Payload部分是可见的，尽管它是签名的，但不能加密。如果存储敏感信息，可能会有安全隐患。</li>
<li><strong>Token大小</strong>：JWT通常比传统的Session ID大，因为它包含了更多信息，这可能增加网络传输的开销。</li>
<li><strong>Token管理</strong>：一旦JWT被签发，服务器无法主动撤销Token的权限，除非采用额外的策略（如Token黑名单）。</li>
</ul>
</li>
</ul>
<p><strong>会话跟踪方案对比</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240816191918.png"
                     
                ></p>
<h4 id="9-8-2-过滤器Filter"><a href="#9-8-2-过滤器Filter" class="headerlink" title="9.8.2 过滤器Filter"></a>9.8.2 过滤器Filter</h4><ul>
<li><p><strong>概述</strong>：</p>
<ul>
<li>概念：Filter 过滤器，是JavaWeb三大组件(Servlet,Filter,Listener)之一。</li>
<li>过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。</li>
<li>过滤器一般完成一些通用的操作，比如：登录校验，统一编码处理、敏感字符处理等。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240816192401.png"
                     
                ></li>
</ul>
</li>
<li><p><strong>快速入门</strong>：</p>
<ol>
<li>创建一个Filter类，实现Filter接口，重写接口中的方法。</li>
<li>配置Filter：Filter类加上<code>@WebFilter</code>注解，配置拦截资源的路径，引导类上加<code>@ServletComponentScan</code>注解开启Servlet组件支持。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240816192829.png"
                     
                ></li>
</ol>
</li>
<li><p><strong>拦截路径</strong>：<br>Filter可以根据需求，配置不同的拦截资源路径：</p>
<table>
<thead>
<tr>
<th align="left">拦截路径</th>
<th align="left">urlPatterns值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">拦截具体路径</td>
<td align="left"><code>/login</code></td>
<td align="left">只有访问 <code>/login</code> 路径时，才会被拦截</td>
</tr>
<tr>
<td align="left">目录拦截</td>
<td align="left"><code>/emps/*</code></td>
<td align="left">访问 <code>/emps/</code> 下的所有资源，都会被拦截</td>
</tr>
<tr>
<td align="left">拦截所有</td>
<td align="left"><code>/*</code></td>
<td align="left">访问所有资源，都会被拦截</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><p><strong>执行流程</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240816193703.png"
                     
                ></p>
</li>
<li><p><strong>过滤器链</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240816193903.png"
                     
                ></p>
<blockquote>
<p><strong>注意</strong>：<br>存在多个过滤器时，过滤器的执行顺序是按照过滤器配置的顺序执行的。但如果没有明确指定执行顺序（例如通过@Order注解），那么容器通常会根据类名的字典顺序（字母顺序）来决定过滤器的执行顺序。</p>
</blockquote>
</li>
</ul>
<h4 id="9-8-3-拦截器-Interceptor"><a href="#9-8-3-拦截器-Interceptor" class="headerlink" title="9.8.3 拦截器(Interceptor)"></a>9.8.3 拦截器(Interceptor)</h4><ul>
<li><p><strong>概述</strong>：</p>
<ul>
<li>概念：是一种动态拦截方法调用的机制，类似于过滤器。Spring框架中提供的，用来动态拦截控制器方法的执行。</li>
<li>作用：拦截请求，在指定的方法调用前后，根据业务需要执行预先设定的代码。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240816202319.png"
                     
                ></li>
</ul>
</li>
<li><p><strong>快速入门</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240816202449.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240816202458.png"
                     
                ><br> <strong>WebMvcConfigurer</strong>： [[WebMvcConfigurer#^mk-20240915210900|WebMvcConfigurer接口的讲解]]</p>
</li>
<li><p><strong>拦截器可以根据需求，配置不同的拦截路径</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240816202719.png"
                     
                ></p>
</li>
<li><p><strong>执行流程</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240816202805.png"
                     
                ></p>
</li>
<li><p><strong>多个拦截器执行顺序</strong>：</p>
<ol>
<li><strong>preHandle() 方法</strong>：SpringMVC 会把所有拦截器收集到一起，然后按照配置顺序调用各个 preHandle() 方法。</li>
<li><strong>postHandle() 方法</strong>：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 postHandle() 方法。</li>
<li><strong>afterCompletion() 方法</strong>：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 afterCompletion() 方法。</li>
</ol>
</li>
</ul>
<h4 id="9-8-4-异常处理"><a href="#9-8-4-异常处理" class="headerlink" title="9.8.4 异常处理"></a>9.8.4 异常处理</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240816202951.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240816203024.png"
                     
                ></p>
<h3 id="9-9-参数校验"><a href="#9-9-参数校验" class="headerlink" title="9.9 参数校验"></a>9.9 参数校验</h3><blockquote>
<p>在 Web 应用三层架构体系中，表述层负责接收浏览器提交的数据，业务逻辑层负责数据的处理。为了能够让业务逻辑层基于正确的数据进行处理，我们需要在表述层对数据进行检查，将错误的数据隔绝在业务逻辑层之外。</p>
</blockquote>
<p><strong>校验概述</strong><br>  JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 标准中。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并过标准的验证接口对Bean进行验证。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>规则</th>
</tr>
</thead>
<tbody><tr>
<td><b><code>@Null</code></b></td>
<td>标注值必须为 null</td>
</tr>
<tr>
<td><b><code>@NotNull</code></b></td>
<td>标注值不可为 null</td>
</tr>
<tr>
<td><b><code>@AssertTrue</code></b></td>
<td>标注值必须为 true</td>
</tr>
<tr>
<td><b><code>@AssertFalse</code></b></td>
<td>标注值必须为 false</td>
</tr>
<tr>
<td><b><code>@Min(value)</code></b></td>
<td>标注值必须大于或等于 value</td>
</tr>
<tr>
<td><b><code>@Max(value)</code></b></td>
<td>标注值必须小于或等于 value</td>
</tr>
<tr>
<td><b><code>@DecimalMin(value)</code></b></td>
<td>标注值必须大于或等于 value</td>
</tr>
<tr>
<td><b><code>@DecimalMax(value)</code></b></td>
<td>标注值必须小于或等于 value</td>
</tr>
<tr>
<td><b><code>@Size(max,min)</code></b></td>
<td>标注值大小必须在 max 和 min 限定的范围内</td>
</tr>
<tr>
<td><b><code>@Digits(integer,fratction)</code></b></td>
<td>标注值值必须是一个数字，且必须在可接受的范围内</td>
</tr>
<tr>
<td><b><code>@Past</code></b></td>
<td>标注值只能用于日期型，且必须是过去的日期</td>
</tr>
<tr>
<td><b><code>@Future</code></b></td>
<td>标注值只能用于日期型，且必须是将来的日期</td>
</tr>
<tr>
<td><b><code>@Pattern(value)</code></b></td>
<td>标注值必须符合指定的正则表达式</td>
</tr>
</tbody></table>
<p>JSR 303 只是一套标准，需要提供其实现才可以使用。Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>规则</th>
</tr>
</thead>
<tbody><tr>
<td><b><code>@Email</code></b></td>
<td>标注值必须是格式正确的 Email 地址</td>
</tr>
<tr>
<td><b><code>@Length</code></b></td>
<td>标注值字符串大小必须在指定的范围内</td>
</tr>
<tr>
<td><b><code>@NotEmpty</code></b></td>
<td>标注值字符串不能是空字符串</td>
</tr>
<tr>
<td><b><code>@Range</code></b></td>
<td>标注值必须在指定的范围内</td>
</tr>
</tbody></table>
<p>Spring 4.0 版本已经拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在SpringMVC 中，可直接通过注动 <b><code>@EnableWebMvc</code></b> 的方式进行数据校验。Spring 的 LocalValidatorFactoryBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在Spring容器定义一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean中。Spring本身并没有提供JSR 303的实现，所以必须将JSR 303的实现者的jar包放到类路径下。</p>
<p>配置 <b><code>@EnableWebMvc</code></b> 后，SpringMVC 会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标注 @Validated 注解即可让 SpringMVC 在完成数据绑定后执行数据校验的作。<br><strong>操作演示</strong></p>
<ul>
<li><strong>导入依赖</strong></li>
</ul>
  <div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 校验注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 校验注解实现--&gt;</span>        </span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator-annotation-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>应用校验注解</strong></li>
</ul>
  <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.validation.constraints.Email;</span><br><span class="line"><span class="keyword">import</span> jakarta.validation.constraints.Min;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Length;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * projectName: com.atguigu.pojo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">//age   1 &lt;=  age &lt; = 150</span></span><br><span class="line">    <span class="meta">@Min(10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//name 3 &lt;= name.length &lt;= 6</span></span><br><span class="line">    <span class="meta">@Length(min = 3,max = 10)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//email 邮箱格式</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>handler标记和绑定错误收集</strong></li>
</ul>
  <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Validated</span> 代表应用校验注解! 必须添加!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">save</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> User user,</span></span><br><span class="line"><span class="params">                       //在实体类参数和 BindingResult 之间不能有任何其他参数, BindingResult可以接受错误信息,避免信息抛出!</span></span><br><span class="line"><span class="params">                       BindingResult result)</span>&#123;</span><br><span class="line">       <span class="comment">//判断是否有信息绑定错误! 有可以自行处理!</span></span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;错误&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> result.getFieldError().toString();</span><br><span class="line">            <span class="keyword">return</span> errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有,正常处理业务即可</span></span><br><span class="line">        System.out.println(<span class="string">&quot;正常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p> <strong>易混总结</strong><br> @NotNull、@NotEmpty、@NotBlank 都是用于在数据校验中检查字段值是否为空的注解，但是它们的用法和校验规则有所不同。</p>
<ol>
<li><p>@NotNull  (包装类型不为null)</p>
<p> @NotNull 注解是 JSR 303 规范中定义的注解，当被标注的字段值为 null 时，会认为校验失败而抛出异常。该注解不能用于字符串类型的校验，若要对字符串进行校验，应该使用 @NotBlank 或 @NotEmpty 注解。</p>
</li>
<li><p>@NotEmpty (集合类型长度大于0)</p>
<p> @NotEmpty 注解同样是 JSR 303 规范中定义的注解，对于 CharSequence、Collection、Map 或者数组对象类型的属性进行校验，校验时会检查该属性是否为 Null 或者 size()&#x3D;&#x3D;0，如果是的话就会校验失败。但是对于其他类型的属性，该注解无效。需要注意的是只校验空格前后的字符串，如果该字符串中间只有空格，不会被认为是空字符串，校验不会失败。</p>
</li>
<li><p>@NotBlank （字符串，不为null，切不为”  “字符串）</p>
<p> @NotBlank 注解是 Hibernate Validator 附加的注解，对于字符串类型的属性进行校验，校验时会检查该属性是否为 Null 或 “” 或者只包含空格，如果是的话就会校验失败。需要注意的是，@NotBlank 注解只能用于字符串类型的校验。</p>
</li>
</ol>
<p> 总之，这三种注解都是用于校验字段值是否为空的注解，但是其校验规则和用法有所不同。在进行数据校验时，需要根据具体情况选择合适的注解进行校验。</p>
</blockquote>
<h2 id="10-事务管理"><a href="#10-事务管理" class="headerlink" title="10. 事务管理"></a>10. 事务管理</h2><h3 id="10-1-事务回顾"><a href="#10-1-事务回顾" class="headerlink" title="10.1 事务回顾"></a>10.1 事务回顾</h3><ul>
<li><strong>概念</strong>：事务是一组操作的集合，它是一个不可分割的工作单位，这些操作<font color="red">要么同时成功，要么同时失败</font></li>
<li><strong>操作</strong>：<ul>
<li><strong>开启事务（一组操作开始前，开启事务）</strong>：<b><code>start transaction / begin</code>;</b></li>
<li><strong>提交事务（这组操作全部成功后，提交事务）</strong>：<b><code>commit</code>;</b></li>
<li><strong>回滚事务（中间任何一个操作出现异常，回滚事务）</strong>：<b><code>rollback</code>;</b></li>
</ul>
</li>
</ul>
<h3 id="10-2-Spring事务管理"><a href="#10-2-Spring事务管理" class="headerlink" title="10.2 Spring事务管理"></a>10.2 Spring事务管理</h3><ul>
<li><strong>注解</strong>：<b><code>@Transactional</code></b></li>
<li><strong>位置</strong>：业务(Service)层的方法上、类上、接口上</li>
<li><strong>作用</strong>：将当前方法交给Spring进行事务管理，方法执行前，开启事务；成功执行完毕，提交事务；出现异常，回滚事务<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240817205221.png"
                     
                ></li>
<li><strong>属性</strong>：<ul>
<li><b><code>rollbackFor</code>回滚</b>：默认情况下，只有出现<b><code>RuntimeException</code></b>才会回滚异常，<code>rollbackFor</code>属性用于控制出现何种异常类型，回滚事务</li>
<li><b><code>noRollbackFor</code>不回滚</b>：指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240817205844.png"
                     
                ><blockquote>
<p>如果<code>rollbackFor</code>和<code>noRollbackFor</code>同时指定同一类型，Spring的行为会出现冲突和不确定性</p>
</blockquote>
</li>
<li><b><code>timeout</code>超时时间</b>：当事务运行时间超过了指定的时间限制，事务将被强制回滚，并抛出一个 <strong>TransactionTimedOutException</strong> 异常。默认值为-1，表示永不超时<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240822140059.png"
                     
                ></li>
<li><b><code>propagation</code>传播行为</b>：指的是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240817210241.png"
                     
                ></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>属性值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>REQUIRED</code></td>
<td>【默认值】需要事务，有则加入，无则创建新事务</td>
</tr>
<tr>
<td><code>REQUIRES_NEW</code></td>
<td>需要新事务，无论有无，总是创建新事务</td>
</tr>
<tr>
<td><code>SUPPORTS</code></td>
<td>支持事务，有则加入，无则在无事务状态中运行</td>
</tr>
<tr>
<td><code>NOT_SUPPORTED</code></td>
<td>不支持事务，在无事务状态下运行，如果当前存在已有事务，则挂起当前事务</td>
</tr>
<tr>
<td><code>MANDATORY</code></td>
<td>必须有事务，否则抛出异常</td>
</tr>
<tr>
<td><code>NEVER</code></td>
<td>必须没有事务，否则抛出异常</td>
</tr>
</tbody></table>
<blockquote>
<ol>
<li><code>REQUIRED</code>：大部分情况下都是用该传播行为即可。</li>
<li><code>REQUIRES_NEW</code>：当我们不希望事务之间相互影响时，可以使用该传播行为。比如：下订单前需要记录日志，不论订单保存成功与否，都需要保证日志记录能够记录成功。</li>
</ol>
</blockquote>
<ul>
<li><b><code>isolation</code>隔离级别</b>：设置事务的隔离级别,mysql默认是repeatable read!</li>
</ul>
<ol>
<li><strong>读未提交（Read Uncommitted）</strong>：事务可以读取未被提交的数据，容易产生脏读、不可重复读和幻读等问题。实现简单但不太安全，一般不用。</li>
<li><strong>读已提交（Read Committed）</strong>：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读。</li>
<li><strong>可重复读（Repeatable Read）</strong>：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改。可以避免脏读和不可重复读，但仍有幻读的问题。</li>
<li><strong>串行化（Serializable）</strong>：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240822141436.png"
                     
                ><blockquote>
<p><strong>开启spring事务管理日志</strong>：<br>在配置文件中添加<br> <div class="code-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&gt;logging:</span></span><br><span class="line"><span class="attr">level:</span></span><br><span class="line">		<span class="attr">org.springframework.jdbc.support.JdbcTransactionManager:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure></div><br><strong>注意事项</strong>：<br>如果在非SpringBoot框架中想使用事务功能，需要在配置类添加<b><code>@EnableTransactionManagement</code></b>注解，编写一个Spring事务管理器配置类，并在pom.xml中添加引入spring-tx依赖。<br><b><code>@EnableTransactionManagement</code></b> 是Spring中的一个注解，用于启用Spring的注解驱动的事务管理功能。它通常与 <strong>@Configuration</strong> 注解一起使用，配置类中声明它表示希望在应用程序中使用基于注解的事务管理。</p>
 <div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 声明式事务依赖--&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org. springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div></blockquote>
</li>
</ol>
<h2 id="11-AOP"><a href="#11-AOP" class="headerlink" title="11.AOP"></a>11.AOP</h2><h3 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h3><ul>
<li><strong>AOP</strong>：Aspect Oriented Programming（面向切面编程，面向方法编程），其实就是面对特定方法编程。</li>
<li><strong>场景</strong>：<br>案例部分功能运行较慢，定位执行耗时较长的业务方法，此时需要统计每一个业务方法的执行耗时<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240817212432.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240817212504.png"
                     
                ><ul>
<li>记录操作日志</li>
<li>权限控制</li>
<li>事务管理</li>
</ul>
</li>
<li><strong>优势</strong>：<ul>
<li>代码无侵入</li>
<li>减少重复代码</li>
<li>提高开发效率</li>
<li>维护方便</li>
</ul>
</li>
<li><strong>实现</strong>：<br>动态代理是面向切面编程最主流的实现。而SpringAOP是Spring框架的高级技术，旨在管理Bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程。</li>
</ul>
<h3 id="11-2-快速入门"><a href="#11-2-快速入门" class="headerlink" title="11.2 快速入门"></a>11.2 快速入门</h3><p>统计各个业务层方法执行耗时</p>
<ul>
<li><strong>导入依赖</strong>：在pom.xml中添加AOP依赖<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong>编写AOP依赖</strong>：针对特定的方法根据业务需要进行编程<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeAspect</span> &#123;</span><br><span class="line">  <span class="meta">@Around(&quot;execution(* com.lusy.service.impl.*.*(..))&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">recordTime</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> pjp.proceed(); <span class="comment">// 调用原始方法运行</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    log.info(pjp.getSignature() + <span class="string">&quot;方法执行耗时：&#123;&#125;ms&quot;</span> + (end - start));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p><strong>注意事项</strong>：<br>如果不是在springboot框架中使用AOP，还需要在配置类中添加<code>@EnableAspectJAutoProxy</code>注解开启AOP功能</p>
</blockquote>
</li>
</ul>
<h3 id="11-3-AOP核心概念"><a href="#11-3-AOP核心概念" class="headerlink" title="11.3 AOP核心概念"></a>11.3 AOP核心概念</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240817220556.png"
                     
                ></p>
<h3 id="11-4-通知类型"><a href="#11-4-通知类型" class="headerlink" title="11.4 通知类型"></a>11.4 通知类型</h3><ul>
<li><b><code>@Around</code></b>：环绕通知，此注解标注的通知方法在目标方法前、后都被执行</li>
<li><b><code>@Before</code></b>：前置通知，此注解标注的通知方法在目标方法前被执行</li>
<li><b><code>@After</code></b>：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行</li>
<li><b><code>@AfterReturning</code></b>：返回后通知，此注解标注的通知方法在目标方法正常返回后被执行，有异常不会执行</li>
<li><b><code>@AfterThrowing</code></b>：异常后通知，此注解标注的通知方法在目标方法抛出异常后被执行，正常返回不会执行<blockquote>
<p><strong>注意事项</strong>：</p>
<ul>
<li><b><code>@Around</code></b>环绕通知需要自己调用 <code>ProceedingJoinPoint.proceed()</code>方法来让原始方法执行，其它通知则不需要考虑目标方法执行</li>
<li><b><code>@Around</code></b>环绕通知的返回值，必须指定为Object类型，来接收原始方法的返回值</li>
<li><b><code>@AfterReturning</code></b>和<b><code>@AfterThrowing</code></b>通知，如果需要指定返回值来接收原始方法的返回值或异常对象，可以通过各自的属性值<b><code>returning</code></b>和<b><code>throwing</code></b>来指定接收返回值或异常对象的变量名。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @AfterReturning注解标记返回通知方法</span></span><br><span class="line"><span class="comment">// 在返回通知中获取目标方法返回值分两步：</span></span><br><span class="line"><span class="comment">// 第一步：在@AfterReturning注解中通过returning属性设置一个名称</span></span><br><span class="line"><span class="comment">// 第二步：使用returning属性设置的名称在通知方法中声明一个对应的形参</span></span><br><span class="line"><span class="meta">@AfterReturning(</span></span><br><span class="line"><span class="meta">       value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;,</span></span><br><span class="line"><span class="meta">       returning = &quot;targetMethodReturnValue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterCoreSuccess</span><span class="params">(JoinPoint joinPoint, Object targetMethodReturnValue)</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">&quot;[AOP返回通知] &quot;</span>+methodName+<span class="string">&quot;方法成功结束了，返回值是：&quot;</span> + targetMethodReturnValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @AfterThrowing注解标记异常通知方法</span></span><br><span class="line"><span class="comment">// 在异常通知中获取目标方法抛出的异常分两步：</span></span><br><span class="line"><span class="comment">// 第一步：在@AfterThrowing注解中声明一个throwing属性设定形参名称</span></span><br><span class="line"><span class="comment">// 第二步：使用throwing属性指定的名称在通知方法声明形参，Spring会将目标方法抛出的异常对象从这里传给我们</span></span><br><span class="line"><span class="meta">@AfterThrowing(</span></span><br><span class="line"><span class="meta">        value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;,</span></span><br><span class="line"><span class="meta">        throwing = &quot;targetMethodException&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterCoreException</span><span class="params">(JoinPoint joinPoint, Throwable targetMethodException)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP异常通知] &quot;</span>+methodName+<span class="string">&quot;方法抛异常了，异常类型是：&quot;</span> + targetMethodException.getClass().getName ());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></blockquote>
</li>
</ul>
<h3 id="11-5-Pointcut注解"><a href="#11-5-Pointcut注解" class="headerlink" title="11.5 @Pointcut注解"></a>11.5 @Pointcut注解</h3><p>该注解的作用是将公共的切点表达式抽取出来，需要用到时引用该切点表达式即可。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240817221648.png"
                     
                ></p>
<h3 id="11-6-通知顺序"><a href="#11-6-通知顺序" class="headerlink" title="11.6 通知顺序"></a>11.6 通知顺序</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240817230133.png"
                     
                ></p>
<h3 id="11-7-切入表达式"><a href="#11-7-切入表达式" class="headerlink" title="11.7 切入表达式"></a>11.7 切入表达式</h3><ul>
<li><strong>概念</strong>：描述切入点方法的一种表达式</li>
<li><strong>作用</strong>：主要用来决定项目中的哪些方法需要加入通知</li>
<li><strong>常见形式</strong>：<ul>
<li><b><code>execution(……)</code></b>：根据方法的签名来匹配</li>
<li><b><code>annotation(……)</code></b>：根据注解匹配<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240817230513.png"
                     
                ></li>
</ul>
</li>
</ul>
<h4 id="11-7-1-execution"><a href="#11-7-1-execution" class="headerlink" title="11.7.1 execution"></a>11.7.1 execution</h4><p>execution 主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配，语法为：<br><b><code>execution([访问修饰符] 返回值 [包名.类名.]方法名(方法参数) [throws 异常])</code></b></p>
<ul>
<li>其中方法参数填写的是<font color="red"><strong>参数类型的全类名</strong></font>，简单类型可以直接指定</li>
<li>其中可省略的部分：<ul>
<li><strong>访问修饰符</strong>：可以省略，表示任意访问修饰符（比如：public、protected）</li>
<li><strong>包名.类名</strong>：可以省略，表示任意包名、类名</li>
<li><strong>throws 异常</strong>：可以省略，表示任意异常（注意是方法上声明抛出的异常，不是实际抛出的异常）</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(public void com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>可以使用通配符描述切入点<ul>
<li><b><code>*</code></b>：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">execution(* com.*.service.impl.*.*(*))</span><br></pre></td></tr></table></figure></div>
<ul>
<li><b><code>..</code></b>：多个独立的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数,在通配包时，不能作为开头。如果要指定全部包，可以用<b><code>*..</code></b></li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">execution(* com.itheima..DeptService.*(..))</span><br><span class="line">execution(* com.example.service..*.*(..))</span><br><span class="line">execution(* ..example.service..*.*(..)) <span class="comment">// 错误的</span></span><br><span class="line"><span class="comment">// 查询全部包下，无参数的方法</span></span><br><span class="line">execution(* *..*.*(..)) <span class="comment">//第三个 *：匹配类名中的最后一级，防止出现连续的 ...</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<blockquote>
<p><strong>注意事项</strong>：<br>根据业务需要，可以使用 且(&amp;&amp;) 、或(||)、非(!)来组合比较复杂的切入点表达式。</p>
</blockquote>
<ul>
<li>书写建议<ul>
<li>所有业务<strong>方法名</strong>在<strong>命名</strong>时尽量<strong>规范</strong>，方便切入点表达式快速匹配。如：查询类方法都是find开头，更新类方法都是update开头</li>
<li>描述切入点方法通常<strong>基于接口描述</strong>，而不是直接描述实现类，<strong>增强拓展性</strong></li>
<li>在满足业务需要的前提下，<strong>尽量缩小切入点的匹配范围</strong>。如：包名匹配尽量不使用.. ，使用 * 匹配单个包。</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411171104448.png"
                      alt="image.png|450"
                ></p>
<h4 id="11-7-2-annotation"><a href="#11-7-2-annotation" class="headerlink" title="11.7.2 annotation"></a>11.7.2 annotation</h4><p><code>@annotation</code>注解的切点表达式用于匹配被指定注解标记的方法。例如，如果你有一个自定义注解<code>@MyLog</code>，你可以使用<code>@annotation</code>来指定所有带有<code>@MyLog</code>注解的方法作为切点。</p>
<ul>
<li><strong>示例</strong>：<br>假设你有一个自定义注解<code>@MyLog</code>：<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyLog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
你希望在所有标记了<code>@MyLog</code>的地方记录方法执行时间，可以定义一个切面如下：<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;@annotation(com.example.MyLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logExecutionTime</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="comment">// 在方法执行前记录开始时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Method &quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot; is about to execute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;@annotation(com.example.MyLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterExecution</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="comment">// 在方法执行后记录结束时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Method &quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot; has executed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
使用<code>@MyLog</code>注解:<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyLog</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Task is being performed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="11-8-连接点"><a href="#11-8-连接点" class="headerlink" title="11.8 连接点"></a>11.8 连接点</h3><ul>
<li>在Spring中用<font color="red">JoinPoint</font>抽象了连接点，用它可以获取方法执行时的相关信息，如目标类名，方法名，方法参数等。<ul>
<li>对于<b><code>@Around</code></b>通知，获取连接点信息只能使用 <b><code>ProceedingJoinPoint</code></b><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240817233214.png"
                     
                ></li>
<li>对于其它四种通知，获取连接点信息只能使用 <b><code>JoinPoint</code></b>，它是<b><code>ProceedingJoinPoint</code></b>的父类<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240817233227.png"
                     
                ></li>
</ul>
</li>
</ul>
<h2 id="12-配置"><a href="#12-配置" class="headerlink" title="12.配置"></a>12.配置</h2><ul>
<li>SpringBoot除了支持配置文件属性配置，还支持<strong>Java系统属性</strong>和<strong>命令行参数</strong>的方式进行属性配置。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818184556.png"
                     
                ></li>
<li><strong>优先级(高 -&gt; 低)</strong><ul>
<li>命令行参数 (–xxx&#x3D;xx)</li>
<li>java系统属性（-Dxxx&#x3D;xxx）</li>
<li>application.properties</li>
<li>application.yml</li>
<li>application.yml（忽略）</li>
</ul>
</li>
</ul>
<h2 id="13-Bean的管理"><a href="#13-Bean的管理" class="headerlink" title="13.Bean的管理"></a>13.Bean的管理</h2><h3 id="13-1-获取Bean"><a href="#13-1-获取Bean" class="headerlink" title="13.1 获取Bean"></a>13.1 获取Bean</h3><ul>
<li>默认情况下，Spring项目启动时，会把Bean都创建好放在IOC容器中，如果想要主动获取这些Bean，可以通过如下方式：<ul>
<li><strong>根据name获取Bean</strong>：<code>Object getBean(String name)</code></li>
<li><strong>根据类型获取Bean</strong>：<code>&lt;T&gt; T getBean(Class&lt;T&gt; requireType)</code></li>
<li><strong>根据name获取Bean（带类型转换）</strong>：<code>&lt;T&gt; T getBean(String name, Class&lt;T&gt; requireType)</code><blockquote>
<p><strong>注意事项</strong>：<br>上述所说的【Spring项目启动时，会把其中的Bean都创建好】还会受到作用域及延迟初始化影响，这里主要针对于默认的单例非延迟加载的Bean而言。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="13-2-Bean作用域"><a href="#13-2-Bean作用域" class="headerlink" title="13.2 Bean作用域"></a>13.2 Bean作用域</h3><ul>
<li>Spring支持五种作用域，后三种在web环境下才生效：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818190143.png"
                     
                ></li>
<li>可以通过<b><code>@Scope</code></b>注解来进行配置作用域<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/depts&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p><strong>注意事项</strong>：</p>
<ul>
<li>默认<strong>singleton</strong>的bean，在容器启动时被创建，可以使用<b><code>@Lazy</code></b>注解来延迟初始化（延迟到第一次使用时）</li>
<li>prototype的bean，每一次使用该bean的时候都会创建一个新的实例</li>
<li>实际开发当中，绝大部分的Bean是单例的，也就是说大部分Bean不需要配置<strong>Scope</strong>属性</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="13-3-第三方Bean"><a href="#13-3-第三方Bean" class="headerlink" title="13.3 第三方Bean"></a>13.3 第三方Bean</h3><ul>
<li><b><code>@Bean</code></b><ul>
<li>如果要管理的Bean对象来自第三方（不是自定义的），是无法用<b><code>Component</code></b>及衍生注解声明Bean的，就需要用到<b><code>@Bean</code></b>注解。</li>
<li>若要管理的第三方Bean对象，建议对这些Bean进行分类配置，可以通过 <b><code>@Configuration</code></b>注解来声明一个配置类。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818191744.png"
                     
                ><blockquote>
<p><strong>注意事项</strong>：</p>
<ul>
<li><strong>@Bean</strong>修饰的方法将当前方法的返回值对象交给IOC容器管理，成为IOC容器的Bean</li>
<li>通过<b>@Bean</b>注解的name或value属性可以声明Bean的名称，如果不指定，默认Bean的名称就是方法名。</li>
<li>周期方法指定：<ul>
<li>原有注解方案：@PostConstruct、@PreDestroy 注解指定</li>
<li>bean属性指定：initMethod、destroyMethod 指定</li>
</ul>
</li>
<li>如果第三方Bean需要依赖其它Bean对象，直接在@Bean定义的方法中设置形参即可，容器会根据类型自动装配。如果有多个类型匹配，可以使用形参名等同于对应的Beanid标识即可。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>@Component及衍生注解与@Bean注解使用场景？</strong></p>
<ul>
<li>项目中自定义的，使用@Component及其衍生注解</li>
<li>项目中引入第三方的，使用@Bean注解</li>
</ul>
</blockquote>
<h2 id="14-自动配置原理"><a href="#14-自动配置原理" class="headerlink" title="14.自动配置原理"></a>14.自动配置原理</h2><h3 id="14-1-ComponentScan-组件扫描"><a href="#14-1-ComponentScan-组件扫描" class="headerlink" title="14.1 @ComponentScan 组件扫描"></a>14.1 @ComponentScan 组件扫描</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818193043.png"
                     
                ></p>
<h3 id="14-2-Import导入"><a href="#14-2-Import导入" class="headerlink" title="14.2 @Import导入"></a>14.2 @Import导入</h3><p><strong>@Import</strong>注解将配置类、普通类、第三方的组件注册到 IOC 容器，组件在容器中的名字是全类名</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818193058.png"
                     
                ></p>
<h3 id="14-3-源码跟踪"><a href="#14-3-源码跟踪" class="headerlink" title="14.3 源码跟踪"></a>14.3 源码跟踪</h3><ul>
<li><p><strong>@SpringBootApplication</strong><br>该注解标识在SpringBoot工程引导类上，是SpringBoot中<strong>最重要</strong>的注解。该注解由三个部分组成：</p>
<ul>
<li><strong><code>@SpringBootConfiguration</code></strong>：该注解与<code>@Configuration</code>注解作用相同，用来声明当前也是一个配置类。</li>
<li><strong><code>@ComponentScan</code></strong>：组件扫描，默认扫描当前引导类所在包及其子包。</li>
<li><strong><code>@EnableAutoConfiguration</code></strong>：SpringBoot实现自动化配置的核心注解。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818194105.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818194131.png"
                     
                ></li>
</ul>
</li>
<li><p><strong>@Conditional</strong></p>
<ul>
<li><strong>作用</strong>：按照一定的条件进行判断，在满足给定条件后才会注册对应的Bean对象到Spring IOC容器中。</li>
<li><strong>位置</strong>：方法、类</li>
<li><strong>@Conditional本身是一个父注解，派生出大量的子注解</strong>：<ul>
<li><strong><code>@ConditionalOnClass</code></strong>：判断环境中是否有对应字节码文件，才注册Bean到IOC容器</li>
<li><strong><code>@ConditionalOnMissingBean</code></strong>：判断环境中没有对应的Bean（类型或名称），才注册Bean到IOC容器</li>
<li><strong><code>@ConditionalOnProperty</code></strong>：判断配置文件中有对应属性和值，才注册Bean到IOC容器</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> Gson <span class="title function_">gson</span><span class="params">(GsonBuilder gsonBuilder)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gsonBuilder.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818195303.png"
                     
                ></p>
<h3 id="14-4-自定义starter"><a href="#14-4-自定义starter" class="headerlink" title="14.4 自定义starter"></a>14.4 自定义starter</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818195426.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818195502.png"
                     
                ></p>
<h2 id="15-Maven高级"><a href="#15-Maven高级" class="headerlink" title="15.Maven高级"></a>15.Maven高级</h2><h3 id="15-1-分模块设计"><a href="#15-1-分模块设计" class="headerlink" title="15.1 分模块设计"></a>15.1 分模块设计</h3><ol>
<li><strong>什么是分模块设计？</strong></li>
</ol>
<ul>
<li>将项目按照功能拆分成若干个子模块</li>
</ul>
<ol start="2">
<li><strong>为什么要分模块设计？</strong></li>
</ol>
<ul>
<li>方便项目的管理维护、拓展、也方便模块间的相互调用，资源共享</li>
</ul>
<ol start="3">
<li><strong>注意事项</strong></li>
</ol>
<ul>
<li>分模块设计需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818200210.png"
                     
                ></p>
<h3 id="15-2-继承"><a href="#15-2-继承" class="headerlink" title="15.2 继承"></a>15.2 继承</h3><ul>
<li><strong>概念</strong>：继承描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承</li>
<li><strong>作用</strong>：简化依赖配置、统一管理依赖</li>
<li><strong>实现</strong>：<b><code>&lt;parent&gt;……&lt;/parent&gt;</code></b></li>
<li><strong>具体步骤</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818200958.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818201045.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818201101.png"
                     
                ></li>
<li><strong>总结</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818201356.png"
                     
                ></li>
</ul>
<blockquote>
<p><strong>打包方式</strong>：</p>
<ul>
<li><strong>jar</strong>：普通模块打包，springboot项目基本都是jar包（内嵌tomcat运行）</li>
<li><strong>war</strong>：普通web程序打包，需要部署在外部的tomcat服务器中运行</li>
<li><strong>pom</strong>：父工程或聚合工程，该模块不写代码，仅进行依赖管理</li>
</ul>
</blockquote>
<h3 id="15-3-版本锁定"><a href="#15-3-版本锁定" class="headerlink" title="15.3 版本锁定"></a>15.3 版本锁定</h3><ul>
<li>在maven中，可以在父工程的pom文件中通过<b><code>&lt;dependencyManagement&gt;</code></b>来统一管理依赖版本。</li>
<li><b><code>&lt;dependencyManagement&gt;</code></b> 是用来管理依赖版本的，它用于声明依赖的版本，但这些依赖不会自动导入到项目中，还需要再<b>&lt;dependencies&gt;</b>中引入。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818202248.png"
                     
                ></li>
</ul>
<blockquote><p><strong>注意事项</strong>：</p>
<ul>
<li>子工程引入依赖时，无需指定 <b>&lt;version&gt;</b>版本号，父工程统一管理。变更依赖版本，只需在父工程中统一变更。</li>
</ul>
<p><b>&lt;dependencyManagement&gt;与&lt;dependencies&gt;的区别</b>：</p>
<ul>
<li><b>&lt;dependencies&gt;</b>是直接依赖，在父工程配置了依赖，子工程会直接继承下来。</li>
<li><b>&lt;dependencyManagement&gt;</b>是统一管理依赖版本，不会直接依赖，还需要在子工程中引入所需依赖(无需指定版本)</li>
</ul>
</blockquote>
<ul>
<li>也可以通过<b><code>&lt;properties&gt;</code></b>自定义&#x2F;引用属性。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818202711.png"
                     
                ></li>
</ul>
<h3 id="15-4-聚合"><a href="#15-4-聚合" class="headerlink" title="15.4 聚合"></a>15.4 聚合</h3><ul>
<li><strong>概念</strong>：将多个模块组织成一个整体，同时进行项目的构建。</li>
<li><strong>聚合工程</strong>：一个不具有业务功能的”空”工程（有且仅有一个pom文件）</li>
<li><strong>作用</strong>：快速构建项目（无需根据依赖关系手动构建，直接在聚合工程上构建即可）<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818204310.png"
                     
                ></li>
<li><strong>实例</strong>：聚合使得在父项目中执行 <code>mvn install</code> 等命令时，所有子模块都会被一起构建。</li>
</ul>
<blockquote><p><strong>继承与聚合</strong>：</p>
<ul>
<li><strong>作用</strong><ul>
<li>聚合用于快速构建项目</li>
<li>继承用于简化依赖配置、统一管理依赖</li>
</ul>
</li>
<li><strong>相同点</strong>：<ul>
<li>聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中</li>
<li>聚合与继承均属于设计型模块，并无实际的模块内容</li>
</ul>
</li>
<li><strong>不同点</strong>：<ul>
<li>聚合是在聚合工程中配置关系，聚合可以感知到参与聚合的模块有哪些</li>
<li>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</li>
</ul>
</li>
</ul>
</blockquote>

<h3 id="15-5-私服"><a href="#15-5-私服" class="headerlink" title="15.5 私服"></a>15.5 私服</h3><ul>
<li><strong>概念</strong>: 私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，用来代理位于外部的中央仓库，用于解决团队内部的资源共享与资源同步问题<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818210544.png"
                     
                ></li>
<li><strong>资源上传与下载</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818210623.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818210637.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818210646.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818210705.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240818210714.png"
                     
                ></li>
</ul>
<h3 id="16-Mybatis-的-Mapper-文件什么时候需要使用-Param"><a href="#16-Mybatis-的-Mapper-文件什么时候需要使用-Param" class="headerlink" title="16 Mybatis 的 Mapper 文件什么时候需要使用 @Param"></a>16 Mybatis 的 Mapper 文件什么时候需要使用 @Param</h3><p><code>@Param</code> 注解的主要作用是 <strong>给 MyBatis 传递的参数起别名</strong>，从而在 <code>mapper.xml</code> 里可以正确引用参数。是否需要 <code>@Param</code> 取决于你的方法参数类型和 MyBatis 解析参数的方式。</p>
<hr>
<h4 id="✅-需要-Param-的情况"><a href="#✅-需要-Param-的情况" class="headerlink" title="✅ 需要 @Param 的情况"></a><strong>✅ 需要 <code>@Param</code> 的情况</strong></h4><h5 id="1️⃣-方法参数有多个"><a href="#1️⃣-方法参数有多个" class="headerlink" title="1️⃣ 方法参数有多个"></a><strong>1️⃣ 方法参数有多个</strong></h5><p>如果 <code>Mapper</code> 方法有 <strong>两个或以上参数</strong>，MyBatis <strong>默认不会自动识别参数名</strong>，需要 <code>@Param</code> 指定别名，否则 <code>mapper.xml</code> 无法正确引用：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;DeptVo&gt; <span class="title function_">findDeptByNameAndState</span><span class="params">(<span class="meta">@Param(&quot;deptName&quot;)</span> String deptName, </span></span><br><span class="line"><span class="params">                                    <span class="meta">@Param(&quot;dataState&quot;)</span> String dataState)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findDeptByNameAndState&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from sys_dept</span><br><span class="line">    where dept_name like concat(&#x27;%&#x27;, #&#123;deptName&#125;, &#x27;%&#x27;)</span><br><span class="line">      and data_state = #&#123;dataState&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>❌ 不加 <code>@Param</code> 可能会报错</strong>：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Parameter &#x27;deptName&#x27; not found. Available parameters are [arg0, arg1, param1, param2]</span><br></pre></td></tr></table></figure></div>

<p>因为 MyBatis 默认只给参数分配 <code>param1, param2</code> 这样的名字，XML 里 <code>#&#123;deptName&#125;</code> 找不到对应的参数。</p>
<hr>
<h5 id="2️⃣-、List-或-Collection-作为参数"><a href="#2️⃣-、List-或-Collection-作为参数" class="headerlink" title="2️⃣ [ ]、List 或 Collection 作为参数"></a><strong>2️⃣ <code>[ ]</code>、<code>List</code> 或 <code>Collection</code> 作为参数</strong></h5><p>如果方法参数是 <strong>List 或 Collection</strong>，MyBatis <strong>不会自动赋予参数名</strong>，需要用 <code>@Param</code> 指定别名：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;DeptVo&gt; <span class="title function_">findDeptInDeptNos</span><span class="params">(<span class="meta">@Param(&quot;deptNos&quot;)</span> List&lt;String&gt; deptNos)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findDeptInDeptNos&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from sys_dept where dept_no in </span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;deptNos&quot;</span> <span class="attr">item</span>=<span class="string">&quot;deptNo&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;deptNo&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>❌ 不加 <code>@Param(&quot;deptNos&quot;)</code> 可能会报错</strong>：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">There is no getter for property named &#x27;deptNos&#x27; in class &#x27;java.util.ArrayList&#x27;</span><br></pre></td></tr></table></figure></div>

<p>因为 MyBatis 认为 <code>List</code> 参数没有名字，而 XML 里 <code>collection=&quot;deptNos&quot;</code> 需要一个明确的参数名。</p>
<hr>
<h5 id="3️⃣-需要在-mapper-xml-里使用参数别名"><a href="#3️⃣-需要在-mapper-xml-里使用参数别名" class="headerlink" title="3️⃣ 需要在 mapper.xml 里使用参数别名"></a><strong>3️⃣ 需要在 <code>mapper.xml</code> 里使用参数别名</strong></h5><p>如果你想在 SQL 里更清楚地引用参数，比如：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">DeptVo <span class="title function_">findDeptInfo</span><span class="params">(<span class="meta">@Param(&quot;dept&quot;)</span> DeptDto dept)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findDeptInfo&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from sys_dept </span><br><span class="line">    where dept_no = #&#123;dept.deptNo&#125; </span><br><span class="line">      and dept_name like concat(&#x27;%&#x27;, #&#123;dept.deptName&#125;, &#x27;%&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>如果不加 <code>@Param(&quot;dept&quot;)</code>，在 XML 里就不能用 <code>#&#123;dept.xxx&#125;</code> 来访问 <code>DeptDto</code> 里的属性</strong>。</p>
<hr>
<h4 id="❌-不需要-Param-的情况"><a href="#❌-不需要-Param-的情况" class="headerlink" title="❌ 不需要 @Param 的情况"></a><strong>❌ 不需要 <code>@Param</code> 的情况</strong></h4><h5 id="1️⃣-只有一个基本类型参数"><a href="#1️⃣-只有一个基本类型参数" class="headerlink" title="1️⃣ 只有一个基本类型参数"></a><strong>1️⃣ 只有一个基本类型参数</strong></h5><p>如果方法只有<strong>一个参数</strong>，且是 <strong>基本数据类型或 String</strong>，MyBatis <strong>会自动识别</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">DeptVo <span class="title function_">findDeptByNo</span><span class="params">(String deptNo)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findDeptByNo&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from sys_dept where dept_no = #&#123;deptNo&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>✅ <strong>不需要 <code>@Param</code>，MyBatis 会自动匹配 <code>#&#123;deptNo&#125;</code></strong>。</p>
<hr>
<h5 id="2️⃣-只有一个-JavaBean-或-DTO-作为参数"><a href="#2️⃣-只有一个-JavaBean-或-DTO-作为参数" class="headerlink" title="2️⃣ 只有一个 JavaBean 或 DTO 作为参数"></a><strong>2️⃣ 只有一个 JavaBean 或 DTO 作为参数</strong></h5><p>如果方法只有<strong>一个对象参数</strong>（JavaBean 或 DTO），MyBatis <strong>会自动匹配对象的字段</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">DeptVo <span class="title function_">findDeptByDto</span><span class="params">(DeptDto deptDto)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findDeptByDto&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from sys_dept </span><br><span class="line">    where dept_no = #&#123;deptNo&#125; </span><br><span class="line">      and dept_name like concat(&#x27;%&#x27;, #&#123;deptName&#125;, &#x27;%&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>✅ <strong>MyBatis 会自动解析 <code>DeptDto</code> 里的字段，不需要 <code>@Param</code></strong>。</p>
<hr>
<h5 id="3️⃣-只有一个-List-或-Collection-参数，并且-XML-里用-collection-list"><a href="#3️⃣-只有一个-List-或-Collection-参数，并且-XML-里用-collection-list" class="headerlink" title="3️⃣ 只有一个 List 或 Collection 参数，并且 XML 里用 collection=&quot;list&quot;"></a><strong>3️⃣ 只有一个 <code>List</code> 或 <code>Collection</code> 参数，并且 XML 里用 <code>collection=&quot;list&quot;</code></strong></h5><p>MyBatis <strong>默认把 <code>List</code> 绑定到 <code>list</code></strong>，所以如果 XML 里使用 <code>collection=&quot;list&quot;</code>，也可以不用 <code>@Param</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;DeptVo&gt; <span class="title function_">findDeptInDeptNos</span><span class="params">(List&lt;String&gt; deptNos)</span>;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;deptNo&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">    #&#123;deptNo&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>✅ <strong>可以不加 <code>@Param</code>，因为 MyBatis 默认会把 <code>List</code> 绑定到 <code>list</code> 这个名字</strong>。</p>
<hr>
<h4 id="🚀-总结：什么时候需要-Param？"><a href="#🚀-总结：什么时候需要-Param？" class="headerlink" title="🚀 总结：什么时候需要 @Param？"></a><strong>🚀 总结：什么时候需要 <code>@Param</code>？</strong></h4><table>
<thead>
<tr>
<th>情况</th>
<th>需要 <code>@Param</code></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>多个参数</strong>（基本类型或 String）</td>
<td>✅ 需要</td>
<td>MyBatis 默认不会自动匹配参数名</td>
</tr>
<tr>
<td><strong>只有一个基本类型参数</strong></td>
<td>❌ 不需要</td>
<td>MyBatis 会自动识别</td>
</tr>
<tr>
<td><strong>只有一个 JavaBean 或 DTO 参数</strong></td>
<td>❌ 不需要</td>
<td>MyBatis 会自动匹配字段</td>
</tr>
<tr>
<td><strong><code>List</code> 或 <code>Collection</code> 参数</strong></td>
<td>✅ 需要（除非用 <code>list</code> 作为默认名）</td>
<td>MyBatis 默认不给 <code>List</code> 取名</td>
</tr>
<tr>
<td><strong>想给参数起别名</strong></td>
<td>✅ 需要</td>
<td>方便 XML 里使用更清晰的参数名</td>
</tr>
</tbody></table>
<h5 id="📌-推荐的做法"><a href="#📌-推荐的做法" class="headerlink" title="📌 推荐的做法"></a><strong>📌 推荐的做法</strong></h5><ul>
<li><strong>单个基本类型或 JavaBean 作为参数时</strong>，不用 <code>@Param</code>，MyBatis 能自动解析。</li>
<li><strong>有多个参数时</strong>，一定要用 <code>@Param</code>，否则 MyBatis 只能用 <code>param1, param2</code> 访问参数。</li>
<li><strong><code>List</code> 作为参数时</strong>，最好加 <code>@Param(&quot;xxx&quot;)</code>，否则只能用 <code>collection=&quot;list&quot;</code> 访问。</li>
</ul>
<p>如果你不确定是否需要 <code>@Param</code>，<strong>加上它总是安全的</strong>，但如果只有一个简单参数，可以省略。 🚀</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>xxl-job 使用</title>
    <url>/2024/07/17/XXL-job/</url>
    <content><![CDATA[<p>xxl-job 开源网址： <a class="link"   href="https://gitee.com/xuxueli0323/xxl-job"  title="https:&#x2F;&#x2F;gitee.com&#x2F;xuxueli0323&#x2F;xxl-job">https://gitee.com/xuxueli0323/xxl-job<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="搭建任务调度平台"><a href="#搭建任务调度平台" class="headerlink" title="搭建任务调度平台"></a>搭建任务调度平台</h2><h3 id="1、拉取xxl-job代码"><a href="#1、拉取xxl-job代码" class="headerlink" title="1、拉取xxl-job代码"></a>1、拉取xxl-job代码</h3><p>首先去上述的gitee拉取开源的xxl-job代码，千万不要选择master分支，要选择稳定的版本，这里我选择2.2.0来做演示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202501281201630.png"
                      alt="image-20250128120107325"
                ></p>
<h3 id="2、创建需要的数据库"><a href="#2、创建需要的数据库" class="headerlink" title="2、创建需要的数据库"></a>2、创建需要的数据库</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202501281205779.png"
                      alt="image-20250128120512644"
                ></p>
<p>执行这个sql文件，创建必要的数据库</p>
<h3 id="3、配置yaml文件"><a href="#3、配置yaml文件" class="headerlink" title="3、配置yaml文件"></a>3、配置yaml文件</h3><p>首先去xxl-job-admin找到配置文件，并修改<strong>port</strong>、<strong>mysql</strong>、<strong>mail</strong>、<strong>xxl.job.accessToken</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202501281209984.png"
                      alt="image-20250128120939910"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202501281209792.png"
                      alt="image-20250128120943725"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202501281215586.png"
                      alt="image-20250128121544518"
                ></p>
<ul>
<li><p>server.port 可以修改成 8888，避免与Java项目的端口产生冲突</p>
</li>
<li><p>数据库的地址、用户名、密码修改成自己的</p>
</li>
<li><p>mail.username和mail.password修改成自己的，如果不用qq邮箱，记得mail.host和mail.from也修改一下</p>
</li>
<li><p>accessToken可以理解为秘钥，后面会在你自己的项目中配置和他名字一模一样的秘钥，让你的项目与任务调度器平台互相关联起来。这里我就不做修改了，使用默认的，可以自定义。</p>
</li>
</ul>
<h3 id="4、配置logback-xml"><a href="#4、配置logback-xml" class="headerlink" title="4、配置logback.xml"></a>4、配置logback.xml</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202501281221856.png"
                      alt="image-20250128122100727"
                ></p>
<p>在linux中先创建好自己的路径日志，然后赋予权限，</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建目录和文件</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /data/xxl-job</span><br><span class="line"><span class="built_in">touch</span> /data/xxl-job/xxl-job-admin.log</span><br><span class="line"><span class="comment"># 赋予权限</span></span><br><span class="line"><span class="built_in">chmod</span> -R 777 /data/xxl-job/xxl-job-admin.log</span><br></pre></td></tr></table></figure></div>

<h3 id="5、启动任务调度器"><a href="#5、启动任务调度器" class="headerlink" title="5、启动任务调度器"></a>5、启动任务调度器</h3><p>配置好之后，用idea打包，并将jar在linux中运行。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/6bd59a506cd84d94d9f35a3e0afbead6.png"
                      alt="img"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将jar通过后台进程启动，并将启动信息指向/data/xxl-job/xxl-job-admin.log中  </span></span><br><span class="line"><span class="built_in">nohup</span> java -jar xxl-job-admin-2.4.1-SNAPSHOT.jar &gt; /data/xxl-job/xxl-job-admin.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看日志</span></span><br><span class="line"><span class="built_in">tail</span> -f /data/xxl-job/xxl-job-admin.log</span><br></pre></td></tr></table></figure></div>

<h3 id="6、访问任务调度器"><a href="#6、访问任务调度器" class="headerlink" title="6、访问任务调度器"></a>6、访问任务调度器</h3><p>访问地址：<strong>http:&#x2F;&#x2F;自己的ip:自己设置的端口号&#x2F;xxl-job-admin</strong>  </p>
<p>账号：admin ；密码：123456</p>
<h2 id="sprintboot引入xxl-job"><a href="#sprintboot引入xxl-job" class="headerlink" title="sprintboot引入xxl-job"></a>sprintboot引入xxl-job</h2><h3 id="1、引入xxl-job-core依赖"><a href="#1、引入xxl-job-core依赖" class="headerlink" title="1、引入xxl-job-core依赖"></a>1、引入xxl-job-core依赖</h3><p>在自己的项目中引入xxl-job-core依赖；只需引入这一个依赖就行</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2、配置yaml"><a href="#2、配置yaml" class="headerlink" title="2、配置yaml"></a>2、配置yaml</h3><p>在自己的项目中配置yaml</p>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">xxl:</span></span><br><span class="line">  <span class="attr">job:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="comment"># 调度中心服务部署的地址</span></span><br><span class="line">      <span class="attr">addresses:</span> <span class="string">http://192.168.139.110:8888/xxl-job-admin</span></span><br><span class="line">    <span class="comment"># 执行器通讯TOKEN,要和调度中心服务部署配置的accessToken一致，要不然无法连接注册</span></span><br><span class="line">    <span class="attr">accessToken:</span> <span class="string">default_token</span></span><br><span class="line">    <span class="attr">executor:</span></span><br><span class="line">      <span class="comment"># 执行器AppName</span></span><br><span class="line">      <span class="attr">appname:</span> <span class="string">job-demo</span></span><br><span class="line">      <span class="comment"># 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。</span></span><br><span class="line">      <span class="attr">address:</span></span><br><span class="line">      <span class="attr">ip:</span> <span class="number">192.168</span><span class="number">.139</span><span class="number">.110</span></span><br><span class="line">      <span class="comment">#执行器端口号：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9999</span></span><br><span class="line">      <span class="comment"># 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；</span></span><br><span class="line">      <span class="attr">logpath:</span> <span class="string">/data/xxl-job/xxl-job-admin.log</span></span><br><span class="line">      <span class="comment"># 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；</span></span><br><span class="line">      <span class="attr">logretentiondays:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202501281235847.png"
                      alt="image-20250128123544534"
                ></p>
<p><strong>注意！！！！</strong>： logpath执行日志存储位置，也是需要自己在linux中创建的，和上述任务调度器平台创建一样，创建完成之后，设置权限。 </p>
<h3 id="3、配置日志"><a href="#3、配置日志" class="headerlink" title="3、配置日志"></a>3、配置日志</h3><p>去你拉取的<strong>xxl-job</strong>项目中找到 <strong>logback.xml</strong>,复制到你自己项目的位置，并且创建该文件，赋予权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202501281239932.png"
                      alt="image-20250128123944764"
                ></p>
<h3 id="4、编写配置类"><a href="#4、编写配置类" class="headerlink" title="4、编写配置类"></a>4、编写配置类</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(XxlJobConfig.class);</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessToken;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> logRetentionDays;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对多网卡、容器内部署等情况，可借助 &quot;spring-cloud-commons&quot; 提供的 &quot;InetUtils&quot; 组件灵活定制注册IP；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      1、引入依赖：</span></span><br><span class="line"><span class="comment">     *          &lt;dependency&gt;</span></span><br><span class="line"><span class="comment">     *             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">     *             &lt;artifactId&gt;spring-cloud-commons&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">     *             &lt;version&gt;$&#123;version&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="comment">     *         &lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      2、配置文件，或者容器启动变量</span></span><br><span class="line"><span class="comment">     *          spring.cloud.inetutils.preferred-networks: &#x27;xxx.xxx.xxx.&#x27;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      3、获取IP</span></span><br><span class="line"><span class="comment">     *          String ip_ = inetUtils.findFirstNonLoopbackHostInfo().getIpAddress();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>xxl-job项目中的XxlJobConfig</strong></p>
<p>上述的配置类代码，其实就是这个xxl-job项目中的XxlJobConfig 一模一样。 </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202501281244173.png"
                      alt="image-20250128124447013"
                ></p>
<h3 id="5、编写执行器"><a href="#5、编写执行器" class="headerlink" title="5、编写执行器"></a>5、编写执行器</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * XxlJob开发示例（Bean模式）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 开发步骤：</span></span><br><span class="line"><span class="comment"> *      1、任务开发：在Spring Bean实例中，开发Job方法；</span></span><br><span class="line"><span class="comment"> *      2、注解配置：为Job方法添加注解 &quot;<span class="doctag">@XxlJob</span>(value=&quot;自定义jobhandler名称&quot;, init = &quot;JobHandler初始化方法&quot;, destroy = &quot;JobHandler销毁方法&quot;)&quot;，注解value值对应的是调度中心新建任务的JobHandler属性的值。</span></span><br><span class="line"><span class="comment"> *      3、执行日志：需要通过 &quot;XxlJobHelper.log&quot; 打印执行日志；</span></span><br><span class="line"><span class="comment"> *      4、任务结果：默认任务结果为 &quot;成功&quot; 状态，不需要主动设置；如有诉求，比如设置任务结果为失败，可以通过 &quot;XxlJobHelper.handleFail/handleSuccess&quot; 自主设置任务结果；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xuxueli 2019-12-11 21:52:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SampleXxlJob</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(SampleXxlJob.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、简单任务示例（Bean模式）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(&quot;demoJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        XxlJobHelper.log(<span class="string">&quot;XXL-JOB, Hello World.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            XxlJobHelper.log(<span class="string">&quot;beat at:&quot;</span> + i);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// default success</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、分片广播任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(&quot;shardingJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shardingJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分片参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">        <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line"></span><br><span class="line">        XxlJobHelper.log(<span class="string">&quot;分片参数：当前分片序号 = &#123;&#125;, 总分片数 = &#123;&#125;&quot;</span>, shardIndex, shardTotal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; shardTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == shardIndex) &#123;</span><br><span class="line">                XxlJobHelper.log(<span class="string">&quot;第 &#123;&#125; 片, 命中分片开始处理&quot;</span>, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                XxlJobHelper.log(<span class="string">&quot;第 &#123;&#125; 片, 忽略&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、命令行任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  参数示例：&quot;ls -a&quot; 或者 &quot;pwd&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(&quot;commandJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commandJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> XxlJobHelper.getJobParam();</span><br><span class="line">        <span class="type">int</span> <span class="variable">exitValue</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// valid</span></span><br><span class="line">            <span class="keyword">if</span> (command&lt;mark&gt;<span class="literal">null</span> || command.trim().length()&lt;/mark&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                XxlJobHelper.handleFail(<span class="string">&quot;command empty.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// command split</span></span><br><span class="line">            String[] commandArray = command.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// command process</span></span><br><span class="line">            <span class="type">ProcessBuilder</span> <span class="variable">processBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>();</span><br><span class="line">            processBuilder.command(commandArray);</span><br><span class="line">            processBuilder.redirectErrorStream(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> processBuilder.start();</span><br><span class="line">            <span class="comment">//Process process = Runtime.getRuntime().exec(command);</span></span><br><span class="line"></span><br><span class="line">            <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(process.getInputStream());</span><br><span class="line">            bufferedReader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(bufferedInputStream));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// command log</span></span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                XxlJobHelper.log(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// command exit</span></span><br><span class="line">            process.waitFor();</span><br><span class="line">            exitValue = process.exitValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            XxlJobHelper.log(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bufferedReader != <span class="literal">null</span>) &#123;</span><br><span class="line">                bufferedReader.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exitValue == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// default success</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            XxlJobHelper.handleFail(<span class="string">&quot;command exit value(&quot;</span>+exitValue+<span class="string">&quot;) is failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4、跨平台Http任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  参数示例：</span></span><br><span class="line"><span class="comment">     *  &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *      &#123;</span></span><br><span class="line"><span class="comment">     *          &quot;url&quot;: &quot;http://www.baidu.com&quot;,</span></span><br><span class="line"><span class="comment">     *          &quot;method&quot;: &quot;get&quot;,</span></span><br><span class="line"><span class="comment">     *          &quot;data&quot;: &quot;hello world&quot;</span></span><br><span class="line"><span class="comment">     *      &#125;</span></span><br><span class="line"><span class="comment">     *  &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(&quot;httpJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">httpJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// param</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> XxlJobHelper.getJobParam();</span><br><span class="line">        <span class="keyword">if</span> (param&lt;mark&gt;<span class="literal">null</span> || param.trim().length()&lt;/mark&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            XxlJobHelper.log(<span class="string">&quot;param[&quot;</span>+ param +<span class="string">&quot;] invalid.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            XxlJobHelper.handleFail();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// param parse</span></span><br><span class="line">        String url;</span><br><span class="line">        String method;</span><br><span class="line">        String data;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Map&lt;String, String&gt; paramMap =GsonTool.fromJson(param, Map.class);</span><br><span class="line">            url = paramMap.get(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            method = paramMap.get(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">            data = paramMap.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            XxlJobHelper.log(e);</span><br><span class="line">            XxlJobHelper.handleFail();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// param valid</span></span><br><span class="line">        <span class="keyword">if</span> (url&lt;mark&gt;<span class="literal">null</span> || url.trim().length()&lt;/mark&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            XxlJobHelper.log(<span class="string">&quot;url[&quot;</span>+ url +<span class="string">&quot;] invalid.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            XxlJobHelper.handleFail();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method==<span class="literal">null</span> || !Arrays.asList(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>).contains(method.toUpperCase())) &#123;</span><br><span class="line">            XxlJobHelper.log(<span class="string">&quot;method[&quot;</span>+ method +<span class="string">&quot;] invalid.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            XxlJobHelper.handleFail();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        method = method.toUpperCase();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isPostMethod</span> <span class="operator">=</span> method.equals(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// request</span></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// connection</span></span><br><span class="line">            <span class="type">URL</span> <span class="variable">realUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(url);</span><br><span class="line">            connection = (HttpURLConnection) realUrl.openConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// connection setting</span></span><br><span class="line">            connection.setRequestMethod(method);</span><br><span class="line">            connection.setDoOutput(isPostMethod);</span><br><span class="line">            connection.setDoInput(<span class="literal">true</span>);</span><br><span class="line">            connection.setUseCaches(<span class="literal">false</span>);</span><br><span class="line">            connection.setReadTimeout(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">            connection.setConnectTimeout(<span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line">            connection.setRequestProperty(<span class="string">&quot;connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>);</span><br><span class="line">            connection.setRequestProperty(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">            connection.setRequestProperty(<span class="string">&quot;Accept-Charset&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// do connection</span></span><br><span class="line">            connection.connect();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// data</span></span><br><span class="line">            <span class="keyword">if</span> (isPostMethod &amp;&amp; data!=<span class="literal">null</span> &amp;&amp; data.trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">DataOutputStream</span> <span class="variable">dataOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(connection.getOutputStream());</span><br><span class="line">                dataOutputStream.write(data.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                dataOutputStream.flush();</span><br><span class="line">                dataOutputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// valid StatusCode</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">statusCode</span> <span class="operator">=</span> connection.getResponseCode();</span><br><span class="line">            <span class="keyword">if</span> (statusCode != <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Http Request StatusCode(&quot;</span> + statusCode + <span class="string">&quot;) Invalid.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// result</span></span><br><span class="line">            bufferedReader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(connection.getInputStream(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                result.append(line);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">responseMsg</span> <span class="operator">=</span> result.toString();</span><br><span class="line"></span><br><span class="line">            XxlJobHelper.log(responseMsg);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            XxlJobHelper.log(e);</span><br><span class="line"></span><br><span class="line">            XxlJobHelper.handleFail();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bufferedReader != <span class="literal">null</span>) &#123;</span><br><span class="line">                    bufferedReader.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">                    connection.disconnect();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                XxlJobHelper.log(e2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 5、生命周期任务示例：任务初始化与销毁时，支持自定义相关逻辑；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@XxlJob(value = &quot;demoJobHandler2&quot;, init = &quot;init&quot;, destroy = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoJobHandler2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        XxlJobHelper.log(<span class="string">&quot;XXL-JOB, Hello World.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="6-xxl-job-任务详解"><a href="#6-xxl-job-任务详解" class="headerlink" title="6. xxl-job 任务详解"></a>6. xxl-job 任务详解</h3><h4 id="6-1-执行器"><a href="#6-1-执行器" class="headerlink" title="6.1 执行器"></a>6.1 执行器</h4><p>执行器：任务的绑定的执行器，任务触发调度时将会自动发现注册成功的执行器, 实现任务自动发现功能; </p>
<p>另一方面也可以方便的进行任务分组。每个任务必须绑定一个执行器</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202501281248143.png"
                      alt="image-20210729232926534"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="E:\BaiduNetdiskDownload\2024zzyl\day03-基础数据开发-预约管理\讲义\assets\image-20210729232825564.png"
                      alt="image-20210729232825564"
                ></p>
<p> 以下是执行器的属性说明：</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AppName</td>
<td>是每个执行器集群的唯一标示AppName, 执行器会周期性以AppName为对象进行自动注册。可通过该配置自动发现注册成功的执行器, 供任务调度时使用;</td>
</tr>
<tr>
<td>名称</td>
<td>执行器的名称, 因为AppName限制字母数字等组成,可读性不强, 名称为了提高执行器的可读性;</td>
</tr>
<tr>
<td>排序</td>
<td>执行器的排序, 系统中需要执行器的地方,如任务新增, 将会按照该排序读取可用的执行器列表;</td>
</tr>
<tr>
<td>注册方式</td>
<td>调度中心获取执行器地址的方式；</td>
</tr>
<tr>
<td>机器地址</td>
<td>注册方式为”手动录入”时有效，支持人工维护执行器的地址信息；</td>
</tr>
</tbody></table>
<p>自动注册和手动注册的区别和配置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202501281248178.png"
                      alt="image-20210729233016355"
                ></p>
<h4 id="6-2-基础配置"><a href="#6-2-基础配置" class="headerlink" title="6.2 基础配置"></a>6.2 基础配置</h4><p>在我们新建任务的时候，里面有很多的配置项，下面我们就来介绍下里面具体的作用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="E:\BaiduNetdiskDownload\2024zzyl\day03-基础数据开发-预约管理\讲义\assets\image-20210729233926457.png"
                      alt="image-20210729233926457"
                ></p>
<p><strong>基础配置</strong></p>
<ul>
<li><p>执行器：每个任务必须绑定一个执行器, 方便给任务进行分组</p>
</li>
<li><p>任务描述：任务的描述信息，便于任务管理；</p>
</li>
<li><p>负责人：任务的负责人；</p>
</li>
<li><p>报警邮件：任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202501281248195.png"
                      alt="image-20210729234009010"
                ></p>
<p><strong>调度配置</strong></p>
<ul>
<li>调度类型：<ul>
<li>无：该类型不会主动触发调度；</li>
<li>CRON：该类型将会通过CRON，触发任务调度；</li>
<li>固定速度：该类型将会以固定速度，触发任务调度；按照固定的间隔时间，周期性触发；</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="E:\BaiduNetdiskDownload\2024zzyl\day03-基础数据开发-预约管理\讲义\assets\image-20210729234114283.png"
                      alt="image-20210729234114283"
                ></p>
<p><strong>任务配置</strong></p>
<ul>
<li><p>运行模式：</p>
<p>  BEAN模式：任务以JobHandler方式维护在执行器端；需要结合 “JobHandler” 属性匹配执行器中任务；</p>
</li>
<li><p>JobHandler：运行模式为 “BEAN模式” 时生效，对应执行器中新开发的JobHandler类“@JobHandler”注解自定义的value值；</p>
</li>
<li><p>执行参数：任务执行所需的参数；</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202501281248041.png"
                      alt="image-20210729234219162"
                ></p>
<p><strong>阻塞处理策略</strong></p>
<p>阻塞处理策略：调度过于密集执行器来不及处理时的处理策略；</p>
<ul>
<li><p>单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO(First Input First Output)队列并以串行方式运行；</p>
</li>
<li><p>丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；</p>
</li>
<li><p>覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="E:\BaiduNetdiskDownload\2024zzyl\day03-基础数据开发-预约管理\讲义\assets\image-20210729234256062.png"
                      alt="image-20210729234256062"
                ></p>
<p><strong>路由策略</strong></p>
<p>当执行器集群部署时，提供丰富的路由策略，包括；</p>
<ul>
<li><p>FIRST（第一个）：固定选择第一个机器；</p>
</li>
<li><p>LAST（最后一个）：固定选择最后一个机器；</p>
</li>
<li><p><strong>ROUND（轮询）</strong></p>
</li>
<li><p>RANDOM（随机）：随机选择在线的机器；</p>
</li>
<li><p>CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。</p>
</li>
<li><p>LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；</p>
</li>
<li><p>LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举；</p>
</li>
<li><p>FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；</p>
</li>
<li><p>BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；</p>
</li>
<li><p><strong>SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</strong></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="E:\BaiduNetdiskDownload\2024zzyl\day03-基础数据开发-预约管理\讲义\assets\image-20210729234409132.png"
                      alt="image-20210729234409132"
                ></p>
<h3 id="7-xxl-job-案例"><a href="#7-xxl-job-案例" class="headerlink" title="7 xxl-job 案例"></a>7 xxl-job 案例</h3><h4 id="7-1-轮询"><a href="#7-1-轮询" class="headerlink" title="7.1 轮询"></a>7.1 轮询</h4><p>1.修改任务为轮询</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202501281248212.png"
                      alt="image-20210729234513775"
                ></p>
<p>2.启动多个微服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202501281248253.png"
                      alt="image-20210729234536483"
                ></p>
<p>修改yml配置文件</p>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="string">$&#123;port:8881&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">xxl:</span></span><br><span class="line">  <span class="attr">job:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="attr">addresses:</span> <span class="string">http://192.168.200.146:8888/xxl-job-admin</span></span><br><span class="line">    <span class="attr">executor:</span></span><br><span class="line">      <span class="attr">appname:</span> <span class="string">xxl-job-executor-sample</span></span><br><span class="line">      <span class="attr">port:</span> <span class="string">$&#123;executor.port:9999&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>3.启动多个微服务</p>
<p>每个微服务轮询的去执行任务</p>
<h4 id="7-2-分片广播"><a href="#7-2-分片广播" class="headerlink" title="7.2 分片广播"></a>7.2 分片广播</h4><p>执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202501281248300.png"
                      alt="image-20210729234756221"
                ></p>
<p>执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202501281248936.png"
                      alt="image-20210729234822935"
                ></p>
<p><strong>具体案例</strong></p>
<p>需求：让两个节点同时执行10000个任务，每个节点分别执行5000个任务</p>
<p>①：在xxl-job-executor-sample执行器下新创建任务，路由策略为分片广播</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202501281248934.png"
                      alt="image-20210729234948571"
                ></p>
<p>②：分片广播代码</p>
<p>   分片参数</p>
<pre><code> index：当前分片序号(从0开始)，执行器集群列表中当前执行器的序号；

 total：总分片数，执行器集群的总机器数量；
</code></pre>
<p>代码</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.xxljob.job;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.context.XxlJobHelper;</span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.handler.annotation.XxlJob;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJob</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@XxlJob(&quot;demoJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">helloJob</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;简单任务执行了。。。。&quot;</span>+port);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XxlJob(&quot;shardingJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shardingJobHandler</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//分片的参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">        <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//业务逻辑</span></span><br><span class="line">        List&lt;Integer&gt; list = getList();</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            <span class="keyword">if</span>(integer % shardTotal == shardIndex)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前第&quot;</span>+shardIndex+<span class="string">&quot;分片执行了，任务项为：&quot;</span>+integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getList</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>④：测试</p>
<p>启动多个微服务测试，一次执行可以执行多个任务</p>
]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>工具集</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础</title>
    <url>/2024/08/05/MySQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="SQL基本命令"><a href="#SQL基本命令" class="headerlink" title="SQL基本命令"></a>SQL基本命令</h1><h2 id="启动与连接"><a href="#启动与连接" class="headerlink" title="启动与连接"></a>启动与连接</h2><ul>
<li><p>MySQL启动</p>
<p>启动MySQL：<code>net start mysql</code></p>
<p>停止MySQL：<code>net stop mysql</code></p>
<blockquote>
<p>这里的<code>mysql</code>是服务的名称，每个人可以自定义，初始化的名称是<code>mysql80</code></p>
</blockquote>
</li>
<li><p>MySQL客户端连接</p>
<p>MySQL自带的客户端命令行</p>
<p><code>mysql -u username -p [-h hostname] [-P port]</code></p>
<blockquote>
<p>-u username：用于指定用户名，比如：-u root</p>
<p>-p：用于提示输入密码</p>
<p>-h hostname：用于指定MySQL服务器的主机名或IP地址的选项，默认是<code>localhost</code></p>
<p>-P port：指定MySQL服务器的端口号，默认端口号是<code>3306</code></p>
</blockquote>
</li>
</ul>
<h2 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h2><ol>
<li>SQL语句可以单行或多行书写，<strong>以分号结尾</strong></li>
<li>SQL语句可以使用空格&#x2F;缩进来增强语句的可读性</li>
<li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写</li>
<li>注释：<ul>
<li>单行注释：– 注释内容 或 # 注释内容(MySQL特有)</li>
<li>多行注释：&#x2F;* 注释内容 *&#x2F;</li>
</ul>
</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>数值类型</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小(byte)</th>
<th>有符号(SIGNED)范围</th>
<th>无符号(UNSIGNED)范围</th>
<th>描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>tinyint</code></td>
<td>1</td>
<td>(-128，127)</td>
<td>(0，255)</td>
<td>小整数值</td>
<td align="left"></td>
</tr>
<tr>
<td>smallint</td>
<td>2</td>
<td>(-32768，32767)</td>
<td>(0，65535)</td>
<td>大整数值</td>
<td align="left"></td>
</tr>
<tr>
<td>mediumint</td>
<td>3</td>
<td>(-8388608，8388607)</td>
<td>(0，16777215)</td>
<td>大整数值</td>
<td align="left"></td>
</tr>
<tr>
<td><code>int</code></td>
<td>4</td>
<td>(-2147483648，2147483647)</td>
<td>(0，4294967295)</td>
<td>大整数值</td>
<td align="left"></td>
</tr>
<tr>
<td><code>bigint</code></td>
<td>8</td>
<td>(-2^63，2^63-1)</td>
<td>(0，2^64-1)</td>
<td>极大整数值</td>
<td align="left"></td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>(-3.402823466 E+38，3.402823466351  E+38)</td>
<td>0 和 (1.175494351  E-38，3.402823466 E+38)</td>
<td>单精度浮点数值</td>
<td align="left">float(5,2)：5表示整个数字长度，2  表示小数位个数</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>(-1.7976931348623157 E+308，1.7976931348623157 E+308)</td>
<td>0 和  (2.2250738585072014 E-308，1.7976931348623157 E+308)</td>
<td>双精度浮点数值</td>
<td align="left">double(5,2)：5表示整个数字长度，2  表示小数位个数</td>
</tr>
<tr>
<td><code>decimal</code></td>
<td></td>
<td></td>
<td></td>
<td>小数值(精度更高)</td>
<td align="left">decimal(5,2)：5表示整个数字长度，2  表示小数位个数</td>
</tr>
</tbody></table>
<ul>
<li>字符串类型</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>char</code></td>
<td>0-255 bytes</td>
<td>定长字符串</td>
<td>char(10): 最多只能存10个字符,不足10个字符,占用10个字符空间【性能高，浪费空间】</td>
</tr>
<tr>
<td><code>varchar</code></td>
<td>0-65535 bytes</td>
<td>变长字符串</td>
<td>varchar(10): 最多只能存10个字符,不足10个字符, 按照实际长度存储【性能低，节省空间】（实际上还会在数据库中单独开辟一个字符的空间，记录实际长度）</td>
</tr>
<tr>
<td>tinyblob</td>
<td>0-255 bytes</td>
<td>不超过255个字符的二进制数据</td>
<td></td>
</tr>
<tr>
<td>tinytext</td>
<td>0-255 bytes</td>
<td>短文本字符串</td>
<td></td>
</tr>
<tr>
<td>blob</td>
<td>0-65535 bytes</td>
<td>二进制形式的长文本数据</td>
<td></td>
</tr>
<tr>
<td>text</td>
<td>0-65535 bytes</td>
<td>长文本数据</td>
<td></td>
</tr>
<tr>
<td>mediumblob</td>
<td>0-16777215 bytes</td>
<td>二进制形式的中等长度文本数据</td>
<td></td>
</tr>
<tr>
<td>mediumtext</td>
<td>0-16777215 bytes</td>
<td>中等长度文本数据</td>
<td></td>
</tr>
<tr>
<td>longblob</td>
<td>0-4294967295 bytes</td>
<td>二进制形式的极大文本数据</td>
<td></td>
</tr>
<tr>
<td>longtext</td>
<td>0-4294967295 bytes</td>
<td>极大文本数据</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>日期时间类型</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小(byte)</th>
<th>范围</th>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>date</code></td>
<td>3</td>
<td>1000-01-01 至  9999-12-31</td>
<td>YYYY-MM-DD</td>
<td>日期值</td>
</tr>
<tr>
<td>time</td>
<td>3</td>
<td>-838:59:59 至  838:59:59</td>
<td>HH:MM:SS</td>
<td>时间值或持续时间</td>
</tr>
<tr>
<td>year</td>
<td>1</td>
<td>1901 至 2155</td>
<td>YYYY</td>
<td>年份值</td>
</tr>
<tr>
<td><code>datetime</code></td>
<td>8</td>
<td>1000-01-01 00:00:00 至 9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值</td>
</tr>
<tr>
<td>timestamp</td>
<td>4</td>
<td>1970-01-01 00:00:01 至 2038-01-19 03:14:07</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值，时间戳</td>
</tr>
</tbody></table>
<h2 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL(数据定义语言)"></a>DDL(数据定义语言)</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><ul>
<li><p>创建</p>
<ul>
<li>创建数据库：<code>create database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序规则]</code></li>
</ul>
<blockquote>
<p>在 MySQL 中，当你使用特殊符号、关键字或空格来命名数据库时，需要使用反引号 &#96; 符号括起来，而不是单引号。单引号通常用于字符串值，而反引号用于标识数据库对象名称。</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> `数据库名`;</span><br></pre></td></tr></table></figure></div></blockquote>
</li>
<li><p>使用</p>
<ul>
<li>使用数据库：<code>use 数据库名</code></li>
</ul>
</li>
<li><p>查询</p>
<ul>
<li><p>查询所有数据库：<code>show databases</code></p>
</li>
<li><p>查询当前数据库：<code>select database()</code></p>
</li>
</ul>
</li>
<li><p>修改数据库编码</p>
<ul>
<li>修改某个数据库字符编码：<code>alter database 数据库名 character set / charset 字符编码</code></li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> database mydb1 <span class="keyword">character set</span> utf8</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>修改数据库 mydb1 的编码为 utf8。注意，在 MySQL 中所有的 UTF-8 编码都<br>不能使用中间的<code>&quot;-&quot;</code>，即 UTF-8 要书写为 UTF8。</p>
<p><strong>注意</strong>：数据库的字符集不建议设置为utf8，因为这里的utf8只能是3个字节的，而数据库中存在一些数据是4个字节的，最好设置为<code>utf8mb4</code></p>
</blockquote>
</li>
<li><p>删除</p>
<ul>
<li>删除数据库：<code>drop database [ if exists ] 数据库名</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>上述语法中的<code>database</code>，也可以替换成 <code>schema</code>，如：<code>create schema db01;</code></p>
</blockquote>
<h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><ul>
<li><p>创建</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名(</span><br><span class="line">    字段<span class="number">1</span> 字段类型 [约束] [comment 字段<span class="number">1</span>注释],</span><br><span class="line">    ……</span><br><span class="line">    字段n 字段类型 [约束] [comment 字段n注释]</span><br><span class="line">)[comment 表标注];</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>查询</p>
<ul>
<li>查询当前数据库所有表：<code>show tables</code></li>
<li>查询表结构：<code>desc 表名</code></li>
<li>查询创建表的SQL语句：<code>show create table 表名</code></li>
</ul>
</li>
<li><p>修改</p>
<ul>
<li>添加字段：<code>alter table 表名 add 字段名 数据类型 [comment 注释]</code></li>
<li>修改字段的数据类型：<code>alter table 表名 modify 字段名 新数据类型 [约束] [comment 新字段注释]</code> <strong>【字段的约束和注释并不会被继承下来】</strong></li>
<li>修改字段名和数据类型：<code>alter table 表名 change 旧字段名 新字段名 新数据类型 [约束] [comment 新字段注释]</code><strong>【旧字段的约束和注释并不会被继承下来】</strong></li>
<li>删除字段：<code>alter table 表名 drop column 字段名</code></li>
<li>修改表名：<code>rename table 表名 to 新表名</code></li>
</ul>
<blockquote>
<p>在修改字段名或数据类型的时候，若表中已经存在数据，修改成不能兼容原先数据的数据类型的话会报错。因此，在修改字段的数据类型时，你需要考虑到已有数据的情况，并确保新的数据类型与现有数据兼容。如果需要更改数据类型，最好先对现有数据进行备份或转换，然后再进行数据类型修改。</p>
</blockquote>
</li>
<li><p>删除</p>
<ul>
<li>删除表：<code>drop table [ if exists ] 表名</code><strong>【在删除表时，表中的全部数据也会被删除】</strong></li>
<li>删除并重建该表：<code>truncate table 表名</code></li>
</ul>
</li>
</ul>
<h2 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML(数据操作语言)"></a>DML(数据操作语言)</h2><h3 id="插入数据-INSERT"><a href="#插入数据-INSERT" class="headerlink" title="插入数据(INSERT)"></a>插入数据(INSERT)</h3><ul>
<li>指定字段添加数据：<code>insert into 表名 (字段名1，字段名2……) values (值1，值2……)</code></li>
<li>全部字段添加数据：<code>insert into 表名 values (值1，值2……)</code></li>
<li>批量添加数据( 指定字段 )：<code>insert into 表名 (字段名1，字段名2……) values (值1，值2……)，(值1，值2……)</code></li>
<li>批量添加数据( 全部字段 )：<code>insert into 表名 values (值1，值2……)，(值1，值2……)</code></li>
</ul>
<blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li>插入数据时，指定的字段顺序需要与值的顺序一一对应。</li>
<li>字符串和日期型数据应该包含在引号中。</li>
<li>插入的数据大小，应该在字段的规定范围内。</li>
</ol>
</blockquote>
<h3 id="修改数据-UPDATE"><a href="#修改数据-UPDATE" class="headerlink" title="修改数据(UPDATE)"></a>修改数据(UPDATE)</h3><ul>
<li>修改数据：<code>update 表名 set 字段名1 = 值1，字段名2 = 值2，…  [where 条件]</code></li>
</ul>
<blockquote>
<p><strong>注意事项：</strong><br>修改语句的条件可以有，也可以没有。如果没有条件，则会修改整张表的所有数据。</p>
</blockquote>
<h3 id="删除数据-DELETE"><a href="#删除数据-DELETE" class="headerlink" title="删除数据(DELETE)"></a>删除数据(DELETE)</h3><ul>
<li>删除数据：<code>delete from 表名 [where 条件]</code></li>
</ul>
<blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li>delete语句的条件可以有，也可以没有。如果没有条件，则会删除整张表的所有数据。</li>
<li>delete语句不能删除某一个字段的值（如果要操作，可以使用UPDATE，将该字段的值设置为NULL）</li>
</ol>
</blockquote>
<h2 id="DQL-数据查询语言"><a href="#DQL-数据查询语言" class="headerlink" title="DQL(数据查询语言)"></a>DQL(数据查询语言)</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>将一列数据作为一个整体，进行纵向计算。</p>
<p>常见聚合函数</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">count</td>
<td>统计数量</td>
</tr>
<tr>
<td align="left">max</td>
<td>最大值</td>
</tr>
<tr>
<td align="left">min</td>
<td>最小值</td>
</tr>
<tr>
<td align="left">avg</td>
<td>平均值</td>
</tr>
<tr>
<td align="left">sum</td>
<td>求和</td>
</tr>
</tbody></table>
<p>语法：<br>	<code>select 聚合函数(字段列表) from 表名;</code><br><strong>【注意：null值不参与所有聚合函数运算】</strong></p>
<h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>语法：<br>	<code>select 字段列表 from 表名 where 条件列表;</code></p>
<p>条件：</p>
<table>
<thead>
<tr>
<th>比较运算符</th>
<th>功能</th>
<th>逻辑运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;，&gt;&#x3D;，&lt;，&lt;&#x3D;，&#x3D;</td>
<td>大于、小于、等于</td>
<td>and 或 &amp;&amp;</td>
<td>并且(多条件同时成立)</td>
</tr>
<tr>
<td>&lt;&gt; 或 !&#x3D;</td>
<td>不等于</td>
<td>or 或 ||</td>
<td>或者(多条件成立一个)</td>
</tr>
<tr>
<td>between…and…</td>
<td>在某个范围之内(闭区间)</td>
<td>not 或 !</td>
<td>非，不是</td>
</tr>
<tr>
<td>in(…，…)</td>
<td>在in之后的列表中的值，多选一</td>
<td></td>
<td></td>
</tr>
<tr>
<td>like ‘占位符’</td>
<td>模糊匹配( _匹配单个字符，%匹配任意个字符)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>is null &#x2F; is not null</td>
<td>是null &#x2F; 不是null</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p>语法：<br>	<code>select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后的过滤条件]</code></p>
<blockquote>
<p>where 与 having 区别：</p>
<ul>
<li>执行时机不同：where是分组之前进行过滤，不满足where条件的不参与分组；<br>         而having是分组之后对结果进行过滤。</li>
<li>判断条件不同：where不能对聚合函数进行判断，而having可以在后面跟上聚合函数进行判断</li>
</ul>
<p><strong>注意：</strong><br>1.执行顺序：where &gt; 聚合函数 &gt; having<br>2.分组之后，查询的字段一般为聚合函数和分组字段，查询其它字段无任何意义</p>
</blockquote>
<h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p>语法：<br>	<code>select 字段列表 from 表名 order by (字段1 排序方式1，字段2 排序方式2)</code></p>
<p>排序方式：<br>	<code>asc</code>：升序(默认值)<br>	<code>desc</code>：降序</p>
<p>排序类型：<br>	1.<strong>数字排序</strong>：对数值类型的数据进行升序或降序排序<br>	2.<strong>字符串排序</strong>：对字符类型的数据进行字典序的升序或降序排序<br>	3.<strong>日期排序</strong>：对日期和时间类型的数据进行升序或降序排序<br>	4.<strong>布尔值排序</strong>：对布尔类型的数据进行升序或降序排序（<code>false</code>被认为小于<code>true</code>）</p>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。</li>
<li>当排序字段值相同时，默认情况下MySQL会按照记录在表中的物理存储顺序返回结果。</li>
</ul>
</blockquote>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>语法：<br>	<code>select 字段列表 from 表名 limit 起始索引，查询记录数</code></p>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>起始索引从 0 开始，起始索引 &#x3D; （查询页码 - 1）* 每页显示的记录数</li>
<li>分页查询是数据库的方言。不同的数据库有不同的实现，MySQL中是 limit</li>
<li>如果查询的是第一页，起始索引可以省略，直接简写为 limit 10</li>
</ul>
</blockquote>
<h2 id="DCL-数据控制语言"><a href="#DCL-数据控制语言" class="headerlink" title="DCL(数据控制语言)"></a>DCL(数据控制语言)</h2><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><ol>
<li><p>查询用户</p>
<ul>
<li><code>select user ，host from mysql.user;</code></li>
</ul>
</li>
<li><p>创建用户</p>
<ul>
<li><code>create user &#39;用户名&#39;@&#39;主机名&#39; identified by &#39;密码&#39;;</code></li>
</ul>
</li>
<li><p>修改用户密码</p>
<ul>
<li><code>alter user &#39;用户名&#39;@&#39;主机名&#39; identified with mysql_native_password by &#39;新密码&#39;;</code></li>
</ul>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>在MySQL 5.7及之前版本中，<code>WITH mysql_native_password</code> 可以省略，系统会默认使用 <code>mysql_native_password</code> 插件。</li>
<li>在MySQL 8.0及以上版本中，省略 <code>WITH mysql_native_password</code> 时，系统会默认使用 <code>caching_sha2_password</code> 插件。如果希望使用 <code>mysql_native_password</code> 插件，则需要显式指定。</li>
</ul>
</blockquote>
</li>
<li><p>删除用户</p>
<ul>
<li><code>drop user &#39;用户名&#39;@&#39;主机名&#39;;</code></li>
</ul>
</li>
</ol>
<h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><ol>
<li>查询权限<ul>
<li><code>show grants for &#39;用户名&#39;@&#39;主机名&#39;;</code></li>
</ul>
</li>
<li>授予权限<ul>
<li><code>grant 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></li>
</ul>
</li>
<li>撤销权限<ul>
<li><code>revoke 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></li>
</ul>
</li>
</ol>
<h3 id="常用权限"><a href="#常用权限" class="headerlink" title="常用权限"></a>常用权限</h3><table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ALL、ALL PRIVILEGES</td>
<td>所有权限</td>
</tr>
<tr>
<td>SELECT</td>
<td>查询数据</td>
</tr>
<tr>
<td>INSERT</td>
<td>插入数据</td>
</tr>
<tr>
<td>UPDATE</td>
<td>修改数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除数据</td>
</tr>
<tr>
<td>ALTER</td>
<td>修改表</td>
</tr>
<tr>
<td>DROP</td>
<td>删除数据库&#x2F;表&#x2F;视图</td>
</tr>
<tr>
<td>CREATE</td>
<td>创建数据库&#x2F;表</td>
</tr>
</tbody></table>
<h2 id="SQL关键字的编写顺序"><a href="#SQL关键字的编写顺序" class="headerlink" title="SQL关键字的编写顺序"></a>SQL关键字的编写顺序</h2><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	字段列表</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	表名列表</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">	条件列表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">	分组字段列表</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">	分组后条件列表</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">	排序字段列表</span><br><span class="line">limit </span><br><span class="line">	分页参数</span><br></pre></td></tr></table></figure></div>

<h2 id="SQL关键字的执行优先级"><a href="#SQL关键字的执行优先级" class="headerlink" title="SQL关键字的执行优先级"></a>SQL关键字的执行优先级</h2><p>在 SQL 查询中，不同的子句按照特定的顺序执行：</p>
<ol>
<li><p><strong>FROM</strong>: 确定查询的数据来源，通常是表或子查询。</p>
</li>
<li><p><strong>JOIN</strong>: 如果存在 JOIN，在此阶段将多个表连接成一个结果集，这是基于 ON 或 USING 子句中指定的条件。</p>
</li>
<li><p><strong>ON&#x2F;USING</strong>: 这是 JOIN 操作的一部分，用于定义表之间连接的条件。</p>
</li>
<li><p><strong>WHERE</strong>: 根据 WHERE 子句的条件过滤记录，只有满足条件的记录才会被保留。</p>
</li>
<li><p><strong>GROUP BY</strong>: 将结果集按照一个或多个列进行分组。</p>
</li>
<li><p><strong>HAVING</strong>: 过滤分组后的结果，只有满足 HAVING 条件的分组才会被包含在最终结果中。</p>
</li>
<li><p><strong>SELECT</strong>: 选择最终输出的列或计算表达式。注意，SELECT 通常在逻辑上认为是在 FROM 和 WHERE 之后，但在实际的查询执行计划中，它通常与 DISTINCT 和 ORDER BY 一起考虑。</p>
</li>
<li><p><strong>DISTINCT</strong>: 如果存在，DISTINCT 会在所有行被处理之后，SELECT 之前，去除结果集中的重复行。</p>
</li>
<li><p><strong>ORDER BY</strong>: 将结果集按照一个或多个列进行排序。</p>
</li>
<li><p><strong>LIMIT</strong>: 在某些数据库系统中（如 MySQL），LIMIT 用于限制结果集的行数。在其他数据库系统中（如 SQL Server），可能使用 TOP 或 ROWNUM 等其他子句来实现类似的功能。</p>
</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>函数</strong> 是指一段可以直接被另一段程序直接调用的程序或代码</p>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>concat(S<del>1</del>， S<del>2</del>，…，S<del>n</del>)</td>
<td>字符串拼接，将S<del>1</del>， S<del>2</del>，…，S<del>n</del>拼接成一个字符串</td>
</tr>
<tr>
<td>lower(str)</td>
<td>将字符串str全部转为小写</td>
</tr>
<tr>
<td>upper(str)</td>
<td>将字符串str全部转为大写</td>
</tr>
<tr>
<td>lpad(str，n，pad)</td>
<td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td>rpad(str，n，pad)</td>
<td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td>trim(str)</td>
<td>去掉字符串头部和尾部的空格</td>
</tr>
<tr>
<td>substring(str，start，len)</td>
<td>返回字符串str从start位置起的len长度的字符串【<strong>MySQL的起始索引是1，不是0</strong>】</td>
</tr>
</tbody></table>
<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>ceil(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>floor(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>mod(x,y)</td>
<td>返回x&#x2F;y的模</td>
</tr>
<tr>
<td>rand()</td>
<td>返回0~1内的随机小数</td>
</tr>
<tr>
<td>round(x,y)</td>
<td>求参数x的四舍五入的值，保留y位小数</td>
</tr>
</tbody></table>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>curdate()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>curtime()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>now()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>year(date)</td>
<td>获取指定date的年份</td>
</tr>
<tr>
<td>month(date)</td>
<td>获取指定date的月份</td>
</tr>
<tr>
<td>day(date)</td>
<td>获取指定date的日期</td>
</tr>
<tr>
<td>date_add(date，interval expr type)</td>
<td>返回一个日期&#x2F;时间值增加上一个时间间隔expr后的时间值</td>
</tr>
<tr>
<td>datediff(date1，date2)</td>
<td>返回起始时间date1和结束时间date2之间的天数 <strong>【date1 - date2】</strong></td>
</tr>
</tbody></table>
<p>eg：<br>	<code>SELECT DATE_ADD(&#39;2024-07-26&#39;, INTERVAL 10 DAY) AS new_date;</code><br>类似day的时间单位还有：</p>
<ul>
<li><code>second</code>：秒                                  </li>
<li><code>minute</code>：分钟</li>
<li><code>hour</code>：小时</li>
<li><code>week</code>：周</li>
<li><code>month</code>：月</li>
<li><code>year</code>：年</li>
<li><code>quarter</code>：季度</li>
<li><code>microsecond</code>：微秒</li>
</ul>
<h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><p>可以在SQL语句中实现条件筛选，从而提高语句的效率。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>if(value，t，f)</td>
<td>如果value为true，则返回 t，否则返回 f</td>
</tr>
<tr>
<td>ifnull(value1，value2)</td>
<td>如果value1部位空，返回value1，否则返回value2</td>
</tr>
<tr>
<td>case when [val1] then [res1] … else [default] end</td>
<td>如果val1为true，返回res1，…否则返回default默认值</td>
</tr>
<tr>
<td>case [expr] when [val1] then [res1] … else [default] end</td>
<td>如果expr的值等于val1，返回res1，…否则返回default默认值</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>不带表达式的case语句可以使用比较运算符等，适用于更灵活的条件判断。</li>
<li>带表达式的case语句不可以使用比较运算符，只能用于具体值匹配。</li>
</ul>
</blockquote>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul>
<li>概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。</li>
<li>目的：保证数据库的正确性、有效性和完整性。</li>
</ul>
<table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>非空约束</td>
<td>限制该字段值不能为null</td>
<td><code>not null</code></td>
</tr>
<tr>
<td>唯一约束</td>
<td>保证字段的所有数据都是唯一、不重复的</td>
<td><code>unique</code></td>
</tr>
<tr>
<td>主键约束</td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td><code>primary key</code>(常搭配<code>auto_increment</code>)</td>
</tr>
<tr>
<td>默认约束</td>
<td>保存数据时，如果未指定该字段值，则采用默认值(默认值可以用引号括起来)</td>
<td><code>default</code></td>
</tr>
<tr>
<td>外键约束</td>
<td>让两张表的数据建立连接，保证数据的一致性和完整性</td>
<td><code>foreign key</code></td>
</tr>
<tr>
<td>检查约束</td>
<td>确保列中的所有值满足特定条件</td>
<td><code>check</code></td>
</tr>
</tbody></table>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><ul>
<li>语法：</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名(</span><br><span class="line">	字段<span class="number">1</span> 字段类型 [约束] [comment 字段<span class="number">1</span>注释],</span><br><span class="line">    ……</span><br><span class="line">    字段n 字段类型 [约束] [comment 字段n注释],</span><br><span class="line">    [<span class="keyword">constraint</span>] [外键名称] <span class="keyword">foreign key</span> (外键字段名) <span class="keyword">references</span> 主表 (主表列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">add constraint</span> 外键名称 <span class="keyword">foreign key</span> (外键字段名) <span class="keyword">references</span> 主表 (主表列名)</span><br></pre></td></tr></table></figure></div>

<p>**注意：**主表是父表，包含外键约束的是子表。</p>
<ul>
<li>删除&#x2F;更新行为：</li>
</ul>
<table>
<thead>
<tr>
<th>行为</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NO ACTION</td>
<td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。</td>
</tr>
<tr>
<td>RESTRICT</td>
<td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。</td>
</tr>
<tr>
<td>CASCADE</td>
<td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有，也删除&#x2F;更新外键在子表中的记录。</td>
</tr>
<tr>
<td>SET NULL</td>
<td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（这里要求外键允许取null）</td>
</tr>
<tr>
<td>SET DEFAULT</td>
<td>父表有变更时，子表将外键列设置成一个默认的值(Innodb&#x2F;MySQL不支持)</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意：</strong><br>删除和更新操作需要分别单独进行设置，可以根据具体的需求设置这两个选项。<br>eg：<code>alter table 表名 add constraint 外键名称 foreign key (外键字段) references 主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;</code></p>
</blockquote>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><ul>
<li>**一对多：**在多的一方设置外键，关联一的一方的主键</li>
<li>**多对多：**建立中间表，中间表包含两个外键，关联两张表的主键</li>
<li>**一对一：**用于表结构拆分，在其中任何一方设置外键(UNIQUE)，关联另一方的主键</li>
</ul>
<h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询"></a>多表查询</h3><ul>
<li><strong>内连接</strong><ul>
<li>**隐式：**select … from 表A，表B where 条件 …</li>
<li>**显式：**select … from 表A [inner] join 表B on 条件 …</li>
</ul>
</li>
<li><strong>外连接</strong><ul>
<li>**左外：**select … from 表A left [outer] join 表B on 条件 …</li>
<li>**右外：**select … from 表A right [outer] join 表A on 条件 …</li>
</ul>
</li>
<li>**自连接：**select … from 表A 别名1 ，表A 别名2 where 条件 …【也可以使用外连接】</li>
<li>**子查询：**标量子查询、列子查询、行子查询、表子查询</li>
</ul>
<h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A …</span><br><span class="line"><span class="keyword">union</span> [<span class="keyword">all</span>]</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表B …</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</p>
<ul>
<li>**union all：**会将全部的数据直接合并在一起</li>
<li>**union：**会对合并之后的数据去重</li>
</ul>
</blockquote>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>概念：SQL语句中嵌套select语句，称为<strong>嵌套语句</strong>，又称<strong>子查询</strong><br>	eg：<code>select * from t1 where column1 = (select column1 form t2);</code><br>	子查询外部的语句可以是 insert &#x2F; update &#x2F; delete &#x2F; select 的任何一个。</p>
<h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>子查询返回的结果是单个值 (数字、字符串、日期等)，最简单的形式，这种子查询称为<strong>标量子查询</strong><br>常用的操作符：&#x3D;、&lt;&gt;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;</p>
<h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h4><p>子查询返回的结果是一行(可以是多列)，这种子查询被称为<strong>行子查询</strong><br>常用的操作符：&#x3D;、&lt;&gt;、in、not in</p>
<h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h4><p>子查询返回的结果是一列(可以是多行)，这种查询被称为<strong>列子查询</strong><br>常用的操作符：in、not in、any、some、all</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>在指定的集合范围内，多选一</td>
</tr>
<tr>
<td>not in</td>
<td>不在指定的集合范围之内</td>
</tr>
<tr>
<td>any</td>
<td>子查询返回列表中，有任意一个满足即可</td>
</tr>
<tr>
<td>some</td>
<td>与any等同，使用some的地方都可以使用any</td>
</tr>
<tr>
<td>all</td>
<td>子查询返回列表的所有值都必须满足</td>
</tr>
</tbody></table>
<h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><p>子查询返回的结果是多行多列，这种子查询称为<strong>表子查询</strong><br>常用的操作符：in</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h4 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h4><ol>
<li>事务简介：<br>事务是一组操作的集合，这组操作要么全部执行成功，要么全部执行失败。</li>
<li>事务操作：<ul>
<li><code>start transaction;</code>：开启事务</li>
<li><code>commit / rollback;</code>：提交&#x2F;回滚事务</li>
</ul>
</li>
<li>事务四大特性(ACID)：<ul>
<li>原子性(Atomicity)：原子性是指一个事务中的所有操作要么全部执行，要么全部不执行。</li>
<li>一致性(Consistency)：一致性确保事务在完成时，数据库从一个一致性状态转换到另一个一致性状态。事务的执行不会违反数据库的完整性约束。</li>
<li>隔离性(Isolation)：隔离性确保并发事务的执行不会相互干扰，每个事务的操作对其他事务是隔离的，中间状态对其他事务不可见。</li>
<li>持久性(Durability)：持久性确保一旦事务提交，其对数据库的修改将永久保存，即使系统发生故障，数据也不会丢失。</li>
</ul>
</li>
<li>并发事务问题</li>
</ol>
<table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>脏读</td>
<td>一个事务读到另一个事务还没有提交的数据</td>
</tr>
<tr>
<td>不可重复读</td>
<td>一个事务先后读取同一条记录，但两次读取的数据不同</td>
</tr>
<tr>
<td>幻读</td>
<td>一个事务按照条件查询数据时，没有对应的数据行，但在插入数据时，又发现这行数据已经存在</td>
</tr>
</tbody></table>
<ol start="5">
<li>事务隔离级别</li>
</ol>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read uncommitted</td>
<td>√(会出现)</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read committed（Oracle默认）</td>
<td>×(不会出现)</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable Read（MySQL默认）</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Serializable</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li>开启事务<br><code>start transaction</code>或<code>begin</code></li>
<li>提交事务<br><code>commit</code></li>
<li>回滚事务<br><code>rollback</code></li>
<li>查看事务隔离级别<br><code>select @@TRANSACTION_ISOLATION;</code></li>
<li>设置事务隔离级别<br><code>set [session | global] transaction isolation level &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125;</code><br>**注意：**花括号在写的时候不用加</li>
</ul>
<h2 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729133637.jpeg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729133733.png"
                     
                ></p>
<h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><ol>
<li>在建表的时，指定存储引擎</li>
</ol>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名(</span><br><span class="line">	字段<span class="number">1</span> 字段<span class="number">1</span>类型 [comment 字段<span class="number">1</span>注释],</span><br><span class="line">     …… ,</span><br><span class="line">    字段n 字段n类型 [comment 字段n注释]</span><br><span class="line">) engine <span class="operator">=</span> innodb [comment 表注释];</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>查看当前数据库支持的存储引擎</li>
</ol>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729134651.png"
                      alt="image-20240729134651824"
                ></p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ul>
<li><p>介绍：<br>InnoDB是一种兼顾可靠性和高性能的通用存储引擎，在MySQL 5.5 之后，InnoDB是默认的MySQL存储引擎</p>
</li>
<li><p>特点：</p>
<ul>
<li>DML操作遵守ACID模型，支持<strong>事务</strong>；</li>
<li><strong>行级锁</strong>，提高并发访问性能；</li>
<li>支持<strong>外键</strong> foreign key 约束，保证数据的完整性和正确性；</li>
</ul>
</li>
<li><p>文件：<br>xxx.ibd：xxx代表的是表名，InnoDB引擎的每一张表都会对应这样一个表空间文件，存储该表的结构(frm，sdi)、数据和索引。</p>
<ul>
<li>参数设置：innodb_file_per_table【MySQL 5.6及以上默认值为’ON‘】</li>
</ul>
<blockquote>
<p>当’innodb_file_per_table’设置为’ON‘时，每一个InnoDB表的数据和索引都会储存在独立的表空间文件中，未必是在共享表空间文件(如’ibdata1‘)中。这些独立的表文件通常以<code>.ibd</code>为后缀,存储在数据库的目录中。</p>
<p>查看状态的SQL语句：<code>show variables like &#39;innodb_file_per_table&#39;;</code></p>
<p>查看ibd文件的SQL语句：<code>ibd2sdi 文件名.ibd;</code></p>
</blockquote>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729163604.png"
                     
                ></p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><ul>
<li><p>介绍：<br>MyISAM是MySQL早期的默认存储引擎</p>
</li>
<li><p>特点：</p>
<ul>
<li>不支持<strong>事务</strong>，不支持<strong>外键</strong>；</li>
<li>支持<strong>表锁</strong>，不支持行锁；</li>
<li>访问速度快；</li>
</ul>
</li>
<li><p>文件：<br>xxx.sdi：存储表结构信息</p>
<p>xxx.MYD：存储数据</p>
<p>xxx.MYI：存储索引</p>
</li>
</ul>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><ul>
<li><p>介绍：<br>Memory引擎的表数据存储在内存中，由于受到硬件问题，或断电问题的影响，只能将这些表作为临时表或缓存使用。</p>
</li>
<li><p>特点：</p>
<ul>
<li>内存存放</li>
<li>hash索引（默认）</li>
</ul>
</li>
<li><p>文件：<br>xxx.sdi：存储表结构信息</p>
</li>
</ul>
<h3 id="不同引擎的区别与选择"><a href="#不同引擎的区别与选择" class="headerlink" title="不同引擎的区别与选择"></a>不同引擎的区别与选择</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729162442.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729162647.png"
                     
                ></p>
<blockquote>
<ul>
<li>InnoDB：存储业务系统中对事务、数据完整性要求较高的核心数据。</li>
<li>MyISAM：存储业务系统的非核心事务。</li>
</ul>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>介绍：<br>索引(index)是帮助MySQL高效获取数据的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</li>
<li>优缺点：</li>
</ul>
<table>
<thead>
<tr>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody><tr>
<td>提高数据检索的效率，降低数据库的IO成本</td>
<td>索引列也是要占用空间的</td>
</tr>
<tr>
<td>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</td>
<td>索引大大提高了查询效率，同时却也降低了更新表的速度，如对表进行insert、update、delete时，效率降低。</td>
</tr>
</tbody></table>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729170831.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729170900.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729171005.png"
                     
                ></p>
<p>思考题</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729175532.png"
                     
                ></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对表中主键创建的索引</td>
<td>默认自动创建，只能有一个</td>
<td>primary</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以有多个</td>
<td>unique</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以有多个·</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td>
<td>可以有多个</td>
<td>fulltext</td>
</tr>
</tbody></table>
<p>在Innodb存储引擎中，根据索引的存储形式，又可以分为以下两种：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>聚焦索引(Clustered Index)</td>
<td>将数据存储和索引放到了一块，索引结构的叶子节点保存了行数据</td>
<td>必须有，且有且仅有一个</td>
</tr>
<tr>
<td>二级索引(Secondary Index)</td>
<td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody></table>
<p>聚集索引选取规则：</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个非空唯一（not null unique）索引作为聚集索引</li>
<li>如果表没有主键，或没有合适的唯一索引，Innodb会自动生成一个<code>rowid</code>作为隐藏的聚集索引</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240729193024.png"
                     
                ></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul>
<li><p>创建索引</p>
<p><code>create [unique | fulltext ] index index_name on table_name (index_col_name,…);</code></p>
</li>
<li><p>查看索引<br><code>show index from table_name;</code></p>
</li>
<li><p>删除索引</p>
<p><code>drop index index_name on table_name;</code></p>
</li>
</ul>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ul>
<li><p>查看执行频次<br><code>show [session | global] status like &#39;Com_______&#39;;</code>【一共7个下划线】</p>
</li>
<li><p>慢查询日志<br>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。MySQL的慢查询日志默认没有开启。</p>
<ul>
<li>查看慢查询日志是否开启<br><code>show variables like &#39;slow_query_log&#39;;</code></li>
<li>开启慢查询日志<br>需要在MySQL的配置文件（ &#x2F;etc&#x2F;my.cnf ）中配置如下信息</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 开启MySQL慢查询日志开关</span><br><span class="line">slow_query_log <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"># 设置慢查询的时间为<span class="number">2</span>s，<span class="keyword">SQL</span>语句执行时间超过<span class="number">2</span>s，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></div>

<p>配置完毕后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息 <strong>&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log</strong>，开启慢查询后，会自动创建这个文件夹。</p>
</li>
<li><p>profile详情<br>show profiles 能够在做SQL优化时帮助我们了解时间都消耗到哪里去了。</p>
<ul>
<li>通过<code>have_profiling</code>参数，能够看到当前MySQL是否支持profile操作<br><code>select @@have_profiling;</code></li>
<li>默认profiling是关闭的，可以通过set语句在session &#x2F; global级别开启profiling<br><code>set profiling = 1;</code></li>
<li>常用指令</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 查看每一条<span class="keyword">SQL</span>的耗时基本情况</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"></span><br><span class="line"># 查看指定query_id的<span class="keyword">SQL</span>语句各个阶段的耗时情况【query_id是在执行完<span class="keyword">show</span> profiles会提供的】</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br><span class="line"></span><br><span class="line"># 查看指定query_id的<span class="keyword">SQL</span>语句CPU的使用情况</span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>explain执行计划<br>explain &#x2F; desc 命令获取MySQL如何执行select语句的信息，包括在select语句执行过程中表如何连接和连接的顺序。</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 直接在<span class="keyword">select</span>语句之间加上关键字 explain <span class="operator">/</span> <span class="keyword">desc</span></span><br><span class="line">explain <span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240730124417.png"
                     
                ></p>
<ul>
<li><strong>id</strong>：select查询的序列号，表示查询中执行select子句或者操作表的顺序( id相同，执行顺序从上到下；id不同，值越大，越先执行)。</li>
<li><strong>select_type</strong>：表示select的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（select&#x2F;where之后包含了子查询）等。</li>
<li><strong>type</strong>：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all。</li>
<li><strong>possible_key</strong>：显示可能应用在这张表上的索引，可以是一个或多个。</li>
<li><strong>key</strong>：实际使用到的索引，如果为NULL，表示没有使用索引。</li>
<li><strong>key_len</strong>：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</li>
<li><strong>rows</strong>：MySQL认为必须要执行查询的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的。</li>
<li><strong>filtered</strong>：表示返回结果的行数占需要读取行数的百分比，filtered的值越大越好，最大等于100。</li>
</ul>
</li>
</ul>
<h3 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h3><h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><p>如果索引了多列（联合索引），要遵守最左前缀法则，查询从最左列开始，并且不跳过索引中的列。如果跳跃某一列，<strong>索引将部分失效（后面的字段索引失效）</strong>。</p>
<h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>联合索引中，出现范围查询(&gt;，&lt;)，<strong>范围查询右侧的列索引失效</strong></p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age<span class="operator">&gt;</span><span class="number">30</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 注意：<span class="operator">&gt;=</span>、<span class="operator">&lt;=</span>不会失效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age<span class="operator">&gt;=</span><span class="number">30</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;0&#x27;</span>;【不会失效】</span><br></pre></td></tr></table></figure></div>

<h4 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h4><ul>
<li><strong>索引列运算</strong>：不要在索引列上进行运算操作，索引将失效</li>
<li><strong>字符串不加引号</strong>：字符串类型字段使用时不加引号，索引将失效</li>
<li><strong>模糊查询</strong>：如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效</li>
<li><strong>or连接的条件</strong>：用or分割开的条件，如果or前的条件的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到</li>
<li><strong>数据分布影响</strong>：如果MySQL评估使用索引比全表更慢，则不使用索引</li>
</ul>
<h4 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h4><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># use index:(建议使用)</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_name use index(idx_user_pro) <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># ignore index:(忽略索引<span class="operator">/</span>不使用)</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_name ignore index(idx_user_pro) <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># force index:(强制使用)</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_name force index(idx_user_pro) <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在索引中已经全部能够找到，减少<code>select *</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240730171450.png"
                      alt="image-20240730171450404"
                ></p>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>当字段类型为字符串（varchar，text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时浪费大量的磁盘IO，影响查询效率。此时可以只将字符的一部分前缀建立索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<ul>
<li><p>语法：<br><code>create index idx_xxxx on table_name(column(n));</code></p>
</li>
<li><p>前缀长度</p>
<p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性时1，这是最好的索引选择性，性能也是最好的。</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email,<span class="number">1</span>,<span class="number">5</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240730173359.png"
                     
                ></p>
</li>
</ul>
<h4 id="单列索引与联合索引"><a href="#单列索引与联合索引" class="headerlink" title="单列索引与联合索引"></a>单列索引与联合索引</h4><ul>
<li>单列索引：即一个索引只包含单个列。</li>
<li>联合索引：即一个索引包含了多个列。</li>
</ul>
<p>【在业务场景中，如果存在多个查询条件时，考虑针对查询字段建立索引时，建议建立联合索引，而非单列索引】</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240730174806.png"
                      alt="image-20240730174806656"
                ></p>
<blockquote>
<p>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询。<br>也就是说当你只查询一个条件时，也有可能是用到联合索引。</p>
</blockquote>
<h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240730174832.png"
                      alt="image-20240730174832726"
                ></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240730183811.png"
                      alt="image-20240730183810887" style="zoom:50%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240730183901.png"
                      alt="image-20240730183901044" style="zoom: 33%;" 
                >

<h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="insert优化"><a href="#insert优化" class="headerlink" title="insert优化"></a>insert优化</h3><ul>
<li>批量插入<br><code>insert into table_name values (值1，值2……)，(值1，值2……);</code></li>
<li>手动提交事务</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert into</span> table_name <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span>……)，(值<span class="number">1</span>，值<span class="number">2</span>……),……;</span><br><span class="line"><span class="keyword">insert into</span> table_name <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span>……)，(值<span class="number">1</span>，值<span class="number">2</span>……),……;</span><br><span class="line"><span class="keyword">insert into</span> table_name <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span>……)，(值<span class="number">1</span>，值<span class="number">2</span>……),……;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>主键顺序插入</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 主键乱序插入：<span class="number">8</span> <span class="number">1</span> <span class="number">9</span> <span class="number">21</span> <span class="number">88</span> <span class="number">2</span> <span class="number">4</span> <span class="number">15</span> 速度慢</span><br><span class="line"># 主键顺序插入：<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">9</span> <span class="number">15</span> <span class="number">21</span> <span class="number">88</span> 速度更快</span><br></pre></td></tr></table></figure></div>

<ul>
<li>大批量插入数据</li>
</ul>
<p>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 客户端连接服务端时，加上参数 <span class="comment">--local-infile</span></span><br><span class="line">mysql <span class="comment">--local-infile -u root -p</span></span><br><span class="line"># 设置全局参数local_infile为<span class="number">1</span>，开启从本地加载文件导入数据的开关</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"># 执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;数据文件路径&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> `tb_name` fields terminated <span class="keyword">by</span> <span class="string">&#x27;区分一行小数据的符号&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;区分每行大数据的符号&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 查看local_infile状态的语句</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@local_infile</span>;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731190144.png"
                      alt="image-20240731190136913"
                ></p>
<h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731192536.png"
                      alt="image-20240731192535901"
                ></p>
<ul>
<li>页分裂</li>
</ul>
<p>主键顺序插入的话并不会发生页分裂的问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731192618.png"
                      alt="image-20240731192618271"
                ></p>
<p>主键乱序插入的情况</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731192836.png"
                      alt="image-20240731192835678"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731192941.png"
                      alt="image-20240731192941544"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731192851.png"
                      alt="image-20240731192851083"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731192859.png"
                      alt="image-20240731192859507"
                ></p>
<ul>
<li>页合并</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731193030.png"
                      alt="image-20240731193029775"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731193043.png"
                      alt="image-20240731193043025"
                ></p>
<ul>
<li>页分裂(合并)的危害<ul>
<li>页分裂和合并涉及大量的数据移动和重组操作。频繁进行这些操作会追加数据库的 I&#x2F;O 负担和CPU消耗，从而影响数据库的整体性能。</li>
<li>分裂和合并可能会导致 B+树索引结构频繁地进行调整，这会影响插入和删除操作的性能。</li>
<li>频繁的页分裂和合并还可能导致磁盘上存在较多的空间碎片。新分出的数据页通常会有大量的空闲空间，则会导致数据库表占用更多的磁盘空间，造成资源浪费。</li>
</ul>
</li>
</ul>
<p><a class="link"   href="https://blog.csdn.net/weixin_43957967/article/details/140259106#t3" >如何避免分页<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<ul>
<li>主键设计原则<ul>
<li>满足业务需求的情况下，尽量降低主键的长度。</li>
<li>插入数据时，尽量选择顺序插入，选择使用<code>auto_increment</code>自增主键。</li>
<li>尽量不要使用UUID做主键或者其它自然主键，如身份证号。</li>
<li>业务操作时，避免对主键的修改。</li>
</ul>
</li>
</ul>
<h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><ol>
<li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序。</li>
<li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高。</li>
</ol>
<ul>
<li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li>
<li>尽量使用覆盖索引，避免回表。</li>
<li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则(ASC&#x2F;DESC)是否和排序规则一致。</li>
<li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小<code>sort_buffer_size</code>（默认值256k）</li>
</ul>
<h3 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h3><ul>
<li>在分组操作时，可以通过索引来提高效率。</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的。</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 假设存在索引 idx_user_pro_age</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> age, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> age;  </span><br><span class="line"># 不满足最左前缀法则，使用的是临时表</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> age, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> age;</span><br><span class="line"># 满足最左前缀法则，使用的是索引</span><br></pre></td></tr></table></figure></div>

<h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p>当搜索是limit 20000000，10时，此时需要MySQL排序前20000010记录，仅仅返回20000000 - 20000010的记录，其它记录丢弃，查询排序的代价非常大。</p>
<p>优化思路：一般分页查询时，通过建立 <strong>覆盖索引</strong> 能够比较好的提高性能，可以通过<strong>覆盖索引</strong> 加 <strong>子查询</strong>形式进行优化</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_sku t , (<span class="keyword">select</span> id <span class="keyword">from</span> tb_sku <span class="keyword">order</span> id limit <span class="number">2000000</span>,<span class="number">10</span>) a <span class="keyword">where</span> t.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure></div>

<h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><ul>
<li><p>count( )是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是null，累计值就加1，否则不加，最后返回累计值</p>
</li>
<li><p>用法：count(*)、count(主键)、count(字段)、count(1)</p>
<ul>
<li><p>count(主键)</p>
<p>InnoDB引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行累加（主键不可能为null）。</p>
</li>
<li><p>count(字段)</p>
<p>没有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务端，服务层判断是否为null，不为null，计数累加。</p>
<p>有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</p>
</li>
<li><p>count(1)</p>
<p>InnoDB引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个字”1“进去，直接按行进行累加。</p>
<p>【括号里的也可以是2，3，4……不一定是1】</p>
</li>
<li><p>count(*)</p>
<p>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</p>
</li>
</ul>
<blockquote>
<p>按效率排序：</p>
<p>count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)，尽量使用 count(*)</p>
</blockquote>
</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高；</p>
</li>
<li><p>InnoDB引擎就比较麻烦，它执行count(*)的时候，需要把数据一个一个地从引擎里面读取出来，然后累积计数。</p>
<p><code>优化思路：自己计数。</code></p>
</li>
</ul>
<h3 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h3><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240731233825.png"
                      alt="image-20240731233824572"
                ></p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>视图(View) 是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p>
<blockquote>
<p>视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作在于创建这条SQL查询语句上。</p>
</blockquote>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li><p>创建</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">or</span> replace] <span class="keyword">view</span> 视图名称[(列名列表)] <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span>[<span class="keyword">cascaded</span> <span class="operator">|</span> <span class="keyword">local</span>] <span class="keyword">check</span> option];</span><br></pre></td></tr></table></figure></div>

<p>如果不定义 <code>列名列表</code>，那么视图中的列名将默认采用 <code>SELECT</code> 语句中所选择的列名。这意味着视图中的每一列将继承 <code>SELECT</code> 语句中的列名。</p>
<p>如果不定义<code>cascaded | local</code>且写了<code>with check option</code>,默认是<code>with cascaded check option</code></p>
<blockquote>
<ul>
<li><p><strong>什么都不写</strong></p>
<p>在执行插入、更新、删除等操作时并没有条件约束。</p>
</li>
<li><p><strong>cascaded check option</strong></p>
<p>创建视图时加上了<code>cascaded check option</code>,在执行插入、更新、删除等操作时会递归所有底层视图的约束条件，确保每一层次的条件都满足。</p>
</li>
<li><p><strong>local check option</strong></p>
<p><code>local check option</code>只检查直接视图的定义条件，而不会检查底层视图的约束条件。</p>
</li>
<li><p><strong>如果视图是基于其它视图创建的</strong></p>
<p>会去查看基于的视图是否被<code>[with[cascaded | local] check option]</code>定义。</p>
</li>
</ul>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240801213751.png"
                      alt="image-20240801213751217"
                ></p>
<ul>
<li>查询</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 查看创建视图语句</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> 视图名称;</span><br><span class="line"># 查看视图数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 视图名称 ……;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>修改</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 方式一</span><br><span class="line"><span class="keyword">create</span> [<span class="keyword">or</span> replace] <span class="keyword">view</span> 视图名称[(列名列表)] <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span>[<span class="keyword">cascaded</span> <span class="operator">|</span> <span class="keyword">local</span>] <span class="keyword">check</span> option];</span><br><span class="line"># 方式二</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> 视图名称[(列名列表)] <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span>[<span class="keyword">cascaded</span> <span class="operator">|</span> <span class="keyword">local</span>] <span class="keyword">check</span> option];</span><br></pre></td></tr></table></figure></div>

<ul>
<li>删除</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> [if <span class="keyword">exists</span>] 视图名称 [,视图名称] …;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则视图不可更新：</p>
<ol>
<li>聚合函数或窗口函数：sum( )、min( )、max( )、count( )等</li>
<li>distinct</li>
<li>group by</li>
<li>having</li>
<li>union 或者 union all</li>
</ol>
<blockquote>
<p>这里的“更新”包括插入操作、更新操作和删除操作。具体来说，当视图包含聚合函数、<code>DISTINCT</code>、<code>GROUP BY</code>、<code>HAVING</code> 或 <code>UNION</code>（<code>UNION ALL</code>）时，视图不仅不可更新，还不可进行插入和删除操作。这是因为这些操作都要求视图中的行能够直接映射回基础表中的行，而上述项使得这种映射无法实现。</p>
<p><strong>为什么不能进行插入操作？</strong><br>视图是基于基础表定义的虚拟表，它并不实际存储数据，而是动态地从基础表中检索和计算数据。因此，通过视图进行的插入操作实际上需要插入到基础表中。如果视图包含聚合函数、<code>GROUP BY</code>、<code>HAVING</code> 等特性，视图中的数据与基础表中的具体行并不直接一一对应，这导致插入操作无法匹配并插入到基础表中。</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> sales (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    salesperson_id <span class="type">INT</span>,</span><br><span class="line">    sales_amount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> sales (id, salesperson_id, sales_amount) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">101</span>, <span class="number">500.00</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="number">102</span>, <span class="number">300.00</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="number">101</span>, <span class="number">700.00</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="number">103</span>, <span class="number">200.00</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> sales_summary <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> salesperson_id, <span class="built_in">SUM</span>(sales_amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> salesperson_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> sales_summary (salesperson_id, total_sales) <span class="keyword">VALUES</span> (<span class="number">104</span>, <span class="number">400.00</span>);</span><br><span class="line"># 报错：The target <span class="keyword">table</span> sales_summary <span class="keyword">of</span> the <span class="keyword">INSERT</span> <span class="keyword">is</span> <span class="keyword">not</span> insertable<span class="operator">-</span><span class="keyword">into</span></span><br></pre></td></tr></table></figure></div>

</blockquote>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>简单<br>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作指定全部的条件。</li>
<li>安全<br>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能看到的数据</li>
<li>数据独立<br>视图可帮助用户屏蔽真实表结构变化带来的影响。</li>
</ul>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>封装、复用</strong></li>
<li>可以接受参数，也可以返回数据</li>
<li>减少网络交流、效率提升</li>
</ul>
<h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li>创建</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([参数列表])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">--SQL语句</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>调用</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> 名称([参数]);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.routines <span class="keyword">where</span> routine_schema<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line"># 查询指定数据库的存储过程及状态信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称;</span><br><span class="line"># 查询某个存储过程的定义</span><br></pre></td></tr></table></figure></div>

<ul>
<li>删除</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> [if <span class="keyword">exists</span>] 存储过程名称;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>注意：</strong></p>
<p>在命令行中，执行创建存储过程的SQL时，需要通过关键字 delimiter 指定SQL语句的结束符。</p>
<p>比如：<code>delimiter $$;</code> ，表明以$$结尾来作为结束语句，默认是<code>;</code></p>
</blockquote>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><p>系统变量是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（global）、会话变量（session）</p>
<ul>
<li>查看系统变量</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 查看所有系统变量</span><br><span class="line"><span class="keyword">show</span> [session <span class="operator">|</span> <span class="keyword">global</span>] variables;</span><br><span class="line"></span><br><span class="line"># 可以通过<span class="keyword">like</span>模糊匹配方式查找变量</span><br><span class="line"><span class="keyword">show</span> [session <span class="operator">|</span> <span class="keyword">global</span>] variables <span class="keyword">like</span> <span class="string">&#x27;……&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 查看指定变量的值</span><br><span class="line"><span class="keyword">select</span> @@[session. <span class="operator">|</span> global.]系统变量名;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>设置系统变量</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> [session <span class="operator">|</span> <span class="keyword">global</span>] 系统变量名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">set</span> @@[session. <span class="operator">|</span> global.]系统变量名 <span class="operator">=</span> 值;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li><p>如果没有指定 session | global，默认是session，会话变量。</p>
</li>
<li><p>MySQL服务重启之后，所设置的全局参数会失效，想要不失效，可以在 &#x2F;etc&#x2F;my.cnf 中配置</p>
</li>
</ol>
</blockquote>
<h4 id="用户定义变量"><a href="#用户定义变量" class="headerlink" title="用户定义变量"></a>用户定义变量</h4><p>用户定义变量是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接通过<code>@变量名</code>使用就可以。其作用域为当前连接。</p>
<ul>
<li>赋值</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@var_name</span> <span class="operator">=</span> expr [, <span class="variable">@var_name</span> <span class="operator">=</span> expr] ……;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr [, <span class="variable">@var_name</span> :<span class="operator">=</span> expr] ……;</span><br><span class="line">更推荐使用 :<span class="operator">=</span> , 因为在<span class="keyword">SQL</span>语言中的等于用的就是 <span class="operator">=</span> ,为了让赋值和比较逻辑中的等于区分开来。</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr [, <span class="variable">@var_name</span> :<span class="operator">=</span> expr] ……;</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> <span class="variable">@var_name</span> <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="variable">@var_name</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>注意：</strong></p>
<p>用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="variable">@abc</span>; <span class="comment">-- 事先没有定义过 @abc</span></span><br><span class="line"># 输出的值为<span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></div></blockquote>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>局部变量是根据需要定义的在局部生效的变量，访问之前需要<code>declare</code>声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内部声明的<code>begin … end</code>块。</p>
<ul>
<li>声明</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> 变量名 变量类型 [<span class="keyword">default</span> …];</span><br></pre></td></tr></table></figure></div>

<p>变量类型就是数据库字段类型：int、bigint、double、char、varchar、date、time等。</p>
<ul>
<li>赋值</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> 变量名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">set</span> 变量名 :<span class="operator">=</span> 值；</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> 变量名 <span class="keyword">from</span> 表名…;</span><br></pre></td></tr></table></figure></div>

<h4 id="用户定义变量-VS-局部变量"><a href="#用户定义变量-VS-局部变量" class="headerlink" title="用户定义变量 VS 局部变量"></a>用户定义变量 VS 局部变量</h4><table>
<thead>
<tr>
<th>特性</th>
<th>用户定义变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody><tr>
<td>作用范围</td>
<td>会话级别</td>
<td>begin…end 块内</td>
</tr>
<tr>
<td>声明方式</td>
<td>无需显式声明，以‘@’符号开头</td>
<td>通过’declare’语句声明</td>
</tr>
<tr>
<td>生命周期</td>
<td>会话期间</td>
<td>begin…end 块内</td>
</tr>
<tr>
<td>使用场景</td>
<td>跨多个语句使用</td>
<td>存储过程、函数或触发器内</td>
</tr>
<tr>
<td>数据类型</td>
<td>自动确定</td>
<td>必须指定数据类型</td>
</tr>
</tbody></table>
<ul>
<li><p>用户定义变量</p>
<ul>
<li>可以在存储过程中使用，但不推荐在复杂的SQL查询中频繁使用。</li>
</ul>
</li>
<li><p>局部变量</p>
<ul>
<li>仅在存储过程、函数或触发器中使用，生命周期受限于它们的作用范围。</li>
<li>更适合在存储过程或函数内部处理复杂的逻辑。</li>
</ul>
</li>
</ul>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>该类参数作为输入，也就是需要调用时传入值</td>
<td>默认</td>
</tr>
<tr>
<td>OUT</td>
<td>该类参数作为输出，也就是该参数可以作为返回值</td>
<td></td>
</tr>
<tr>
<td>INOUT</td>
<td>既可以作为输入参数，也可以作为输出参数</td>
<td></td>
</tr>
</tbody></table>
<p>语法：</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([<span class="keyword">IN</span><span class="operator">/</span><span class="keyword">OUT</span><span class="operator">/</span><span class="keyword">INOUT</span> 参数名 参数类型])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">--SQL语句</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>语法：</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">if 条件<span class="number">1</span> <span class="keyword">then</span> ……</span><br><span class="line">elseif 条件<span class="number">2</span> <span class="keyword">then</span> ……	 	<span class="comment">-- 可选</span></span><br><span class="line"><span class="keyword">else</span> ……		<span class="comment">-- 可选</span></span><br><span class="line"><span class="keyword">end</span> if;</span><br></pre></td></tr></table></figure></div>

<h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><p>语法1（填准确值）：</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> case_value</span><br><span class="line">	<span class="keyword">when</span> when_value1 <span class="keyword">then</span> statement_list1</span><br><span class="line">	[<span class="keyword">when</span> when_value2 <span class="keyword">then</span> statement_list2]</span><br><span class="line">	……</span><br><span class="line">	[<span class="keyword">else</span> statement_list]</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure></div>

<p>语法2（填表达式）：</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span></span><br><span class="line">	<span class="keyword">when</span> search_condition1 <span class="keyword">then</span> statement_list1</span><br><span class="line">	[<span class="keyword">when</span> search_condition2 <span class="keyword">then</span> statement_list2]</span><br><span class="line">	……</span><br><span class="line">	[<span class="keyword">else</span> statement_list]</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>while循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 先判定条件，如果条件为<span class="literal">true</span>，则执行逻辑，否则，不执行逻辑</span><br><span class="line">while 条件 do</span><br><span class="line">	<span class="keyword">SQL</span>逻辑…</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> while;</span><br></pre></td></tr></table></figure></div>

<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><p>repeat是有条件的循环2控制语句，当满足条件的时候推出循环。【相当于do…while语句，先执行一次再判断条件】</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">repeat</span><br><span class="line">	<span class="keyword">SQL</span>逻辑……</span><br><span class="line">	until 条件</span><br><span class="line"><span class="keyword">end</span> repeat;</span><br></pre></td></tr></table></figure></div>

<h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><p>loop实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用来实现简单的死循环。loop可以配合以下两个语句使用：</p>
<ul>
<li>leave：配合循环使用，退出循环。</li>
<li>iterate：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环</li>
</ul>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">[begin_label:] loop</span><br><span class="line">	<span class="keyword">SQL</span>逻辑…</span><br><span class="line"><span class="keyword">end</span> loop [end_label];</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">leave label; <span class="comment">-- 退出指定标记的循环体</span></span><br><span class="line">iterate label; <span class="comment">-- 直接进入下一次循环</span></span><br><span class="line"># 搭配if <span class="keyword">then</span> 语句使用</span><br></pre></td></tr></table></figure></div>

<p>eg：</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	sum: loop</span><br><span class="line">		if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span> leave sum;</span><br><span class="line">		<span class="keyword">end</span> if;</span><br><span class="line">	<span class="keyword">end</span> loop sum;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>游标（cursor）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明，open、fetch和close。</p>
<ul>
<li><p>声明游标</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> 游标名称 <span class="keyword">cursor</span> <span class="keyword">for</span> 查询语句;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>打开游标</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> 游标名称;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>获取游标记录</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fetch</span> 游标名称 <span class="keyword">into</span> 变量[,变量];</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>关闭游标</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">close</span> 游标名称;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="条件处理程序"><a href="#条件处理程序" class="headerlink" title="条件处理程序"></a>条件处理程序</h3><p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> handler_action handler <span class="keyword">for</span> condition_value [,condition_value]… statement;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>handler_action<ul>
<li>**continue：**继续执行当前程序</li>
<li>**exit：**终止执行当前程序</li>
</ul>
</li>
<li>condition_value<ul>
<li>**sqlstate sqlstate_value：**状态码，sqlstate_value可以是02000等</li>
<li>**sqlwarning：**所有以01开头的sqlstate代码的简写</li>
<li>**not found：**所有以02开头的sqlstate代码的简写</li>
<li>**sqlexception：**所有没有被 sqlwarning 或 not found 捕获的sqlstate代码的简写</li>
</ul>
</li>
</ul>
<p>状态码的查询网址：<a class="link"   href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html" >https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p2(<span class="keyword">in</span> uage <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">	<span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name,profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">&lt;=</span> uage;</span><br><span class="line">	<span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">sqlstate</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">close</span> u_cursor;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro;</span><br><span class="line">	<span class="keyword">create table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tb_user_pro(</span><br><span class="line">    	id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment,</span><br><span class="line">        name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    	profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> u_cursor;</span><br><span class="line">    while <span class="literal">true</span> do</span><br><span class="line">    	<span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname,upro;</span><br><span class="line">    	<span class="keyword">insert into</span> tb_user_pro <span class="keyword">values</span> (<span class="keyword">null</span>,uname,upro);</span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">close</span> u_cursor;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><p>存储函数是有返回值的存储过程，存储函数的参数只能是 in 类型的。</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 存储函数的名称([参数列表])</span><br><span class="line"><span class="keyword">return</span> type [characteristic…]</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	…<span class="keyword">SQL</span>语句</span><br><span class="line">	<span class="keyword">return</span>…;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>type<ul>
<li>int、bigint、double、char、varchar、date、time等。</li>
</ul>
</li>
<li>characteristic<ul>
<li>determinstic：相同的输入参数总是产生相同的结果</li>
<li>no sql：不含sql语句</li>
<li>reads sql data：包含读取数据的语句，但不包含写入数据的语句</li>
</ul>
</li>
</ul>
<blockquote>
<p>可以用存储函数的场景都可以使用存储过程。</p>
</blockquote>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><ul>
<li><p>介绍</p>
<p>触发器是与表有关的数据库对象，指在 insert &#x2F; update &#x2F; delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。</p>
<p>使用别名 <code>old</code> 和 <code>new</code> 来引用触发器中发生变化的记录内容，这与其它的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>触发器类型</th>
<th>NEW和OLD</th>
</tr>
</thead>
<tbody><tr>
<td>insert型触发器</td>
<td>new表示将要或者已经新增的数据</td>
</tr>
<tr>
<td>update型触发器</td>
<td>old表示修改之前的数据，new表示将要或已经修改后的数据</td>
</tr>
<tr>
<td>delete型触发器</td>
<td>old表示将要或者已经删除的数据</td>
</tr>
</tbody></table>
<ul>
<li><p>语法</p>
<ul>
<li><p>创建</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name</span><br><span class="line">before<span class="operator">/</span>after <span class="keyword">insert</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">/</span><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">on</span> tbl_name <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> <span class="comment">-- 行级触发器</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	trigger_stmt;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>查看</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> triggers;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>删除</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> [schema_name.]trigger_name;<span class="comment">-- 如果没有指定schema_name,默认为当前数据库</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<p>eg：</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_update_trigger</span><br><span class="line">	after <span class="keyword">update</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">insert into</span> user_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span></span><br><span class="line">	(<span class="keyword">null</span>,<span class="string">&#x27;insert&#x27;</span>,now(),new.id,</span><br><span class="line">     concat(<span class="string">&#x27;插入的数据内容为：id=&#x27;</span>,new.id,<span class="string">&#x27;,name=&#x27;</span>,new.name));</span><br><span class="line"> <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>锁是计算机协调多个进程或者线程并发访问某一资源的机制。在数据库中，除传统计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。</p>
<p>MySQL中的锁，按照锁的颗粒度分为以下三类：</p>
<ol>
<li>全局锁：锁定数据库的所有表。</li>
<li>表级锁：每次操作锁住整张表。</li>
<li>行级锁：每次操作锁住对应的行数据。</li>
</ol>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。【DQL查询语句可以继续执行】</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240803201459.png"
                      alt="image-20240803201458973"
                ></p>
<blockquote>
<p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
</blockquote>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># Step <span class="number">1</span>：锁定数据库</span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"></span><br><span class="line"># Step <span class="number">2</span>：打开另一个终端窗口，执行备份[在终端中执行，而不是在MySQL窗口中]</span><br><span class="line">mysqldump <span class="operator">-</span>u <span class="operator">-</span>p 数据库名 <span class="operator">&gt;</span> 备份文件.<span class="keyword">sql</span></span><br><span class="line"></span><br><span class="line"># Step <span class="number">3</span>：返回MySQL会话，解锁数据库</span><br><span class="line">unlock tables;</span><br><span class="line"></span><br><span class="line"># 在一个窗口中执行的情况<span class="comment">---------------------------------------</span></span><br><span class="line"></span><br><span class="line"># Step <span class="number">1</span>: 登录MySQL并启用全局锁</span><br><span class="line">mysql <span class="operator">-</span>u 用户名 <span class="operator">-</span>p <span class="operator">-</span>e &quot;FLUSH TABLES WITH READ LOCK;&quot;</span><br><span class="line"></span><br><span class="line"># Step <span class="number">2</span>: 在同一个终端中执行备份操作</span><br><span class="line">mysqldump <span class="operator">-</span>u 用户名 <span class="operator">-</span>p 数据库名 <span class="operator">&gt;</span> 备份文件.<span class="keyword">sql</span></span><br><span class="line"></span><br><span class="line"># Step <span class="number">3</span>: 解除全局锁</span><br><span class="line">mysql <span class="operator">-</span>u 用户名 <span class="operator">-</span>p <span class="operator">-</span>e &quot;UNLOCK TABLES;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致性数据备份</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump <span class="comment">--single-transaction -u 用户名 -p  数据库名 &gt; 备份文件.sql</span></span><br></pre></td></tr></table></figure></div>

<p>备份过程中不会锁定表，因此可以最大限度地减少对数据库的干扰。这对于高并发、需要持续写操作的数据库尤为重要。但在高负载环境中，长时间的备份可能会增加I&#x2F;O负担，影响数据库性能。</p>
</blockquote>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p>
<ol>
<li>如果在主库上备份，那么在备份期间不能执行更新，业务基本上就得停摆。</li>
<li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</li>
</ol>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InooDB、BDB等存储引擎中。</p>
<p>表级锁主要分为以下三类：</p>
<ul>
<li>表锁</li>
<li>元数据锁（meta data lock，MDL）</li>
<li>意向锁</li>
</ul>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><ul>
<li>表共享读锁（read lock）：不会阻塞其它客户端的读，但是会阻塞写。</li>
<li>表独占写锁（write lock）：既阻塞其它客户端的读，有阻塞其它客户端的写。</li>
</ul>
<p>语法：</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 加锁</span><br><span class="line">lock tables 表名… read<span class="operator">/</span>write;</span><br><span class="line"></span><br><span class="line"># 释放锁</span><br><span class="line">unlock tables; <span class="operator">/</span> 客户端断开连接</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240803201344.png"
                      alt="image-20240803201337334"
                ></p>
<h4 id="元数据锁（meta-data-lock，MDL）"><a href="#元数据锁（meta-data-lock，MDL）" class="headerlink" title="元数据锁（meta data lock，MDL）"></a>元数据锁（meta data lock，MDL）</h4><p>MDL加锁过程是系统自动控制，无需显式使用。在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML与DDL冲突，保证读写的正确性</strong>。</p>
<p>在MySQL5.5中引入了MDL，<strong>当对一张表进行增删改查的时候，加MDL读锁（共享）；当对表结构进行变更操作的时候，加MDL写锁（排他）</strong>。</p>
<table>
<thead>
<tr>
<th>对应SQL</th>
<th>锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock tables xxx read &#x2F; write</td>
<td>SHARED_READ_ONLY &#x2F; SHARED_NO_READ_WRITE</td>
<td></td>
</tr>
<tr>
<td>select、select … lock in share mode</td>
<td>SHARED_READ</td>
<td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td>
</tr>
<tr>
<td>insert、update、delete、select … for update</td>
<td>SHARED_WRITE</td>
<td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td>
</tr>
<tr>
<td>alter table ……</td>
<td>EXCLUSIVE</td>
<td>与其它的MDL都互斥</td>
</tr>
</tbody></table>
<p>查看元数据锁</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> object_type,object_schema,object_name,lock_type,lock_duration <span class="keyword">from</span> performance_schema.metadata_locks;</span><br></pre></td></tr></table></figure></div>

<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>意向锁的主要作用是实现多粒度锁定（即表级和行级锁定）的高效管理。通过在表级别使用意向锁，InnoDB可以快速确定某个事务是否可以安全地在行级别加锁，而不需要检查表中的每一行是否已被其他事务锁定。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240803205817.png"
                      alt="image-20240803205817547"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240803205834.png"
                      alt="image-20240803205834335"
                ></p>
<ol>
<li>意向共享锁（IS）：由语句 <strong>select … lock in share mode</strong> 添加。<ul>
<li>与表锁共享锁（read）兼容，与表锁排他锁（write）互斥</li>
</ul>
</li>
<li>意向排他锁（IX）：由<strong>insert、update、delete、select … for update</strong>添加。<ul>
<li>与表锁共享锁（read）及排他锁（write）都互斥。意向锁之间不会互斥。</li>
</ul>
</li>
</ol>
<p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure></div>

<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><h4 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h4><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p>
<p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p>
<ol>
<li>行锁（Record Lock）：锁定单个行记录的锁，防止其它事务对此行进行update和delete。在RC、RR隔离级别下都支持。</li>
<li>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录，开区间），确保索引记录间隙不变，防止其它事务在这个间隙进行insert，产生幻读。在RR隔离级别下支持。</li>
<li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap，在RR隔离级别下支持。</li>
</ol>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>InnoDB实现了以下两种类型的行锁：</p>
<ol>
<li>共享锁（S）：允许一个事务去读一行，阻止其它事务获得相同数据集的排他锁。</li>
<li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其它事务获得相同数据集的共享锁和排他锁。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240803221030.png"
                     
                ></p>
<p><strong>SQL语句的行锁类型：</strong></p>
<table>
<thead>
<tr>
<th>SQL</th>
<th>行锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>insert ……</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>update ……</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>delete ……</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>select（正常）</td>
<td><strong>不加任何锁</strong></td>
<td></td>
</tr>
<tr>
<td>select……lock in share mode</td>
<td>共享锁</td>
<td>需要手动在select之后加lock in share mode</td>
</tr>
<tr>
<td>select……for update</td>
<td>排他锁</td>
<td>需要手动在select之后加for update</td>
</tr>
</tbody></table>
<blockquote>
<p>默认情况下，InnoDB在repeatable read事务隔离级别运行，InnoDB使用 next-key锁进行搜索和索引扫描，以防止幻读。</p>
<ol>
<li>针对唯一索引进行检验索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li>
<li>InnoDB的行锁是针对索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时<strong>就会升级为表锁</strong>。</li>
</ol>
</blockquote>
<h4 id="间隙锁-临键锁"><a href="#间隙锁-临键锁" class="headerlink" title="间隙锁&#x2F;临键锁"></a>间隙锁&#x2F;临键锁</h4><p>默认情况下，InnoDB 在 repeatable read 事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p>
<ol>
<li>索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。</li>
<li>索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁。</li>
<li>索引上的范围查询（唯一索引）–会访问到不满足条件的第一个值为止。</li>
</ol>
<blockquote>
<p><strong>注意：</strong></p>
<p>间隙锁唯一目的是防止其它事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p>
</blockquote>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul>
<li>全局锁<ul>
<li>对整个数据库实例加锁，加锁后整个实例就处于只读状态</li>
<li>性能较差，数据逻辑备份时使用</li>
</ul>
</li>
<li>表级锁<ul>
<li>操作锁住整张表，锁定颗粒度大，发生锁冲突的概率高</li>
<li>表锁，元数据锁，意向锁</li>
</ul>
</li>
<li>行级锁<ul>
<li>操作锁住对应的行数据，锁定颗粒度最小，发生锁冲突的概率最低</li>
<li>行锁，间隙锁，临键锁</li>
</ul>
</li>
</ul>
<h2 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h2><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804170348.png"
                      alt="image-20240804170347868"
                ></p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>MySQL5.5版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804170802.png"
                      alt="image-20240804170802270"
                ></p>
<h4 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804172201.png"
                      alt="image-20240804172200790"
                ></p>
<p><strong>Change Buffer的意义是什么？</strong><br>与聚焦索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了Change Buffer之后，我们可以在缓冲池中合并处理，减少磁盘IO。【<strong>针对的是非唯一的二级索引页</strong>】</p>
<p><strong>Buffer Pool 和 Change Buffer 的主要区别：</strong></p>
<ul>
<li>用途不同：Buffer Pool 用于缓存所有类型的数据页和索引页，而 Change Buffer 仅用于缓存非唯一二级索引的修改。</li>
<li>缓存内容：Buffer Pool 缓存的是实际的数据页和索引页，Change Buffer 缓存的是对非唯一二级索引的<strong>变更操作</strong>。</li>
<li>写入时机：Buffer Pool 中的脏页会在适当的时候异步写回磁盘，而 Change Buffer中的变更会在索引页被访问或后台定期合并时写入磁盘。</li>
</ul>
<p><strong>Change Buffer缓存的是对应的变更操作</strong></p>
<p>变更信息结构通常包括：</p>
<ol>
<li>索引页的Page ID：指示要修改的二级索引页在磁盘上的位置。</li>
<li>变更类型：插入（insert）、更新（update）、删除（delete）</li>
<li>索引键值：要变更的索引项的具体键值。</li>
<li>变更的具体数据：包括插入的新索引项、更新后的索引项或删除的索引项。</li>
</ol>
<blockquote>
<p>eg：<br>	假设我们有一个表<code>employees</code>，其非唯一二级索引<code>idx_salary</code>记录了员工的工资信息。<br>现在插入一条新记录：</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert into</span> employees (id,name,salary) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;Alice&#x27;</span>,<span class="number">5000</span>);</span><br></pre></td></tr></table></figure></div>

<p>这条插入操作在 Change Buffer 中的变更信息可能类似如下：</p>
<ul>
<li>Page ID：1234 （假设索引页ID为1234）</li>
<li>变更类型：Insert</li>
<li>索引键值：（salary&#x3D;5000，id&#x3D;1）</li>
<li>变更数据：将（salary&#x3D;5000，id&#x3D;1）插入索引页</li>
</ul>
<div class="code-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;page_id&quot;</span><span class="punctuation">:</span> <span class="number">1234</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;change_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;insert&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;index_key&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;salary&quot;</span><span class="punctuation">:</span> <span class="number">5000</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;change_data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;insert&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> (<span class="number">5000</span><span class="punctuation">,</span> <span class="number">1</span>)<span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>相关数据<span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page_id: 这是需要变更的二级索引页在磁盘上的位置。</span></span><br><span class="line"><span class="comment">// change_type: 表示变更的类型，在这个例子中是插入操作。</span></span><br><span class="line"><span class="comment">// index_key: 要变更的索引项的键值，表示salary和id。</span></span><br><span class="line"><span class="comment">// change_data: 具体的变更数据，这里是插入操作，将键值(salary=5000, id=1)插入索引页。</span></span><br></pre></td></tr></table></figure></div>

</blockquote>
<h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804190657.png"
                      alt="image-20240804190657195"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804190711.png"
                      alt="image-20240804190710823"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804190718.png"
                      alt="image-20240804190718542"
                ></p>
<h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804191845.png"
                      alt="image-20240804191845143"
                ></p>
<h3 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h3><h4 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h4><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<p><strong>特性</strong></p>
<ul>
<li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li>
<li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li>
<li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li>
<li>持久性（DUrability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804193258.png"
                      alt="image-20240804193257888"
                ></p>
<h4 id="redo-log-持久性"><a href="#redo-log-持久性" class="headerlink" title="redo log(持久性)"></a>redo log(持久性)</h4><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。<br>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805155500.png"
                     
                ></p>
<h4 id="undo-log-原子性"><a href="#undo-log-原子性" class="headerlink" title="undo log(原子性)"></a>undo log(原子性)</h4><p>回滚日志，用于记录数据被修改前的信息，作用包含两个：<strong>提供回滚</strong>和<strong>MVCC(多版本并发控制)</strong>。<br>undo log 和 redo log记录物理日志不一样，它记录的是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行 roll back 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。</p>
<ul>
<li>undo log的销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</li>
<li>undo log的存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 roll back segment 回滚段中，内部包含1024个undo log segment。</li>
</ul>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><h5 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h5><ul>
<li><p>当前读</p>
<p>读取的是记录的最新版本，读取时还要保证其它并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：<strong>select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读。</strong></p>
</li>
<li><p>快照读</p>
<p><strong>简单的select（不加锁）就是快照读</strong>，快照读读取的是记录数据的可见版本，有可能是历史数据。不加锁，是非阻塞读。</p>
<ul>
<li>Read Committed：每次select，都生成一个快照读。</li>
<li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li>
<li>Serializable：快照读会退化为当前读。</li>
</ul>
</li>
<li><p>MVCC</p>
<p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p>
</li>
</ul>
<h4 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h4><table>
<thead>
<tr>
<th>隐藏字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>DB_TRX_ID</td>
<td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</td>
</tr>
<tr>
<td>DB_ROLL_PIR</td>
<td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。</td>
</tr>
<tr>
<td>DB_ROW_ID</td>
<td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</td>
</tr>
</tbody></table>
<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。<br>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。<br>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p>
<ul>
<li>undo log 版本链</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804205208.png"
                     
                ></p>
<h4 id="readView"><a href="#readView" class="headerlink" title="readView"></a>readView</h4><p>readView（读视图）是 <strong>快照读</strong> SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p>
<p>readView中包含了四个核心字段：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>m_ids</td>
<td>当前活跃的事务ID集合（所有未提交的事务集合）</td>
</tr>
<tr>
<td>min_trx_id</td>
<td>最小活跃事务ID</td>
</tr>
<tr>
<td>max_trx_id</td>
<td>预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td>
</tr>
<tr>
<td>creator_trx_id</td>
<td>readView创建者的事务ID</td>
</tr>
</tbody></table>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804210219.png"
                      alt="image-20240804210219378"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804211326.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240804211435.png"
                      alt="image-20240804211434665"
                ></p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志是MySQL中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。</p>
<p>该日志是默认开启的，默认存放目录 &#x2F;var&#x2F;log&#x2F;，默认的日志文件名为 mysqld.log 。查看日志位置的SQL语句：</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_error%&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><ul>
<li><p>介绍</p>
<p>二进制日志（BINLOG）记录了所有的DDL（数据定义语言）语句和DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW）语句。</p>
<p>作用：</p>
<pre><code>1. 灾难时的数据恢复；
1. MySQL的主从复制，在MySQL8版本中，默认二进制日志是开启着的，涉及到的参数如下：
</code></pre>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805171448.png"
                      alt="image-20240805171447473"
                ></p>
</li>
<li><p>日志格式</p>
<table>
<thead>
<tr>
<th>日志格式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>STATEMENT</td>
<td>基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中。</td>
</tr>
<tr>
<td>ROW</td>
<td>基于行的日志记录，记录的是每一行的数据变更。（默认）</td>
</tr>
<tr>
<td>MIXED</td>
<td>混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会自动切换为ROW进行记录。</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_format%&#x27;</span>; <span class="comment">-- 查看</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span><span class="operator">/</span>session binlog_format <span class="operator">=</span> <span class="string">&#x27;ROW&#x27;</span><span class="operator">/</span><span class="string">&#x27;STATEMENT&#x27;</span><span class="operator">/</span>……;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>日志查看</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805173557.png"
                      alt="image-20240805173557201"
                ></p>
</li>
</ul>
<p><strong>ROW格式下查看的日志格式：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805174014.png"
                      alt="image-20240805174014623"
                ></p>
<p><strong>STATEMENT格式下查看的日志格式：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805174134.png"
                      alt="image-20240805174134528"
                ></p>
<ul>
<li><p>日志删除</p>
<p>对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量的磁盘空间。可以通过以下几种方式清理日志：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>reset master</td>
<td>删除全部binlog日志，删除之后，日志编号将从binlog.000001重新开始。</td>
</tr>
<tr>
<td>purge master logs to ‘binlog.******‘</td>
<td>删除 *<em>***</em>* 编号之前的所有日志，不包含该日志。</td>
</tr>
<tr>
<td>purge master logs before ‘yyyy-mm-dd hh:mi:ss’</td>
<td>删除日志为”yyyy-mm-dd hh:mi:ss”之前产生的所有日志，这里的hh是24小时制的。</td>
</tr>
</tbody></table>
<p>也可以在mysql的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除。</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_expire_logs_seconds%&#x27;</span>; <span class="comment">-- 默认设置是30天</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。默认情况下，查询日志是未开启的。如果需要开启查询日志，可以设置以下配置：</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 查看查询日志的开启状态</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805181122.png"
                      alt="image-20240805181121871"
                ></p>
<p>修改MySQL的配置文件 &#x2F;etc&#x2F;my.cnf 文件，添加如下内容：</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 该选项用来开启查询日志，可选值：<span class="number">0</span>或者<span class="number">1</span>；<span class="number">0</span>代表关闭，<span class="number">1</span>代表开启</span><br><span class="line">general_log <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"># 设置日志的文件名，如果没有指定，默认的文件名为 host_name.log</span><br><span class="line">general_log_file <span class="operator">=</span> mysql_query.log</span><br></pre></td></tr></table></figure></div>

<p>文件内容示图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805181610.png"
                      alt="image-20240805181609856"
                ></p>
<h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的SQL语句的日志，默认未开启。long_query_time 默认为10秒，最小为0，精度可以准确到微妙。</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 在<span class="operator">/</span>etc<span class="operator">/</span>my.cnf配置文件中添加如下内容</span><br><span class="line"># 开启慢查询日志</span><br><span class="line">slow_query_log <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"># 执行时间参数</span><br><span class="line">long_query_time <span class="operator">=</span> <span class="number">2</span> <span class="comment">-- 设置成2s</span></span><br></pre></td></tr></table></figure></div>

<p>默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以使用 log_slow_admin_statements 和log_queries_not_using_indexes 更改此行为。</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 记录执行较慢的管理语句</span><br><span class="line">log_slow_admin_statements <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">#记录执行较慢的未使用索引的语句</span><br><span class="line">log_queries_not_using_indexes <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<p>查询示图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805183430.png"
                      alt="image-20240805183430193"
                ></p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>主从复制是指将主数据库的DDL和DML操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p>
<p>MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其它从服务器的主库，实现链状复制。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805190532.png"
                      alt="image-20240805190531871"
                ></p>
<blockquote>
<p>MySQL 的主从复制（Replication）是一种用于将数据从一个 MySQL 服务器（主服务器）复制到一个或多个 MySQL 服务器（从服务器）的机制。主从复制的主体是<strong>整个服务器</strong>，而不是单独的数据库或表。</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805190731.png"
                      alt="image-20240805190731673"
                ></p>
<h3 id="服务器准备"><a href="#服务器准备" class="headerlink" title="服务器准备"></a>服务器准备</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805191623.png"
                      alt="image-20240805191623628"
                ></p>
<h3 id="主库配置"><a href="#主库配置" class="headerlink" title="主库配置"></a>主库配置</h3><ol>
<li>修改配置文件 &#x2F;etc&#x2F;my.cnf</li>
</ol>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># mysql服务ID，保证整个集群环境中唯一，取值范围：<span class="number">1</span> <span class="operator">~</span> <span class="number">2</span><span class="operator">^</span><span class="number">32</span> <span class="number">-1</span>,默认值为<span class="number">1</span></span><br><span class="line">server<span class="operator">-</span>id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"># 是否只读，<span class="number">1</span>代表只读，<span class="number">0</span>代表读写</span><br><span class="line">read<span class="operator">-</span><span class="keyword">only</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"># 忽略的数据，指不需要同步的数据库</span><br><span class="line"># binlog<span class="operator">-</span>ignore<span class="operator">-</span>db <span class="operator">=</span> mysql</span><br><span class="line"># 指定同步的数据库</span><br><span class="line">#binlog<span class="operator">-</span>do<span class="operator">-</span>db<span class="operator">=</span>db01</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>重启MySQL服务器</li>
</ol>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld <span class="comment">-- 针对Linux而言</span></span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>登录MySQL，创建远程连接的账号，并赋予主从复制的权限</li>
</ol>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建itcast用户，并设置密码，该用户可以在任意主机连接该MySQL服务</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;%&#x27;</span> indentified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;Root@123456&#x27;</span>;</span><br><span class="line"># 为<span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;%&#x27;</span>用户分配主从复制权限</span><br><span class="line"><span class="keyword">grant</span> replication slave <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>通过指令，查看二进制日志坐标</li>
</ol>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure></div>

<p>字段含义说明：</p>
<ul>
<li>file：从哪个日志文件开始推送日志文件</li>
<li>position：从哪个位置开始推送日志</li>
<li>binlog_ignore_db：指定不需要同步的数据库</li>
</ul>
<h3 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h3><ol>
<li>修改配置文件 &#x2F;etc&#x2F;my.cnf</li>
</ol>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># mysql服务ID，保证在整个集群环境中唯一，取值范围：<span class="number">1</span> <span class="operator">~</span> <span class="number">2</span><span class="operator">^</span><span class="number">32</span> <span class="number">-1</span>，和主库不一样即可</span><br><span class="line">server<span class="operator">-</span>id <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">#是否只读，<span class="number">1</span>代表只读，<span class="number">0</span>代表读写</span><br><span class="line">read<span class="operator">-</span><span class="keyword">only</span> <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>重启MySQL服务</li>
</ol>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld; <span class="comment">-- 针对Linux而言</span></span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>登录MySQL，设置主库配置</li>
</ol>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">8.0</span><span class="number">.23</span>之后的语法</span><br><span class="line">change replication source <span class="keyword">to</span> source_host<span class="operator">=</span><span class="string">&#x27;xxx.xxx&#x27;</span>, source_user<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>,source_password<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>,source_log_file<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>,source_log_pos<span class="operator">=</span>xxx;</span><br><span class="line"></span><br><span class="line"># <span class="number">8.0</span><span class="number">.23</span>之前的语法</span><br><span class="line">change master source <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;xxx.xxx&#x27;</span>, master_user<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>,master_log_pos<span class="operator">=</span>xxx;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805194728.png"
                      alt="image-20240805194727987"
                ></p>
<ol start="4">
<li>开启同步操作</li>
</ol>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> replica; # <span class="number">8.0</span><span class="number">.22</span>之后</span><br><span class="line"><span class="keyword">start</span> slave; # <span class="number">8.0</span><span class="number">.22</span>之前</span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li>查看主从同步状态</li>
</ol>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> replica status; # <span class="number">8.0</span><span class="number">.22</span>之后</span><br><span class="line"><span class="keyword">show</span> slave status; # <span class="number">8.0</span><span class="number">.22</span>之前</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240805195127.png"
                      alt="image-20240805195127196"
                ></p>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807193841.png"
                      alt="image-20240807193834457"
                ></p>
<h3 id="拆分方式"><a href="#拆分方式" class="headerlink" title="拆分方式"></a>拆分方式</h3><h4 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807184355.png"
                     
                ></p>
<h4 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807184414.png"
                     
                ></p>
<h4 id="实现技术"><a href="#实现技术" class="headerlink" title="实现技术"></a>实现技术</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807184447.png"
                     
                ></p>
<h3 id="Mycat"><a href="#Mycat" class="headerlink" title="Mycat"></a>Mycat</h3><h4 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h4><p>Mycat是开源的、活跃的，基于Java语言编写的MySQL<strong>数据库中间件</strong>。可以像使用MySQL一样来使用Mycat，对于开发人员来说根本感觉不到Mycat的存在。【Mycat使用了MySQL的伪装协议】</p>
<p>优势：</p>
<ol>
<li>性能可靠稳定</li>
<li>强大的技术团队</li>
<li>体系完善</li>
<li>社区活跃</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807194522.png"
                      alt="image-20240807194522163"
                ></p>
<p>结构示图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807194728.png"
                      alt="image-20240807194728336"
                ></p>
<h4 id="启动与连接-1"><a href="#启动与连接-1" class="headerlink" title="启动与连接"></a>启动与连接</h4><ul>
<li><p>启动服务</p>
<p>切换到Mycat的安装目录，执行如下指令，启动Mycat：</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"># 启动</span><br><span class="line">bin<span class="operator">/</span>mycat <span class="keyword">start</span></span><br><span class="line"># 停止</span><br><span class="line">bin<span class="operator">/</span>mycat stop</span><br></pre></td></tr></table></figure></div>

<p><strong>Mycat启动之后，占用端口号 8066</strong></p>
</li>
<li><p>连接Mycat</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h 主机号 <span class="operator">-</span>P <span class="number">8066</span>[端口号] <span class="operator">-</span>u 用户名 <span class="operator">-</span>p;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><h5 id="schema-xml"><a href="#schema-xml" class="headerlink" title="schema.xml"></a>schema.xml</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807201109.png"
                      alt="image-20240807201109146"
                ></p>
<p>schema.xml作为Mycat中最重要的配置文件之一，涵盖了Mycat的逻辑库、逻辑表、分片规则、分片节点及数据源的配置。</p>
<p>主要包含以下三组标签：</p>
<ol>
<li>schema标签</li>
<li>datanode标签</li>
<li>datahost标签</li>
</ol>
<p><em><strong>schema标签</strong></em></p>
<p>schema标签用于定义Mycat实例中的逻辑库，一个Mycat实例中，可以有多个逻辑库，可以通过schema标签来划分不同的数据库。</p>
<p>Mycat中逻辑库的概念，等同于MySQL中的database概念，需要操作某个逻辑库下的表时，也需要切换逻辑库（use xxx）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807201702.png"
                      alt="image-20240807201702402"
                ></p>
<p>核心属性：</p>
<ul>
<li>**name：**指定自定义的逻辑库库名</li>
<li>**checkSQLschema：**在SQL语句操作时指定了数据库名，执行时是否自动去除；true：自动去除，false：不自动去除</li>
<li>**sqlMaxLimit：**如果未指定limit进行查询，列表查询模式最多查询多少条记录</li>
</ul>
<p><em><strong>schema标签(table)</strong></em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807203508.png"
                      alt="image-20240807203508570"
                ></p>
<p>table标签定义了Mycat中数据库schema下的逻辑表，所有需要拆分的表都需要在table标签中的定义。</p>
<ul>
<li>**name：**自定义逻辑表名，在该逻辑库下唯一</li>
<li>**dataNode：**定义逻辑表所属的dataNode，该属性需要与dataNode标签中name对应；多个dataNode逗号分隔</li>
<li>**rule：**分片规则的名字，分片规则名字是在<code>rule.xml</code>中定义的</li>
<li>**primaryKey：**逻辑表对应真实表的主键</li>
<li>**type：**逻辑表的类型，目前逻辑表只有全局表和普通表，如果未配置，就是普通表；全局表，配置为global</li>
</ul>
<p><em><strong>dataNode标签</strong></em></p>
<p>dataNode标签中定义了Mycat中的数据节点，也就是我们通常说的数据分片。一个dataNode标签就是一个独立的数据节点。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807205018.png"
                      alt="image-20240807205018175"
                ></p>
<p>核心属性：</p>
<ul>
<li>**name：**定义数据节点名称</li>
<li>**dataHost：**数据库实例主机名称，引用自 dataHost 标签中的name属性</li>
<li>**database：**定义分片所属数据库</li>
</ul>
<p><em><strong>dataHost标签</strong></em></p>
<p>该标签在Mycat逻辑库中作为底层标签存在，直接定义了具体的数据库实例、读写分离、心跳语句。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807205450.png"
                      alt="image-20240807205450186"
                ></p>
<p>核心属性：</p>
<ul>
<li>**name：**唯一标识，供上层标签使用</li>
<li>**maxCon&#x2F;minCon：**最大连接数&#x2F;最小连接数</li>
<li>**balance：**负载均衡策略，取值0，1，2，3</li>
<li>**writeType：**写操作分发方式（0：写操作转发到第一个writeHost，第一个挂了，切换到第二个；1：写操作随机分发到配置的writeHost）</li>
<li>**dbDriver：**数据库驱动，支持native、jdbc</li>
</ul>
<p><em>小结：</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807210444.png"
                      alt="image-20240807210444239"
                ></p>
<h5 id="rule-xml"><a href="#rule-xml" class="headerlink" title="rule.xml"></a>rule.xml</h5><p>rule.xml中定义所有拆分表的规则，在使用过程中可以灵活的使用分片算法，或者对同一个分片算法使用不同的参数，它让分片过程可配置化。主要包含两类标签：tableRule、Function。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807211807.png"
                      alt="image-20240807211807001"
                ></p>
<h5 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h5><p>server.xml配置文件包含了Mycat的系统配置信息，主要有两个重要的标签：system、user。</p>
<p><em><strong>system标签</strong></em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807212245.png"
                      alt="image-20240807212245198"
                ></p>
<p>对应的系统配置项及其含义参考下列表格：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>charset</td>
<td>utf8</td>
<td>设置Mycat的字符集,  字符集需要与MySQL的字符集保持一致</td>
</tr>
<tr>
<td>nonePasswordLogin</td>
<td>0,1</td>
<td>0为需要密码登陆、1为不需要密码登陆  ,默认为0，设置为1则需要指定默认账户</td>
</tr>
<tr>
<td>useHandshakeV10</td>
<td>0,1</td>
<td>使用该选项主要的目的是为了能够兼容高版本的jdbc驱动,  是否采用HandshakeV10Packet来与client进行通信, 1:是, 0:否</td>
</tr>
<tr>
<td>useSqlStat</td>
<td>0,1</td>
<td>开启SQL实时统计,  1 为开启 , 0 为关闭 ; 开启之后, MyCat会自动统计SQL语句的执行情况 ; mysql -h 127.0.0.1 -P 9066 -u  root -p 查看MyCat执行的SQL, 执行效率比较低的SQL , SQL的整体执行情况、读写比例等 ; show @@sql ; show  @@sql.slow ; show @@sql.sum ;</td>
</tr>
<tr>
<td>useGlobleTableCheck</td>
<td>0,1</td>
<td>是否开启全局表的一致性检测。1为开启  ，0为关闭 。</td>
</tr>
<tr>
<td>sqlExecuteTimeout</td>
<td>1000</td>
<td>SQL语句执行的超时时间  , 单位为 s ;</td>
</tr>
<tr>
<td>sequnceHandlerType</td>
<td>0,1,2</td>
<td>用来指定Mycat全局序列类型，0  为本地文件，1 为数据库方式，2 为时间戳列方式，默认使用本地文件方式，文件方式主要用于测试</td>
</tr>
<tr>
<td>sequnceHandlerPattern</td>
<td>正则表达式</td>
<td>必须带有MYCATSEQ或者  mycatseq进入序列匹配流程 注意MYCATSEQ_有空格的情况</td>
</tr>
<tr>
<td>subqueryRelationshipCheck</td>
<td>true,false</td>
<td>子查询中存在关联查询的情况下,检查关联字段中是否有分片字段  .默认 false</td>
</tr>
<tr>
<td>useCompression</td>
<td>0,1</td>
<td>开启mysql压缩协议  , 0 : 关闭, 1 : 开启</td>
</tr>
<tr>
<td>fakeMySQLVersion</td>
<td>5.5,5.6</td>
<td>设置模拟的MySQL版本号</td>
</tr>
<tr>
<td>defaultSqlParser</td>
<td></td>
<td>由于MyCat的最初版本使用了FoundationDB的SQL解析器,  在MyCat1.3后增加了Druid解析器, 所以要设置defaultSqlParser属性来指定默认的解析器; 解析器有两个 : druidparser  和 fdbparser, 在MyCat1.4之后,默认是druidparser, fdbparser已经废除了</td>
</tr>
<tr>
<td>processors</td>
<td>1,2….</td>
<td>指定系统可用的线程数量,  默认值为CPU核心 x 每个核心运行线程数量; processors 会影响processorBufferPool,  processorBufferLocalPercent, processorExecutor属性, 所有, 在性能调优时,  可以适当地修改processors值</td>
</tr>
<tr>
<td>processorBufferChunk</td>
<td></td>
<td>指定每次分配Socket  Direct Buffer默认值为4096字节, 也会影响BufferPool长度, 如果一次性获取字节过多而导致buffer不够用, 则会出现警告,  可以调大该值</td>
</tr>
<tr>
<td>processorExecutor</td>
<td></td>
<td>指定NIOProcessor上共享  businessExecutor固定线程池的大小; MyCat把异步任务交给 businessExecutor线程池中,  在新版本的MyCat中这个连接池使用频次不高, 可以适当地把该值调小</td>
</tr>
<tr>
<td>packetHeaderSize</td>
<td></td>
<td>指定MySQL协议中的报文头长度,  默认4个字节</td>
</tr>
<tr>
<td>maxPacketSize</td>
<td></td>
<td>指定MySQL协议可以携带的数据最大大小,  默认值为16M</td>
</tr>
<tr>
<td>idleTimeout</td>
<td>30</td>
<td>指定连接的空闲时间的超时长度;如果超时,将关闭资源并回收,  默认30分钟</td>
</tr>
<tr>
<td>txIsolation</td>
<td>1,2,3,4</td>
<td>初始化前端连接的事务隔离级别,默认为  REPEATED_READ , 对应数字为3 READ_UNCOMMITED&#x3D;1; READ_COMMITTED&#x3D;2; REPEATED_READ&#x3D;3;  SERIALIZABLE&#x3D;4;</td>
</tr>
<tr>
<td>sqlExecuteTimeout</td>
<td>300</td>
<td>执行SQL的超时时间,  如果SQL语句执行超时,将关闭连接; 默认300秒;</td>
</tr>
<tr>
<td>serverPort</td>
<td>8066</td>
<td>定义MyCat的使用端口,  默认8066</td>
</tr>
<tr>
<td>managerPort</td>
<td>9066</td>
<td>定义MyCat的管理端口,  默认9066</td>
</tr>
</tbody></table>
<p><em><strong>user标签</strong></em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807212422.png"
                      alt="image-20240807212421991"
                ></p>
<h4 id="分片规则"><a href="#分片规则" class="headerlink" title="分片规则"></a>分片规则</h4><h5 id="范围分片"><a href="#范围分片" class="headerlink" title="范围分片"></a>范围分片</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807220135.png"
                      alt="image-20240807220135577"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807220149.png"
                      alt="image-20240807220149320"
                ></p>
<h5 id="去模分片"><a href="#去模分片" class="headerlink" title="去模分片"></a>去模分片</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807220236.png"
                      alt="image-20240807220236397"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807220250.png"
                      alt="image-20240807220249980"
                ></p>
<h5 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807220807.png"
                      alt="image-20240807220807274"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807220818.png"
                      alt="image-20240807220818067"
                ></p>
<h5 id="枚举分片"><a href="#枚举分片" class="headerlink" title="枚举分片"></a>枚举分片</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807221140.png"
                      alt="image-20240807221140275"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807221240.png"
                      alt="image-20240807221240239"
                ></p>
<h5 id="应用指定"><a href="#应用指定" class="headerlink" title="应用指定"></a>应用指定</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807223441.png"
                      alt="image-20240807223440974"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807223453.png"
                      alt="image-20240807223453361"
                ></p>
<h5 id="固定分片hash算法"><a href="#固定分片hash算法" class="headerlink" title="固定分片hash算法"></a>固定分片hash算法</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807223530.png"
                      alt="image-20240807223530065"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807223543.png"
                      alt="image-20240807223542684"
                ></p>
<h5 id="字符串hash解析"><a href="#字符串hash解析" class="headerlink" title="字符串hash解析"></a>字符串hash解析</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807224800.png"
                      alt="image-20240807224800100"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807224813.png"
                      alt="image-20240807224813189"
                ></p>
<h5 id="按（天）日期分片"><a href="#按（天）日期分片" class="headerlink" title="按（天）日期分片"></a>按（天）日期分片</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807224949.png"
                      alt="image-20240807224949404"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807225009.png"
                      alt="image-20240807225008912"
                ></p>
<h5 id="自然月"><a href="#自然月" class="headerlink" title="自然月"></a>自然月</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807225025.png"
                      alt="image-20240807225024836"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240807225048.png"
                      alt="image-20240807225048044"
                ></p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808100902.png"
                      alt="image-20240808100854948"
                ></p>
<h4 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808101218.png"
                      alt="image-20240808101217635"
                ></p>
<h4 id="管理工具"><a href="#管理工具" class="headerlink" title="管理工具"></a>管理工具</h4><p><strong>Mycat-eye</strong></p>
<p>Mycat-web（Mycat-eye）是对Mycat-server提供监控服务，功能不局限于对Mycat-server使用。他通过JDBC连接对Mycat、MySQL监控，监控远程服务（目前仅局限于Linux系统）的CPU、内存、网络、磁盘。</p>
<p>Mycat-eye运行过程中需要依赖zookeeper。</p>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>读写分离，简单地说就是把数据库的读和写操作分开，以对应不同的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。</p>
<p>通过Mycat即可轻易实现上述功能，不仅可以支持MySQL，也可以支持Oracle和SQL Server。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808111617.png"
                      alt="image-20240808111616641"
                ></p>
<h3 id="一主一从读写分离"><a href="#一主一从读写分离" class="headerlink" title="一主一从读写分离"></a>一主一从读写分离</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808111701.png"
                      alt="image-20240808111701174"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808111709.png"
                      alt="image-20240808111709697"
                ></p>
<h3 id="双主双从读写分离"><a href="#双主双从读写分离" class="headerlink" title="双主双从读写分离"></a>双主双从读写分离</h3><ul>
<li>双主双重介绍</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808111956.png"
                      alt="image-20240808111956237"
                ></p>
<ul>
<li>双主双重的搭建</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808112637.png"
                      alt="image-20240808112636652"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808112648.png"
                      alt="image-20240808112648091"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808112655.png"
                      alt="image-20240808112654844"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808112700.png"
                      alt="image-20240808112659878"
                ></p>
<ul>
<li>双主双从的读写分离</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808113017.png"
                      alt="image-20240808113016811"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240808113025.png"
                      alt="image-20240808113025031"
                ></p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="单引号-vs-双引号"><a href="#单引号-vs-双引号" class="headerlink" title="单引号 vs. 双引号"></a>单引号 vs. 双引号</h3><p>在 SQL 中，字符串通常是用单引号 (<code>&#39;</code>) 包围起来的，这是标准的 SQL 规范。然而，不同的数据库管理系统（如 MySQL、PostgreSQL、SQL Server 等）可能有各自的一些特殊规则和扩展，允许在某些情况下使用双引号，但通常是用于其他目的。以下是一些常见的情况：</p>
<ol>
<li><p><strong>标准 SQL</strong>：</p>
<ul>
<li>字符串必须用单引号包围。例如：<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><strong>双引号的用途</strong>：</p>
<ul>
<li>在标准 SQL 中，双引号 (<code>&quot;</code>) 通常用于标识符（如表名、列名）而非字符串。例如：<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &quot;column_name&quot; <span class="keyword">FROM</span> &quot;table_name&quot;;</span><br></pre></td></tr></table></figure></div></li>
<li>双引号可以用于表示区分大小写的标识符（例如 PostgreSQL 中的表或列名）。</li>
</ul>
</li>
<li><p><strong>使用双引号表示字符串</strong>：</p>
<ul>
<li>某些数据库（如 MySQL）可能允许你在 SQL 模式中启用 <code>ANSI_QUOTES</code> 选项，从而将双引号用于字符串。这种情况下，双引号和单引号的作用类似，但这种用法并不符合标准 SQL 规范：<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION sql_mode <span class="operator">=</span> <span class="string">&#x27;ANSI_QUOTES&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;John&quot;;  <span class="comment">-- 这种用法在启用了 ANSI_QUOTES 模式后有效</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><strong>数据库特定的字符串分隔符</strong>：</p>
<ul>
<li>某些数据库还支持自定义分隔符，比如 PostgreSQL 支持用 <code>E&#39;...&#39;</code> 处理带有转义字符的字符串，或用 <code>$$... $$</code> 表示大文本块（如函数体）。</li>
</ul>
</li>
</ol>
<p>因此，在标准 SQL 和大多数数据库的默认配置下，字符串应当使用单引号包围。如果需要使用双引号，必须确认数据库的特定配置或扩展支持这一功能。一般情况下，为了确保跨数据库的兼容性，使用单引号是最安全的做法。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket</title>
    <url>/2024/07/16/Websocket/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="1-1-什么是WebSocket"><a href="#1-1-什么是WebSocket" class="headerlink" title="1.1 什么是WebSocket"></a>1.1 什么是WebSocket</h3><p>WebSocket 是一种协议，用于在Web应用程序和服务器之间建立 <code>实时</code>、<code>双向</code>、<code>持久化</code> 的通信连接。它通过一个单一的 <code>TCP</code>连接提供了持久化连接，这使得Web应用程序可以更加实时地传递数据。WebSocket 协议最初是由W3C开发，并于2011年成为标准。</p>
<blockquote>
<p><strong>补充说明：</strong></p>
<p>WebSocket 是通过 <strong>HTTP 协议的升级机制</strong> 来建立的，但连接一旦建立，就脱离了 HTTP 协议，成为纯粹的 TCP 连接，这种持久化连接减少了因不断建立和关闭连接所带来的延迟。</p>
</blockquote>
<h3 id="1-2-WebSocket的优劣势"><a href="#1-2-WebSocket的优劣势" class="headerlink" title="1.2 WebSocket的优劣势"></a>1.2 WebSocket的优劣势</h3><ul>
<li><strong>优势：</strong><ul>
<li>**实时性：**由于WebSocket的持久化连接，它可以实现实时的数据传输，避免了Web应用程序需要不断地发起请求以获取最新数据的情况。特别适合实时更新的应用场景，如聊天应用、股票行情和在线游戏等。</li>
<li>**双向通信：**WebSocket协议支持双向通信，这意味着服务器可以主动向客户端发起数据，而不需要客户端发送请求。这种双向通信是<code>全双工</code>的，允许服务器和客户端在任意时间互相发送消息。</li>
<li>**减少网络负载：**由于WebSocket的持久化连接，它可以减少HTTP请求的次数，从而减少网络的负载。 WebSocket 仅在最初建立连接时会有一次握手请求，之后的数据传输都通过该连接完成，避免了频繁的请求开销。</li>
</ul>
</li>
<li><strong>劣势：</strong><ul>
<li>**需要浏览器和服务器都支持：**WebSocket是一种相对新的技术，需要浏览器和服务器都支持。一些旧的浏览器和服务器可能不支持WebSocket。【目前的主流浏览器和服务器都已支持】</li>
<li>**需要额外的开销：**WebSocket需要在服务器上维护长时间的连接，对于每个客户端都要保留一定的资源，则需要额外的开销，包括内存和CPU。特别是对于大规模连接的场景，可能需要较高的硬件资源支持。</li>
<li>**安全问题：**由于WebSocket允许服务器主动向客户端发送数据，可能会存在安全问题。服务器必须保证只向合法的客户端发送数据。因为WebSocket 在建立连接后不再通过 HTTP 头部进行每次身份验证，因此服务器在实现中需要确保连接的安全性，例如通过加密连接（wss:&#x2F;&#x2F;）以及身份验证、IP 过滤等方法。</li>
</ul>
</li>
</ul>
<h2 id="WebSocket的基本概念"><a href="#WebSocket的基本概念" class="headerlink" title="WebSocket的基本概念"></a>WebSocket的基本概念</h2><h3 id="2-1-WebSocket的协议"><a href="#2-1-WebSocket的协议" class="headerlink" title="2.1 WebSocket的协议"></a>2.1 WebSocket的协议</h3><p><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket#%E5%8F%82%E8%A7%81" >WebSocket<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 是一种基于TCP的协议，用于在客户端和服务端之间建立持久连接，并且可以在这个连接上实时地交换数据。WebSocket协议有自己的握手过程，用于建立连接，也有自己的数据传输格式。</p>
<ul>
<li><strong>握手过程：<strong>WebSocket的连接通过一个HTTP升级请求启动。客户端发送带有 <code>Upgrade</code> 头的HTTP请求，服务器接收到请求后返回状态码 <code>101 Switching Protocols</code> 来确定协议升级成功并切换到 WebSocket 协议。握手过程中，客户端和服务器会协商</strong>协议版本、支持的子协议、拓展选项等</strong>。一旦握手完成，连接将保持打开状态，不再使用 <code>HTTP</code> 请求-响应模式。</li>
<li>**数据帧结构：**WebSocket定义了独特的数据帧结构，用于更高效地携带数据和减少通信开销。数据帧中包含标记位，用于表示数据是否分片、数据的类型（文本或二进制）等。数据帧的结构能够适应大数据的流式传输需求。</li>
<li>**双向通信：**WebSocket协议使用全双工通信，支持客户端和服务器在任意时间向对方发送数据，而不需要等待对方的请求。这种双向通信允许实时数据的推送和快速响应，是WebSocket协议的一大优势。</li>
<li><strong>支持二进制和文本数据</strong>：WebSocket支持文本和二进制数据的传输，可以根据实际应用需求在两者之间自由转换。这使得WebSocket能够适应更多场景。</li>
</ul>
<p>总之，WebSocket协议是一种可靠、高效、双向且持久的通信协议，特别适用于需要实时通信的Web应用，如在线游戏、股票行情、实时聊天和在线客服系统等场景。</p>
<h3 id="2-2-WebSocket-的生命周期"><a href="#2-2-WebSocket-的生命周期" class="headerlink" title="2.2 WebSocket 的生命周期"></a>2.2 WebSocket 的生命周期</h3><p>WebSocket 生命周期描述了 WebSocket 连接从创建到关闭的过程，包括以下四个主要阶段：</p>
<ul>
<li><p><strong>连接建立阶段（Connection Establishment）</strong>：客户端发送 WebSocket 握手请求，服务器接收请求并发送握手响应。如果握手成功，则建立 WebSocket 连接，并切换到 TCP 长连接状态。此过程通过 <code>Upgrade</code> 请求头实现 HTTP 到 WebSocket 的协议转换。</p>
</li>
<li><p><strong>连接开放阶段（Connection Open）</strong>：握手完成后，WebSocket 连接进入开放状态。此时，客户端和服务器之间的连接已建立并可以互相发送数据。进入开放状态时，会触发 <code>onopen</code> 事件（通常在客户端的 WebSocket 实例上触发），以指示连接已准备好进行通信。</p>
</li>
<li><p><strong>连接关闭阶段（Connection Closing）</strong>：连接关闭可以由客户端或服务器发起，通过发送一个关闭帧（Close Frame）来通知对方准备关闭连接。关闭帧中可包含关闭原因的代码和描述，提供了关闭连接的上下文。</p>
</li>
<li><p><strong>连接关闭完成阶段（Connection Closed）</strong>：当关闭过程完成时，WebSocket 连接彻底关闭，客户端和服务器之间的交互终止。在客户端上会触发 <code>onclose</code> 事件，通常用于进行清理操作和资源释放。</p>
</li>
</ul>
<blockquote>
<p><strong>补充说明：</strong></p>
<p>WebSocket 连接可能在任何时候意外关闭，例如因网络问题、服务器崩溃或超时而断开。因此，客户端和服务器需要监听 <code>onclose</code> 和 <code>onerror</code> 事件，并在连接断开时执行相应的恢复或重连逻辑，以保证应用的可靠性和稳定性。</p>
</blockquote>
<p>HTTP和WebSocket的生命周期图：</p>
<p>​                                     <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411091251133.png"
                      alt="image-20221222184340172" style="zoom:80%;" 
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411091251303.png"
                      style="zoom:80%;" 
                ></p>
<blockquote>
<p><strong>WebSocket和HTTP协议的主要区别：</strong></p>
<ul>
<li>WebSocket通过持久化的连接实现了双向实时通信</li>
<li>HTTP是基于请求&#x2F;响应的模型，适用于较少的交互</li>
</ul>
</blockquote>
<h3 id="2-3-WebSocket的消息格式"><a href="#2-3-WebSocket的消息格式" class="headerlink" title="2.3 WebSocket的消息格式"></a>2.3 WebSocket的消息格式</h3><ol>
<li><strong>消息头：</strong><ul>
<li>**FIN：**一个 1 位的标志位，指示消息是否是完善的。值为 1 表示这是一条完整的消息，值为 0 表示该消息只是分段消息的一部分。</li>
<li>**RSV1、RSV2、RSV3：**这三个位目前未使用，通常为0，它们预留用于将来的拓展。</li>
<li>**Opcode：**表示消息的类型，常见的值有：<ul>
<li><code>0x1</code>：表示文本消息（UTF-8编码）</li>
<li><code>0x2</code>：表示二进制消息（图片或者文件数据等）</li>
<li><code>0x8</code>：表示连接关闭消息</li>
<li><code>0x9</code>：表示Ping消息</li>
<li><code>0xA</code>：表示Pong消息</li>
</ul>
</li>
<li><strong>Mask</strong>：一个 1 位的标志位，指示消息是否已经经过掩码处理。客户端发送的消息总是需要掩码，而服务器接收消息时不需要</li>
<li>**Payload length：**表示消息体的长度。这个字段会根据消息的长度变化，可能是7位、16位或64位长度字段，具体取决于消息体的大小</li>
<li>**Masking key：**当 <code>Mask</code>为 1 时，这个 32 位的字段将用于对消息体进行掩码加密。服务器使用该密钥来解码消息体，仅在消息需要解密时出现</li>
</ul>
</li>
<li><strong>消息体：</strong><ul>
<li>这部分包含了实际的传输数据，可以是文本（例如UTF-8编码的字符串）或二进制数据（如图像、视频或文件）</li>
</ul>
</li>
</ol>
<h3 id="2-4-WebScoket的API"><a href="#2-4-WebScoket的API" class="headerlink" title="2.4 WebScoket的API"></a>2.4 WebScoket的API</h3><p>WebSocket API 是用于在 Web应用程序中创建和管理 WebSocket 连接的接口集合，WebSocket API 由浏览器原生支持，无需使用额外的 JavaScript库或框架，可以直接在 JavaScript 中使用。以下是一些常用的 WebSocket API：</p>
<ul>
<li>**WebSocket 构造函数：**WebSocket构造函数用于创建 WebSocket 对象。它接受一个 URL 作为参数，表示要连接的 WebSocket 服务器地址。通常，WebSocket 协议的 URL 使用 <code>ws://</code>（非加密）或 <code>wss://</code>（加密）开头，类似于 HTTP 协议的 URL。</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://example.com/ws&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**WebSocket.send( )：**WebSocket.send( ) 方法用于向服务器发送数据。它接受一个参数，表示要发送的数据。数据可以是字符串、Blob对象、ArrayBuffer对象。</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.<span class="title function_">send</span>(<span class="string">&#x27;Hello, server!&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**WebSocket.onopen：**WebSocket.onopen事件在WebSocket连接成功建立时触发。</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket 连接已经建立。&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**WebSocket.onmessage：**WebSocket.onmessage事件在接收到服务器发送的消息时触发。它的 event对象包含一个data属性，表示接收到的数据。</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到服务器消息：&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**WebSocket.onerror：**WebSocket.onerror事件在WebSocket连接出现错误时触发。通过这个事件可以处理连接错误。</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;WebSocket 连接出现错误：&#x27;</span>, event);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**WebSocket.onclose：**WebSocket.onclose事件在web Socket连接被关闭时触发。可以用来处理连接关闭后的清理工作。</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket 连接已经关闭。&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="Java中使用WebSocket"><a href="#Java中使用WebSocket" class="headerlink" title="Java中使用WebSocket"></a>Java中使用WebSocket</h2><p><strong>Maven依赖：</strong></p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="3-1-使用Java-WebSocket-API-编写-WebSocket-服务端"><a href="#3-1-使用Java-WebSocket-API-编写-WebSocket-服务端" class="headerlink" title="3.1 使用Java WebSocket API 编写 WebSocket 服务端"></a>3.1 使用Java WebSocket API 编写 WebSocket 服务端</h3><p><strong>示例代码：</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/echo&quot;)</span> <span class="comment">//定义了一个名为&quot;echo&quot;的WebSocket端点，它会监听客户端发来的消息，并将处理后的消息返回给客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WebSocket 连接已经建立。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到客户端消息：&quot;</span> + message);</span><br><span class="line">        session.getBasicRemote().sendText(<span class="string">&quot;服务器收到消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WebSocket 连接已经关闭。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WebSocket 连接出现错误：&quot;</span> + t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个示例代码定义了一个名为“echo”的WebSocket端点，它会监听客户端发来的消息，并将处理后的消息返回给客户端。具体来说，它使用了<code>@ServerEndpoint</code>注解来指定WebSocket端点的URL，使用 @OnOpen 、@OnMessage、@OnClose 和 @OnError 注解来定义 WebSocket 事件处理器。</p>
<p>要使用这个 WebSocket 服务端，我们需要部署它到一个支持 WebSocket 的 Web 容器中。例如，我们可以使用 Tomcat 8 或以上版本来运行它。部署完成后，我们可以使用任何支持 WebSocket 的客户端来连接这个服务端，发送消息并接收服务器的响应。【这个WebSocket 客户端通常需要我们自己实现】</p>
<p><strong>HTML&#x2F;JavaScript 的 WebSocket 客户端代码示例：</strong></p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebSocket Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/echo&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket 连接已经建立。&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            ws.<span class="title function_">send</span>(<span class="string">&#x27;Hello, server!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到服务器消息：&#x27;</span>, event.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        ws.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;WebSocket 连接出现错误：&#x27;</span>, event);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        ws.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket 连接已经关闭。&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>WebSocket Demo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>这个客户端使用了 WebSocket 构造函数来创建一个 WebSocket 对象，并指定连接的URL为我们之前部署的服务端的URL。它使用了 WebSocket 的事件处理器来处理 WebSocket 事件，例如当 WebSocket 连接成功建立时，他会像服务器发送一条消息，并在收到服务器的响应时打印出消息的内容。</p>
<h3 id="3-2-使用-Java-WebSocket-API-编写-WebSocket-客户端"><a href="#3-2-使用-Java-WebSocket-API-编写-WebSocket-客户端" class="headerlink" title="3.2 使用 Java WebSocket API 编写 WebSocket 客户端"></a>3.2 使用 Java WebSocket API 编写 WebSocket 客户端</h3><p><strong>示例代码：</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@ClientEndpoint</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoClient</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Session session; <span class="comment">// 用于保存与 WebSocket 服务器的连接会话,可如果需要保存多个会话可以使用Map集合</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WebSocket 连接已经建立。&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.session = session;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到服务器消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WebSocket 连接已经关闭。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WebSocket 连接出现错误：&quot;</span> + t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 连接到 WebSocket 服务器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(String url)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">WebSocketContainer</span> <span class="variable">container</span> <span class="operator">=</span> ContainerProvider.getWebSocketContainer();  <span class="comment">// 获取 WebSocket 容器实例</span></span><br><span class="line">        container.connectToServer(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">URI</span>(url));  <span class="comment">// 使用 WebSocket 容器连接到指定的服务器端点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息到 WebSocket 服务器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        session.getBasicRemote().sendText(message);  <span class="comment">// 通过会话的基本远程接口发送文本消息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭与 WebSocket 服务器的连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        session.close();  <span class="comment">// 关闭 WebSocket 会话</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-3-使用Spring-Boot编写WebSocket服务端"><a href="#3-3-使用Spring-Boot编写WebSocket服务端" class="headerlink" title="3.3 使用Spring Boot编写WebSocket服务端"></a>3.3 使用Spring Boot编写WebSocket服务端</h3><p><strong>Maven依赖</strong></p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果仍然遇到 javax.websocket.* 包找不到的问题，可以添加 javax.websocket-api 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>配置WebSocket</strong></p>
<p>应用程序中，需要配置WebSocket。创建一个新的Java类，并添加注解<code>@ServerEndpoint(&quot;/websocket&quot;)</code>，这将指定WebSocket服务端的端点为<code>/websocket</code>，也可以自行修改。</p>
<p>在此类中，需要实现几个方法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WebSocket服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/ws/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放会话对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Session&gt; sessionMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接建立成功调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session, <span class="meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端：&quot;</span> + sid + <span class="string">&quot;建立连接&quot;</span>);</span><br><span class="line">        sessionMap.put(sid, session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送过来的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, <span class="meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到来自客户端：&quot;</span> + sid + <span class="string">&quot;的信息:&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sid</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(<span class="meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接断开:&quot;</span> + sid);</span><br><span class="line">        sessionMap.remove(sid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 群发</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendToAllClient</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        Collection&lt;Session&gt; sessions = sessionMap.values();</span><br><span class="line">        <span class="keyword">for</span> (Session session : sessions) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//服务器向客户端发送消息</span></span><br><span class="line">                session.getBasicRemote().sendText(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="配置WebSocket支持"><a href="#配置WebSocket支持" class="headerlink" title="配置WebSocket支持"></a>配置WebSocket支持</h3><p> 最后，需要配置Spring Boot以支持WebSocket。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WebSocket 配置类，用于注册 WebSocket 服务器端点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerEndpointExporter <span class="title function_">serverEndpointExporter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServerEndpointExporter</span>();  <span class="comment">// 自动扫描并注册 @ServerEndpoint 注解的类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="WebSocket的消息格式"><a href="#WebSocket的消息格式" class="headerlink" title="WebSocket的消息格式"></a>WebSocket的消息格式</h2><h4 id="4-1-文本消息和二进制消息"><a href="#4-1-文本消息和二进制消息" class="headerlink" title="4.1 文本消息和二进制消息"></a>4.1 文本消息和二进制消息</h4><p>文本消息是普通的Unicode文本字符串。当WebSocket连接建立时，客户端和服务器可以通过发送文本消息来互相交换信息。服务器可以使用Session对象的<code>getBasicRemote()</code>方法来向客户端发送文本消息，客户端可以使用WebSocket的<code>send()</code>方法来向服务器发送文本消息。</p>
<ul>
<li><p><strong>getBasicRemote()具体用法：</strong></p>
<ul>
<li><p><strong><code>sendText(String message)</code></strong>: 发送一个文本消息给客户端。</p>
</li>
<li><p><strong><code>sendBinary(ByteBuffer data)</code></strong>: 发送二进制数据到客户端。</p>
</li>
<li><p><strong><code>flush()</code></strong>: 刷新缓冲区，确保数据发送。</p>
</li>
<li><p><strong><code>close()</code></strong>: 关闭 WebSocket 连接</p>
</li>
</ul>
</li>
</ul>
<p>下面是向客户端发送文本消息的示例代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">session.getBasicRemote().sendText(<span class="string">&quot;Hello, client!&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>二进制消息可以是任意类型的数据，包括图像、音频、视频等。要向客户端发送二进制消息，服务器可以使用Session对象的<code>getBasicRemote()</code>方法，将消息作为ByteBuffer对象发送。客户端可以使用WebSocket的send()方法来向服务器发送二进制消息。</p>
<p>下面是向客户端发送二进制消息的示例代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] data = <span class="comment">// binary data</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(data); <span class="comment">// 将字节数组包装成 ByteBuffer</span></span><br><span class="line">session.getBasicRemote().sendBinary(buffer);</span><br></pre></td></tr></table></figure></div>

<p>请注意，尽管文本消息和二进制消息在格式上有所不同，但它们都是通过WebSocket发送的消息类型，因此客户端和服务器都需要能够处理这两种类型的消息。</p>
<h4 id="4-2-Ping和Pong消息"><a href="#4-2-Ping和Pong消息" class="headerlink" title="4.2 Ping和Pong消息"></a>4.2 Ping和Pong消息</h4><p>WebSocket还支持Ping和Pong消息类型，用于检测WebSocket连接是否仍然处于活动状态。Ping消息由客户端发送到服务器，Pong消息由服务器发送回客户端作为响应。如果客户端在一段时间内没有收到Pong消息，则它可以假定WebSocket连接已断开，并关闭连接。</p>
<p>要发送Ping消息，请使用Session对象的<code>getBasicRemote()</code>方法，并将Ping消息作为ByteBuffer对象发送。客户端可以使用WebSocket的<code>sendPing()</code>方法来向服务器发送Ping消息。</p>
<p>下面是向客户端发送Ping消息的示例代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">pingMessage</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="keyword">new</span> <span class="title class_">byte</span>[] &#123; <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;);</span><br><span class="line">session.getBasicRemote().sendPing(pingMessage);</span><br></pre></td></tr></table></figure></div>

<p>要接收Pong消息，请在您的WebSocket处理程序中实现<code>onPong()</code>方法。当您的WebSocket服务器接收到Pong消息时，它将自动调用此方法，并将接收到的Pong消息作为ByteBuffer对象传递给它。</p>
<p>下面是实现onPong()方法的示例代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OnMessage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPong</span><span class="params">(Session session, ByteBuffer pongMessage)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Received Pong message: &quot;</span> + pongMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>请注意，Ping和Pong消息通常用于WebSocket连接的健康检查。如果您希望在WebSocket连接中使用此功能，则应定期发送Ping消息并等待Pong消息的响应。</p>
<h4 id="4-3-关闭消息"><a href="#4-3-关闭消息" class="headerlink" title="4.3 关闭消息"></a>4.3 关闭消息</h4><p>WebSocket还支持关闭消息类型，用于关闭WebSocket连接。关闭消息可以由客户端或服务器发起，并且可以携带一个可选的状态码和关闭原因。当WebSocket连接关闭时，客户端和服务器都应该发送一个关闭消息以结束连接。</p>
<p>要发送关闭消息，请使用Session对象的<code>getBasicRemote()</code>方法，并调用它的<code>sendClose()</code>方法。关闭消息可以携带一个可选的状态码和关闭原因。如果您不希望发送状态码或关闭原因，则可以将它们设置为0和null。</p>
<p>下面是向客户端发送关闭消息的示例代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">session.close(<span class="keyword">new</span> <span class="title class_">CloseReason</span>(CloseReason.CloseCodes.NORMAL_CLOSURE, <span class="string">&quot;Closing from client.&quot;</span>));</span><br></pre></td></tr></table></figure></div>

<p>要处理接收到的关闭消息，请在您的WebSocket处理程序中实现<code>onClose()</code>方法。当您的WebSocket服务器接收到关闭消息时，它将自动调用此方法，并将接收到的状态码和关闭原因传递给它。</p>
<p>下面是实现<code>onClose()</code>方法的示例代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OnClose</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session, CloseReason closeReason)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Connection closed: &quot;</span> + closeReason.getCloseCode() + <span class="string">&quot; - &quot;</span> </span><br><span class="line">                       + closeReason.getReasonPhrase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>请注意，客户端和服务器都应该发送关闭消息以结束WebSocket连接。如果只有一方发送了关闭消息，则另一方可能无法正确地关闭连接，并且可能需要等待超时才能释放资源。建议客户端和服务器在关闭连接时都发送关闭消息，以确保连接正确地关闭。</p>
<h2 id="WebSocket的性能"><a href="#WebSocket的性能" class="headerlink" title="WebSocket的性能"></a>WebSocket的性能</h2><h4 id="5-1-与传统的HTTP请求-响应模型比较"><a href="#5-1-与传统的HTTP请求-响应模型比较" class="headerlink" title="5.1 与传统的HTTP请求&#x2F;响应模型比较"></a>5.1 与传统的HTTP请求&#x2F;响应模型比较</h4><ul>
<li><strong>双向通信性能更好：</strong> WebSocket协议使用单一的TCP连接，允许客户端和服务器在同一个连接上进行双向通信。这种实时的双向通信可以更快地传输数据，而不需要建立多个HTTP请求&#x2F;响应连接。</li>
<li><strong>更小的网络流量：</strong> 与HTTP相比，WebSocket协议需要更少的网络流量来维护连接，因为它不需要在每个请求&#x2F;响应交换中发送头部信息。</li>
<li><strong>更低的延迟：</strong> WebSocket协议允许服务器主动向客户端推送消息，而不需要客户端先发送请求。这种实时通信可以减少响应延迟，并提高应用程序的性能。</li>
<li><strong>更好的服务器资源管理：</strong> 由于WebSocket连接可以保持活动状态，服务器可以更好地管理客户端连接，减少服务器开销和处理时间。</li>
</ul>
<p>WebSocket协议的性能比传统的HTTP请求&#x2F;响应模型更好，特别是在实时通信和低延迟方面。WebSocket协议适用于需要实时通信和实时数据更新的应用程序，如在线聊天、多人游戏、实时监控等。</p>
<h4 id="5-2-优化WebSocket的性能"><a href="#5-2-优化WebSocket的性能" class="headerlink" title="5.2 优化WebSocket的性能"></a>5.2 优化WebSocket的性能</h4><ul>
<li><strong>减少消息大小：</strong> WebSocket 传输的数据大小对性能有很大影响。尽量减少消息的大小，可以降低网络带宽和服务器负载。例如，可以使用二进制传输协议来代替文本传输，或使用压缩算法对消息进行压缩。</li>
<li><strong>使用CDN加速：</strong> 使用 CDN（内容分发网络）可以将静态资源缓存到离用户更近的节点上，提高传输速度和性能。CDN 可以缓存 Websocket 的初始握手请求，避免不必要的网络延迟。</li>
<li><strong>使用负载均衡：</strong> WebSocket 服务可以使用负载均衡来分配并平衡多个服务器的负载。负载均衡可以避免单个服务器被过载，并提高整个服务的可伸缩性。</li>
<li><strong>优化服务端代码：</strong> WebSocket 服务端代码的性能也是关键因素。使用高效的框架和算法，避免使用过多的内存和 CPU 资源，可以提高服务端的性能和响应速度。</li>
<li><strong>避免网络阻塞：</strong> WebSocket 的性能也会受到网络阻塞的影响。当有太多的连接同时请求数据时，服务器的性能会下降。使用合适的线程池和异步 IO 操作可以避免网络阻塞，提高 WebSocket 服务的并发性能。</li>
</ul>
<h2 id="WebSocket的扩展应用和未来发展方向"><a href="#WebSocket的扩展应用和未来发展方向" class="headerlink" title="WebSocket的扩展应用和未来发展方向"></a>WebSocket的扩展应用和未来发展方向</h2><ul>
<li><strong>更加完善的标准规范：</strong> WebSocket 标准规范还有很多可以优化的地方，未来可能会继续完善 WebSocket 的标准规范，以适应更加复杂的应用场景。</li>
<li><strong>更加安全的通信方式：</strong> 由于 WebSocket 的开放性，使得它可能会受到一些安全威胁，未来可能会通过加密、身份验证等方式来增强 WebSocket 的安全性。</li>
<li><strong>更好的兼容性：</strong> WebSocket 协议需要在 HTTP 协议的基础上建立连接，因此可能会遇到兼容性问题，未来可能会通过技术手段来解决这些问题。</li>
<li><strong>更好的性能和可伸缩性：</strong> WebSocket 协议的性能和可伸缩性对于复杂的应用场景非常关键，未来可能会通过技术手段来进一步提高 WebSocket 的性能和可伸缩性。</li>
</ul>
]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>工具集</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream流</title>
    <url>/2024/05/06/Stream%E6%B5%81/</url>
    <content><![CDATA[<h1 id="Java-Stream流"><a href="#Java-Stream流" class="headerlink" title="Java Stream流"></a>Java Stream流</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1.概念"></a>1.1.概念</h3><ul>
<li><strong>Stream不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的Iterator</strong>。原始版本的Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的Stream，用户只要给出需要对其包含的元素执行什么操作，比如，“过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream会隐式地在内部进行遍历，做出相应的数据转换。<strong>Stream就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了</strong>，就好比流水从面前流过，一去不复返。</li>
<li>而和迭代器又不同的是，<strong>Stream可以并行化操作</strong>，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个item读完后再读下一个item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream的并行操作依赖于Java7中引入的Fork&#x2F;Join框架（JSR166y）来拆分任务和加速处理过程。</li>
<li>Stream 的另外一大特点是，<strong>数据源本身可以是无限的</strong>。</li>
</ul>
<h3 id="1-2-Stream流的特性"><a href="#1-2-Stream流的特性" class="headerlink" title="1.2.Stream流的特性"></a>1.2.Stream流的特性</h3><ul>
<li>不存储数据[按照特定的规则对数据进行计算，一般会输出结果]</li>
<li>不会改变数据源[通常情况下会产生一个新的集合或一个值]</li>
<li>具有延迟执行特性[只有调用终端操作时，中间操作才会执行]</li>
</ul>
<h3 id="1-3-Stream流的作用"><a href="#1-3-Stream流的作用" class="headerlink" title="1.3.Stream流的作用"></a>1.3.Stream流的作用</h3><p>  结合Lambda表达式，简化集合、数组操作，提高代码的效率。</p>
<h3 id="1-4-Stream流的使用步骤"><a href="#1-4-Stream流的使用步骤" class="headerlink" title="1.4.Stream流的使用步骤"></a>1.4.Stream流的使用步骤</h3><ul>
<li>获取数据源，将数据源中的数据读取到流中<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240507103133.png"
                     
                ></li>
<li>对流中的数据进行各种各样的处理[筛选、过滤……]    <strong>中间操作</strong>-&gt;方法调用完毕后会返回另一个流，还可以继续调用其他方法[建议使用链式编程]</li>
<li>对流中的数据进行整合处理[遍历、统计……]    <strong>终端操作</strong>-&gt;方法调用完毕后，流就关闭了，不能再调用其他方法</li>
</ul>
<h2 id="2-Stream的生成"><a href="#2-Stream的生成" class="headerlink" title="2.Stream的生成"></a>2.Stream的生成</h2><h3 id="2-1-Collection-stream-、Collection-parallelStream"><a href="#2-1-Collection-stream-、Collection-parallelStream" class="headerlink" title="2.1.Collection.stream()、Collection.parallelStream()"></a>2.1.Collection.stream()、Collection.parallelStream()</h3><ul>
<li>通过Collection接口中的<strong>stream</strong>()方法获取数据源为<strong>集合</strong>的流对象【同步流】：<code>Stream&lt;T&gt; stream() = list.stream();</code></li>
<li>通过Collection接口中的<strong>parallelStream</strong>()方法获取数据源为<strong>集合</strong>的流对象【并发、异步流】：<code>Stream&lt;T&gt; parallelStream() = list.parallelStream();</code></li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建一个顺序流</span></span><br><span class="line">    Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">    System.out.println(<span class="string">&quot;创建一个顺序流&quot;</span>);</span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">    <span class="comment">// 创建一个并行流</span></span><br><span class="line">    Stream&lt;String&gt; parallelStream = list.parallelStream();</span><br><span class="line">    System.out.println(<span class="string">&quot;创建一个并行流&quot;</span>);</span><br><span class="line">    parallelStream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  输出：创建一个顺序流</span></span><br><span class="line"><span class="comment">        a</span></span><br><span class="line"><span class="comment">        b</span></span><br><span class="line"><span class="comment">        c</span></span><br><span class="line"><span class="comment">        创建一个并行流</span></span><br><span class="line"><span class="comment">        b</span></span><br><span class="line"><span class="comment">        c</span></span><br><span class="line"><span class="comment">        a</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>「stream和parallelStream的简单区分」</strong>: stream是顺序流，由主线程按顺序对流执行操作，而parallelStream是并行流，内部以多线程并行执行的方式对流进行操作，但前提是流中的数据处理没有顺序要求。例如筛选集合中的奇数，两者的处理不同之处：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240507102247.png"
                     
                ></p>
</blockquote>
<h3 id="2-2-Arrays-stream"><a href="#2-2-Arrays-stream" class="headerlink" title="2.2.Arrays.stream()"></a>2.2.Arrays.stream()</h3><ul>
<li>通过Arrays工具类中的<strong>stream</strong>(T[] array)方法获取数据源为<strong>数组</strong>的流对象：<code>IntStream stream = Arrays.stream(array);</code>[除了IntStream，还有LongStream、DoubleStream……]</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(array);</span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-Stream的静态方法"><a href="#2-3-Stream的静态方法" class="headerlink" title="2.3.Stream的静态方法"></a>2.3.Stream的静态方法</h3><ul>
<li>通过Stream工具类中的<strong>of</strong>(T… values)方法获取数据源为<strong>一堆零散数据</strong>的流对象：<code>Stream&lt;T&gt; stream = Stream.of(array);</code></li>
<li>通过Stream工具类中的<strong>iterate</strong>(T seed, UnaryOperator f)方法获取数据源为<strong>无限</strong>的流对象，其中第一个参数是种子值，第二个参数是一个函数，用于生成后续的元素：<code>Stream&lt;T&gt; stream = Stream.iterate(0, n -&gt; n + 2);</code></li>
<li>通过Stream工具类中的<strong>generate</strong>(Supplier s)方法获取数据源为<strong>无限</strong>的流对象，其中参数是一个供应商函数，用于生成元素：<code>Stream&lt;T&gt; stream = Stream.generate(Math::random);</code></li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">stream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">3</span>).limit(<span class="number">4</span>); <span class="comment">//limit(4)表示只取前4个元素</span></span><br><span class="line">stream2.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(<span class="number">3</span>); <span class="comment">//limit(3)表示只取前3个元素</span></span><br><span class="line">stream3.forEach(System.out::println);</span><br><span class="line"><span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">  使用Stream.of()：</span></span><br><span class="line"><span class="comment">  1</span></span><br><span class="line"><span class="comment">  2</span></span><br><span class="line"><span class="comment">  3</span></span><br><span class="line"><span class="comment">  4</span></span><br><span class="line"><span class="comment">  使用Stream.iterate()：</span></span><br><span class="line"><span class="comment">  0</span></span><br><span class="line"><span class="comment">  3</span></span><br><span class="line"><span class="comment">  6</span></span><br><span class="line"><span class="comment">  9</span></span><br><span class="line"><span class="comment">  使用Stream.generate()：</span></span><br><span class="line"><span class="comment">  0.34339747950763355</span></span><br><span class="line"><span class="comment">  0.8263192360076247</span></span><br><span class="line"><span class="comment">  0.6455630248922111 */</span></span><br></pre></td></tr></table></figure></div>
<h3 id="2-4-文件创建"><a href="#2-4-文件创建" class="headerlink" title="2.4.文件创建"></a>2.4.文件创建</h3><ul>
<li>BufferedReader.lines()方法获取数据源为<strong>文件</strong>的流对象：<code>Stream&lt;String&gt; stream = new BufferedReader(new FileReader(filePath)).lines();</code></li>
<li>通过Files工具类中的<strong>lines</strong>(Path path, Charset cs)方法获取数据源为<strong>文件</strong>的流对象：<code>Stream&lt;String&gt; stream = Files.lines(Paths.get(filePath), Charset.forName(charsetName));</code>【安全性更强，推荐使用】</li>
</ul>
<blockquote>
<p>BufferedReader.lines() 和 Files.lines() 都是用于<strong>从文件中逐行读取数据</strong>的方法，但它们的用法和实现细节略有不同。前者需要手动创建 BufferedReader 对象，并在使用完后<strong>手动关闭流</strong>，而后者更为简洁，因为这个方法是Files工具类的一个静态方法，所以不需要手动创建对象，<strong>不需要手动关闭流</strong></p>
</blockquote>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">// 使用BufferedReader.lines()创建数据源为文件的流</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>))) &#123;</span><br><span class="line">            Stream&lt;String&gt; stream = br.lines();</span><br><span class="line">            stream.forEach(System.out::println);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Files.lines()创建数据源为文件的流</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line">            <span class="comment">// 等价于：Stream&lt;String&gt; lines = Files.lines(Path.of(&quot;input.txt&quot;));</span></span><br><span class="line">            lines.forEach(System.out::println);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-5-其他"><a href="#2-5-其他" class="headerlink" title="2.5.其他"></a>2.5.其他</h3><ul>
<li><strong>Pattrn.splitAsStream(CharSequence input)</strong>：是Pattern类中的一个方法，用于将字符串根据指定的正则表达式分割为流对象，其中参数为字符串，返回值为流对象。</li>
<li><strong>JarFile.stream()</strong>：是JarFile类中的一个方法，用于将Jar文件中的条目(文件)转换为流对象，返回值为流对象。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">// Pattrn.splitAsStream(CharSequence input)</span></span><br><span class="line">        <span class="comment">// 定义正则表达式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;\\s+&quot;</span>; <span class="comment">// 表示一个或多个空白字符</span></span><br><span class="line">        <span class="comment">// 创建 Pattern 对象</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">        <span class="comment">// 使用 splitAsStream() 方法分割字符串并返回流,并对流进行遍历操作</span></span><br><span class="line">        pattern.splitAsStream(<span class="string">&quot;Java is a programming language&quot;</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用JarFile.stream()</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">JarFile</span> <span class="variable">jarFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JarFile</span>(<span class="string">&quot;a.jar&quot;</span>)) &#123;</span><br><span class="line">            Stream&lt;JarEntry&gt; entryStream = jarFile.stream();</span><br><span class="line">            entryStream.forEach(entry -&gt; System.out.println(entry.getName()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="3-中间操作"><a href="#3-中间操作" class="headerlink" title="3.中间操作"></a>3.中间操作</h2><p>中间操作又可以分为<strong>无状态（Stateless）操作</strong>与<strong>有状态（Stateful）操作</strong>，前者是指元素的处理不受之前元素的影响；后者是指该操作只有拿到所有元素之后才能继续下去。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240508161846.png"
                     
                ></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></td>
<td>过滤流中的元素，返回符合条件的元素组成的流</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt; distinct()</code></td>
<td>元素去重，返回不含重复的元素的流 【依赖元素的hashCode()和equals()方法，注意判断是否需要进行重写】</td>
</tr>
<tr>
<td><code>Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</code></td>
<td>将流中的元素映射到另一个流中，返回映射后的流 【第一个类型是流中原本的元素类型，第二个类型是映射后的元素类型】</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends T&gt;&gt; mapper)</code></td>
<td>将流中的元素映射到另一个流中，返回映射后的流，其中映射后的流可以是多个元素组成的流，而不是单个元素。【第一个类型是流中原本的元素类型，第二个类型是映射后的流中元素的类型】</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt; sorted()</code></td>
<td>对流中的元素进行排序，返回排序后的流</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)</code></td>
<td>对流中的元素进行排序，返回排序后的流，其中参数为比较器，用于比较元素大小。【依赖元素的compareTo()方法，注意判断是否需要进行重写】</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt; skip(long n)</code></td>
<td>跳过前n个元素，返回剩余的元素组成的流</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt; limit(long maxSize)</code></td>
<td>截取前maxSize个元素，返回截取后的流</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code></td>
<td>将两个流合并为一个流，返回合并后的流 【如果a和b的类型不同，合并出来的会是他们共同的父类</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action)</code></td>
<td>对流中的元素进行操作，返回操作后的流，但不改变原流。【参数为消费者，用于对元素进行操作】</td>
</tr>
</tbody></table>
<h3 id="3-1-筛选、去重"><a href="#3-1-筛选、去重" class="headerlink" title="3.1.筛选、去重"></a>3.1.筛选、去重</h3><p>filter()和distinct()方法用于筛选和去重流中的元素。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        ArrayList&lt;Person&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(array,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;隔壁老王&quot;</span>,<span class="number">25</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;隔壁老王&quot;</span>,<span class="number">25</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">24</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小思思&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;用filter()筛选名字长度大于2的人物:&quot;</span>);</span><br><span class="line">        array.stream().filter(p -&gt; p.getName().length() &gt; <span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;用distinct()去重:&quot;</span>);</span><br><span class="line">        array.stream().distinct().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  用filter()筛选名字长度大于2的人物:</span></span><br><span class="line"><span class="comment">  Person&#123;name = 隔壁老王, age = 25&#125;</span></span><br><span class="line"><span class="comment">  Person&#123;name = 隔壁老王, age = 25&#125;</span></span><br><span class="line"><span class="comment">  Person&#123;name = 小思思, age = 23&#125; </span></span><br><span class="line"><span class="comment">  用distinct()去重:</span></span><br><span class="line"><span class="comment">  Person&#123;name = 张三, age = 23&#125;</span></span><br><span class="line"><span class="comment">  Person&#123;name = 隔壁老王, age = 25&#125;</span></span><br><span class="line"><span class="comment">  Person&#123;name = 李四, age = 24&#125;</span></span><br><span class="line"><span class="comment">  Person&#123;name = 小思思, age = 23&#125;</span></span><br><span class="line"><span class="comment">  */</span>  </span><br></pre></td></tr></table></figure></div>
<h3 id="3-2-映射"><a href="#3-2-映射" class="headerlink" title="3.2.映射"></a>3.2.映射</h3><h4 id="3-2-1-map-方法："><a href="#3-2-1-map-方法：" class="headerlink" title="3.2.1.map() 方法："></a>3.2.1.<strong>map() 方法</strong>：</h4><ul>
<li><code>map()</code> 方法接受一个函数作为参数，该函数用于将流中的每个元素映射到另一个值。这个映射后的值可以是<strong>任何类型</strong>，最后返回的流包含这些映射后的元素。</li>
<li>对于每个输入元素，<code>map()</code> 方法都会生成一个对应的输出元素。</li>
<li><code>map()</code> 方法返回的流与原始流的元素数量相同，但是每个元素都经过了映射函数的转换。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       Collections.addAll(array,</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>),</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;隔壁老王&quot;</span>,<span class="number">25</span>),</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小思思&quot;</span>,<span class="number">23</span>));</span><br><span class="line">       <span class="comment">// 调用map的方法一:</span></span><br><span class="line">       array.stream().map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Person, String&gt;() &#123;</span><br><span class="line">           <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> person.getName();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).forEach(System.out::println);</span><br><span class="line">       <span class="comment">// 调用map的方法二(lambda表达式):</span></span><br><span class="line">       array.stream().map(p -&gt; p.getName()).forEach(System.out::println);</span><br><span class="line">       <span class="comment">// 调用map的方法三(方法引用)</span></span><br><span class="line">       array.stream().map(Person::getName).forEach(System.out::println);</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 输出：</span></span><br><span class="line"><span class="comment">    * 张三</span></span><br><span class="line"><span class="comment">    * 隔壁老王</span></span><br><span class="line"><span class="comment">    * 小思思</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure></div>

<h4 id="3-2-2-flatMap-方法："><a href="#3-2-2-flatMap-方法：" class="headerlink" title="3.2.2.flatMap() 方法："></a>3.2.2.<strong>flatMap() 方法</strong>：</h4><ul>
<li><code>flatMap()</code> 方法也接受一个函数作为参数，但是这个函数的返回类型是一个流。这个函数会将流中的每个元素映射到<strong>另一个流</strong>。</li>
<li>与 <code>map()</code> 方法不同，<code>flatMap()</code> 方法会将这些内部流合并成一个单一的流。内部流中的所有元素都会被合并到结果流中，形成一个扁平化的流。</li>
<li><code>flatMap()</code> 方法可以处理嵌套的流结构，即使每个元素映射后的流可能包含多个元素，最终返回的流也只是一个单一的流。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先初始化输入列表</span></span><br><span class="line">List&lt;String&gt; list1 = List.of(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">List&lt;String&gt; list2 = List.of(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">List&lt;String&gt; list3 = List.of(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">List&lt;String &gt; list4 =List.of(<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>);</span><br><span class="line">List&lt;List&lt;String&gt;&gt; list = List.of(list1,list2,list3,list4);</span><br><span class="line"><span class="comment">//开始执行操作</span></span><br><span class="line">List&lt;String&gt; listT = list.stream().flatMap(Collection::stream).collect(Collectors.toList());</span><br><span class="line">System.out.println(listT);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给定输入：[[1],[2],[3],[4,5]]</span></span><br><span class="line"><span class="comment">要求输出：[1,2,3,4,5]*/</span></span><br></pre></td></tr></table></figure></div>
<p>看一下具体的执行流程。橙色的是stream的通用执行流程，不管你中间态用哪个方法，这里是不变的，蓝色的是<code>ArrayListSpliterator</code>分割器。红色的执行流程是flatMap的执行流程。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240508125402.png"
                     
                ></p>
<p>可以看到<code>ArrayListSpliterator</code>先取出第一个元素<code>[1]</code>这个一维数组传递给<code>flatMap</code>，然后flatMap执行了我们传入的<code>Collection::stream</code>方法，该方法是初始化一个stream头节点。也就是再生成了一个stream</p>
<p>重点就是这里了。再次把[1]这个一维数组放入了新的stream里面。然后把结果态节点<code>ReduceOps</code>传递给了新的stream作为新的stream的结果态节点。</p>
<p>这个时候新的stream开始执行<code>ArrayListSpliterator</code>。从而把[1]一维数组进行for循环，取出了其中的<code>1</code>这个元素，然后把1传入了同一个<code>ReduceOps</code>进行处理从而组成了一个结果list-&gt;[1]。</p>
<p>把步骤总结如下：</p>
<p> 1.取出二维数组的第一个一维数组<br> 2.把一维数组和结果态节点重新创建一个stream<br> 3.执行stream把一维数组的元素循环放入结果态的list<br>循环二维数组，不断重复上述步骤，就可以把二维数组展开成一维数组了。</p>
<h4 id="3-2-3-map-和flatMap-的区别"><a href="#3-2-3-map-和flatMap-的区别" class="headerlink" title="3.2.3.map()和flatMap()的区别"></a>3.2.3.<strong>map()和flatMap()的区别</strong></h4><blockquote>
<p><strong>总的来说:</strong></p>
<ul>
<li><code>map()</code> 方法是一对一的映射，而 <code>flatMap()</code> 方法可以处理一对多的映射，可以将多个流合并成一个流。</li>
<li><code>map()</code>和<code>faltMap()</code>的参数差别在于，前者传入一个实体返回一个实体，后者则是传入一个实体返回一个Stream流，那既然是流，最好返回值本身就是一个Stream，或者能被转换成Stream的对象!</li>
</ul>
</blockquote>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;Holle world and you world&quot;</span>);</span><br><span class="line"><span class="comment">// 调用flatMap的方法一:</span></span><br><span class="line">list.stream().flatMap(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Stream&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> Stream&lt;String&gt; <span class="title function_">apply</span><span class="params">(String list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(list.split(<span class="string">&quot;\\s+&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 调用flatMap的方法二:</span></span><br><span class="line">list.stream().flatMap(t -&gt; Stream.of(t.split(<span class="string">&quot;\\s+&quot;</span>)))</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出: Holle</span></span><br><span class="line"><span class="comment">  *       world</span></span><br><span class="line"><span class="comment">  *       and</span></span><br><span class="line"><span class="comment">  *       you</span></span><br><span class="line"><span class="comment">  *       world</span></span><br><span class="line"><span class="comment">  * flatMap会把按空格拆分后所有的单词流合并成一个流返回.</span></span><br><span class="line"><span class="comment">  * 这就意味着，当你调用 forEach(System.out::println) 方法时，它会直接作用于这个合并后的流上，</span></span><br><span class="line"><span class="comment">  * 并打印出每个单词。</span></span><br><span class="line"><span class="comment">  * */</span></span><br><span class="line">  <span class="comment">//Map方法</span></span><br><span class="line">  list.stream().map(t -&gt; Stream.of(t.split(<span class="string">&quot;\\s+&quot;</span>)))</span><br><span class="line">      .forEach(System.out::println);</span><br><span class="line">  <span class="comment">/*输出:java.util.stream.ReferencePipeline$Head@b1bc7ed</span></span><br><span class="line"><span class="comment">  而Map方法最后的结果为一个地址，并没有对数组里面的结果进行细分,最后的结果依旧为一个整体</span></span><br><span class="line"><span class="comment">  这是因为map里面的参数Stream.of(t.split(&quot;\\s+&quot;))会将每个元素映射成一个流,</span></span><br><span class="line"><span class="comment">  而map() 方法返回的是一个包含映射后元素的流对象,这个流没有重写`toString`方法</span></span><br><span class="line"><span class="comment">  导致返回的是一个包含多个流的流,在使用.forEach方法时,默认打印对象的 toString() 方法的结果。</span></span><br><span class="line"><span class="comment">  在这种情况下，由于没有重写 toString() 方法，所以它打印的是默认的对象地址信息。</span></span><br><span class="line"><span class="comment">  因为list中只有一个元素,所以外部流对象只包含一个内部流对象,输出一个地址*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*list.stream().map(new Function&lt;String, String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public String apply(String s) &#123;</span></span><br><span class="line"><span class="comment">                return s.split(&quot;\\s+&quot;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;).forEach(System.out::println);*/</span></span><br><span class="line">  <span class="comment">// 在return s.split(&quot;\\s+&quot;);会报错，是因为split()方法返回的是一个数组，而map()方法要求返回的是一个对象。map并不能处理一对多的映射      </span></span><br></pre></td></tr></table></figure></div>
<h3 id="3-3-排序"><a href="#3-3-排序" class="headerlink" title="3.3.排序"></a>3.3.排序</h3><ul>
<li><code>sorted()</code> 方法用于对流中的元素进行排序。默认情况下，排序是按照自然顺序进行的，即升序。【其中的元素必须实现 Comparable 接口，否则会抛出 ClassCastException 异常】</li>
<li><code>sorted(Comparator&lt;T&gt; comparator)</code> 方法用于对流中的元素进行排序，并指定排序规则。我们可以使用lambda表达式来创建一个Comparator实例。可以自定义排序规则。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">#自然序排序一个list</span><br><span class="line">list.stream().sorted() </span><br><span class="line"> </span><br><span class="line">#自然序逆序元素，使用Comparator 提供的reverseOrder() 方法</span><br><span class="line">list.stream().sorted(Comparator.reverseOrder()) </span><br><span class="line"> </span><br><span class="line"># 使用Comparator 来排序一个list</span><br><span class="line">list.stream().sorted(Comparator.comparing(Student::getAge)) </span><br><span class="line"> </span><br><span class="line"># 颠倒使用Comparator 来排序一个list的顺序，使用Comparator 提供的reversed() 方法</span><br><span class="line">list.stream().sorted(Comparator.comparing(Student::getAge).reversed()) </span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>Comparator.thenComparing(Comparator&lt;? super T&gt; other)</code>: 实现多字段排序，如果第一个比较器比较结果相等，则使用第二个比较器进行比较。可以搭配使用Comparator.reverseOrder() 实现降序和升序</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按年龄升序，如果年龄相等，再按零花钱升序</span></span><br><span class="line">List&lt;userInfo&gt; userList3 = userList.stream()</span><br><span class="line">	.sorted(Comparator.comparing(userInfo::getAge).thenComparing(userInfo::getMoney))</span><br><span class="line">	.collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按年龄降序，如果年龄相等，再按零花钱降序</span></span><br><span class="line">List&lt;userInfo&gt; userList3 = userList.stream()</span><br><span class="line">  .sorted(Comparator.comparing(userInfo::getAge).thenComparing(userInfo::getMoney,Comparator.reverseOrder()))</span><br><span class="line">  <span class="comment">// 也可以等价于 .sorted(Comparator.comparing(userInfo::getAge).thenComparing(Comparator.comparing(userInfo::getMoney).reversed()))</span></span><br><span class="line">  .collect(Collectors.toList());  </span><br></pre></td></tr></table></figure></div>
<ul>
<li>自定义排序规则</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按照名字的长度排序，长的在前面。【如果使用compareTo，是按照字典序排序】</span></span><br><span class="line"> List&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">        Collections.addAll(list,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">23</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">24</span>));</span><br><span class="line">        list.stream().sorted((s1, s2) -&gt; s2.getName().length() - s1.getName().length() )</span><br><span class="line">                .forEach(System.out::println);</span><br></pre></td></tr></table></figure></div>

<h3 id="3-4-跳过、截取"><a href="#3-4-跳过、截取" class="headerlink" title="3.4.跳过、截取"></a>3.4.跳过、截取</h3><ul>
<li><code>skip(long n)</code>：如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。</li>
<li><code>limit(long n)</code>：参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10StreamSkip</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; result = original.skip(<span class="number">2</span>);</span><br><span class="line">        System.out.println(result.count()); <span class="comment">// 1 ：流中剩下 &quot;周芷若&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11StreamLimit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; result = original.limit(<span class="number">2</span>);</span><br><span class="line">        System.out.println(result.count()); <span class="comment">// 2：截取了 &quot;张无忌&quot; 和 &quot;张三丰&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-5-结合"><a href="#3-5-结合" class="headerlink" title="3.5.结合"></a>3.5.结合</h3><ul>
<li><code>concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code> : 合并a和b两个流为一个流 【如果a和b的类型不同，合并出来的会是他们共同的父类】<blockquote>
<p>备注：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。</p>
</blockquote>
</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo12StreamConcat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; streamA = Stream.of(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; streamB = Stream.of(<span class="string">&quot;张翠山&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; result = Stream.concat(streamA, streamB);</span><br><span class="line">        result.forEach(System.out::println);</span><br><span class="line">        <span class="comment">/*输出:</span></span><br><span class="line"><span class="comment">        张无忌</span></span><br><span class="line"><span class="comment">        张翠山  */</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-6-调试"><a href="#3-6-调试" class="headerlink" title="3.6.调试"></a>3.6.调试</h3><ul>
<li><code>peek(Comsumer&lt;? super T&gt; action)</code>：它接受一个 Consumer 函数作为参数，该函数会被应用到流中的每个元素上。【不会销毁流对象】<blockquote>
<p>这个方法通常用于调试或记录流中元素的中间状态，或者在调试代码时查看流中元素的值，而不会对流进行实际操作。</p>
</blockquote>
</li>
</ul>
<h4 id="3-6-1-对流中的元素进行遍历"><a href="#3-6-1-对流中的元素进行遍历" class="headerlink" title="3.6.1.对流中的元素进行遍历"></a>3.6.1.对流中的元素进行遍历</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;userInfo&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(userList,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">userInfo</span>(<span class="number">18</span>,<span class="number">30</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">userInfo</span>(<span class="number">18</span>,<span class="number">34</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">userInfo</span>(<span class="number">17</span>,<span class="number">28</span>));</span><br><span class="line"><span class="comment">// 调用peek()方法遍历流中的元素</span></span><br><span class="line">List&lt;userInfo&gt; list = userList.stream().peek(System.out::println)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">/*输出:</span></span><br><span class="line"><span class="comment">userInof&#123;Age = 18, Money = 30&#125;</span></span><br><span class="line"><span class="comment">userInof&#123;Age = 18, Money = 34&#125;</span></span><br><span class="line"><span class="comment">userInof&#123;Age = 17, Money = 28&#125;</span></span><br><span class="line"><span class="comment">[userInof&#123;Age = 18, Money = 30&#125;, userInof&#123;Age = 18, Money = 34&#125;, userInof&#123;Age = 17, Money = 28&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<h4 id="3-6-2-对流中的对象进行修改"><a href="#3-6-2-对流中的对象进行修改" class="headerlink" title="3.6.2.对流中的对象进行修改"></a>3.6.2.对流中的对象进行修改</h4><p>在Java的Stream中，它实际上是对原始数据的引用。</p>
<ul>
<li>对于基本数据类型：修改只会作用在<code>peek()</code>方法的内部，因为基本数据类型是按值传递的，<code>peek()</code>方法中的参数是局部变量，对它们的修改不会影响到原始数据。所以，对基本数据类型进行的修改只会作用在peek()方法的内部。</li>
<li>对于引用数据类型：<ul>
<li>对于不可变对象（如<code>String</code>）：对它们的操作会返回一个新对象，而不会修改原始数据。所以对不可变对象的操作也只会作用在<code>peek()</code>方法的内部，不会影响流中的数据或原始数据。</li>
<li>对于可变对象（如<code>StringBuilder</code>、自己创建的类<code>userInfo</code>等）：对它们的操作会直接修改原始数据。因此，对可变对象的操作会影响流中的数据以及原始数据。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>对于流中的对象进行修改：</strong><br>实际上，流中的操作不会直接修改原始数据，而是操作原始数据中的对象。这意味着对流中的对象进行的任何修改都会影响原始数据。然而，需要注意的是，如果流中的对象是不可变对象，对它们进行的修改只会影响到流中的对象，而不会修改原始数据。这种修改只会作用在peek()方法的内部，不会影响到原始数据。</p>
</blockquote>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 流中对象是不可变对象String，对其修改只会作用在peek()方法内部，不会影响流中的数据或原始数据</span></span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">list1.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">list1.add(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line">list1.stream()</span><br><span class="line">        .peek(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                s += <span class="string">&quot;_suffix&quot;</span>;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) <span class="comment">// 修改字符串内容</span></span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">System.out.println(list1);</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">apple_suffix</span></span><br><span class="line"><span class="comment">apple</span></span><br><span class="line"><span class="comment">banana_suffix       </span></span><br><span class="line"><span class="comment">banana                -&gt; 这里的输出顺序是先运行一次peek()方法，再运行一次forEach()方法，这样子迭代下去的</span></span><br><span class="line"><span class="comment">cherry_suffix            因为中间操作peek()属于无状态，所以元素的处理不受之前元素的影响，会直接执行完整条流中的所有操作         </span></span><br><span class="line"><span class="comment">cherry</span></span><br><span class="line"><span class="comment">[apple, banana, cherry]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用peek()方法遍历流中的对象,将用户的年龄加10,注意:这个修改会修改到流中数据和原始数据</span></span><br><span class="line">List&lt;userInfo&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(userList,</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">userInfo</span>(<span class="number">18</span>,<span class="number">30</span>),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">userInfo</span>(<span class="number">18</span>,<span class="number">34</span>),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">userInfo</span>(<span class="number">17</span>,<span class="number">28</span>));</span><br><span class="line">userList.stream().peek(userInfo -&gt; userInfo.setAge(userInfo.getAge()+<span class="number">10</span>))</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">System.out.println(userList);</span><br><span class="line"><span class="comment">/*输出:</span></span><br><span class="line"><span class="comment">userInof&#123;Age = 28, Money = 30&#125;</span></span><br><span class="line"><span class="comment">userInof&#123;Age = 28, Money = 34&#125;</span></span><br><span class="line"><span class="comment">userInof&#123;Age = 27, Money = 28&#125;</span></span><br><span class="line"><span class="comment">[userInof&#123;Age = 28, Money = 30&#125;, userInof&#123;Age = 28, Money = 34&#125;, userInof&#123;Age = 27, Money = 28&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 流中对象是StringBuilder类型，属于可变对象，对它们进行的操作会影响流中的数据以及原始数据。</span></span><br><span class="line">List&lt;StringBuilder&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;apple&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;banana&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;cherry&quot;</span>));</span><br><span class="line">        list.stream().peek(stringBuilder -&gt; stringBuilder.append(<span class="string">&quot;apple&quot;</span>))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">appleapple</span></span><br><span class="line"><span class="comment">bananaapple</span></span><br><span class="line"><span class="comment">cherryapple</span></span><br><span class="line"><span class="comment">[appleapple, bananaapple, cherryapple]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<h4 id="3-6-3-peek-方法的时序图"><a href="#3-6-3-peek-方法的时序图" class="headerlink" title="3.6.3.peek()方法的时序图"></a>3.6.3.peek()方法的时序图</h4><p>针对前面的代码在peek()方法后执行forEach()方法时，输出顺序是先运行一次peek()方法，再运行一次forEach()方法，这样子迭代下去的这个问题，我们通过时序图来解释。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先初始化输入列表</span></span><br><span class="line">List&lt;String&gt; list1 = List.of(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">List&lt;String&gt; list2 = List.of(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">List&lt;String&gt; list3 = List.of(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">List&lt;String &gt; list4 =List.of(<span class="string">&quot;5&quot;</span>,<span class="string">&quot;4&quot;</span>);</span><br><span class="line">List&lt;List&lt;String&gt;&gt; list = List.of(list1,list2,list3,list4);</span><br><span class="line"><span class="comment">//开始执行操作</span></span><br><span class="line">List&lt;String&gt; listT = list.stream()</span><br><span class="line">        .flatMap(Collection::stream)</span><br><span class="line">        .peek(e -&gt; System.out.println(e)).filter(x -&gt; Integer.parseInt(x) &gt; <span class="number">2</span>)</span><br><span class="line">        .peek(e -&gt; System.out.println(e))</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240508120158.png"
                     
                ><br>通过时序图我们可以发现，由于中间操作peek()、filter()和flatMap()都是属于无状态，所以在流(Stream)中，对于每个元素，会先执行完整条流中的所有操作，然后才处理下一个元素。这意味着，对于每个元素，先运行完整条流中的操作链，然后再处理下一个元素。而不是等待所有元素的某个操作完成后再进行下一个操作。</p>
<h4 id="3-6-4-peek-方法的坑"><a href="#3-6-4-peek-方法的坑" class="headerlink" title="3.6.4.peek()方法的坑"></a>3.6.4.peek()方法的坑</h4><ul>
<li><p><strong>坑一：peek() 不影响流的生成和消费</strong><br>peek()是一个中间操作，它并不会终止流的处理流程，因此如果不跟一个终端操作（如collect(), forEach(), count()等），则peek()中的操作不会被执行，换言之，只有当流被消耗时，peek()里的操作才会真正发生。</p>
</li>
<li><p><strong>坑二：peek() 的执行次数取决于下游操作</strong><br>peek()方法中的动作会在流的每个元素上执行一次，但具体执行多少次取决于下游的终端操作。例如，如果你在排序(sorted())前使用了peek()，而在排序后又使用了一次peek()，则同一个元素可能会被两次peek()。</p>
</li>
<li><p><strong>坑三：并发流中的peek()行为</strong><br>对于并行流，peek()操作的执行顺序没有保证，而且可能会多次执行（取决于JVM的具体调度）。如果你在并行流中依赖peek()的顺序性或唯一性，可能会遇到意想不到的问题。</p>
</li>
<li><p><strong>坑四：资源管理</strong><br>如果在peek()中打开了一些资源（如文件、数据库连接等），但在peek()内部并未妥善关闭它们，可能会导致资源泄露。因为在没有终端操作的情况下，流可能不会立即执行，资源也就无法及时释放。</p>
</li>
<li><p><strong>坑五：对流元素的修改可能无效</strong><br>peek()通常用于读取或打印流元素，而不是修改它们。虽然理论上可以尝试在peek()中修改元素，但由于流的惰性求值和可能的不可变性，这样的修改可能不会反映到源集合或后续流操作中。</p>
</li>
<li><p><strong>坑六：对于可变对象的处理可能会影响流中的数据和原始数据</strong><br>peek()方法通常用于读取或打印流元素，而不是修改它们。然而，如果流中的元素是可变对象，并且在peek()中对其进行了修改，这些修改可能会影响到流中的数据以及原始数据。这是因为可变对象的特性使得对其进行的修改会在流中传递，可能会对后续的操作产生意外的影响。因此，在处理可变对象时，需要格外小心，并确保了解其对流处理的影响。</p>
</li>
</ul>
<h2 id="4-终结操作"><a href="#4-终结操作" class="headerlink" title="4.终结操作"></a>4.终结操作</h2><p>结束操作又可以分为<strong>短路操作</strong>与<strong>非短路操作</strong>，前者是指遇到某些符合条件的元素就可以得到最终结果；而后者是指必须处理所有元素才能得到最终结果。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240508163154.png"
                     
                ></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>forEach(Consumer&lt;? super T&gt; action)</code></td>
<td>遍历流中的元素，并对每个元素执行指定的操作。</td>
</tr>
<tr>
<td><code>findFirst()</code></td>
<td>返回流中的第一个元素，如果流为空，则返回一个空的Optional对象。</td>
</tr>
<tr>
<td><code>findAny()</code></td>
<td>返回流中的任意一个元素，如果流为空，则返回一个空的Optional对象。</td>
</tr>
<tr>
<td><code>anyMatch(Predicate&lt;? super T&gt; predicate)</code></td>
<td>判断流中是否存在至少一个元素满足指定的条件。返回一个boolean值。</td>
</tr>
<tr>
<td><code>allMatch(Predicate&lt;? super T&gt; predicate)</code></td>
<td>判断流中是否所有元素都满足指定的条件。返回一个boolean值。</td>
</tr>
<tr>
<td><code>noneMatch(Predicate&lt;? super T&gt; predicate)</code></td>
<td>判断流中是否没有元素满足指定的条件。返回一个boolean值。</td>
</tr>
<tr>
<td><code>reduce(BinaryOperator&lt;T&gt; accumulator)</code></td>
<td>将流中的元素按照指定的规则进行合并，返回合并后的结果。如果流为空，返回的 Optional 对象也为空。</td>
</tr>
<tr>
<td><code>reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code></td>
<td>对流中的元素进行累积操作，使用指定的初始值，并返回累积结果。如果流为空，返回的是初始值。</td>
</tr>
<tr>
<td><code>max(Comparator&lt;? super T&gt; comparator)</code></td>
<td>返回流中最大的元素，如果流为空，则返回一个空的Optional对象。</td>
</tr>
<tr>
<td><code>min(Comparator&lt;? super T&gt; comparator)</code></td>
<td>返回流中最小的元素，如果流为空，则返回一个空的Optional对象。</td>
</tr>
<tr>
<td><code>count</code></td>
<td>返回流中元素的数量【long类型】。</td>
</tr>
<tr>
<td><code>toArray()</code></td>
<td>将流中的元素转换为数组，返回一个数组。</td>
</tr>
<tr>
<td><code>toList()</code></td>
<td>将流中的元素转换为List，返回一个List。</td>
</tr>
<tr>
<td><code>collect(Collector&lt;? super T, A, R&gt; collector)</code></td>
<td>将流中的元素收集到一个容器中，返回该容器。方法中的参数<code>A</code>和<code>R</code>表示中间结果容器的类型和最终结果的类型。</td>
</tr>
</tbody></table>
<h3 id="4-1-遍历"><a href="#4-1-遍历" class="headerlink" title="4.1.遍历"></a>4.1.遍历</h3><p><code>forEach(Consumer&lt;? super T&gt; action)</code>：遍历流中的元素，并对每个元素执行指定的操作。【打印、计算、转换……】</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach遍历打印</span></span><br><span class="line">List&lt;Integer&gt; list1 = List.of(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>);</span><br><span class="line">list1.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach遍历求和</span></span><br><span class="line">List&lt;Integer&gt; list2 = List.of(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>);</span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(); <span class="comment">//将sum声明为AtomicInteger类型，因为AtomicInteger是原子性的，可以被匿名内部类访问。</span></span><br><span class="line">list2.forEach((Integer num) -&gt; sum.addAndGet(num));</span><br><span class="line">System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum); <span class="comment">// 输出 Sum: 27</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach遍历实现字母小写到大写的转换</span></span><br><span class="line">List&lt;String&gt; strings = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>);</span><br><span class="line">List&lt;String&gt; upperCaseStrings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">strings.forEach((String s) -&gt; upperCaseStrings.add(s.toUpperCase()));</span><br><span class="line">System.out.println(<span class="string">&quot;Upper case strings: &quot;</span> + upperCaseStrings); <span class="comment">// 输出 Upper case strings: [APPLE, BANANA, CHERRY]</span></span><br></pre></td></tr></table></figure></div>
<h3 id="4-2-匹配"><a href="#4-2-匹配" class="headerlink" title="4.2.匹配"></a>4.2.匹配</h3><ul>
<li><code>findFirst()</code>：返回流中的第一个元素，如果流为空，则返回一个空的Optional对象。</li>
<li><code>findAny()</code>：返回流中的任意一个元素，如果流为空，则返回一个空的Optional对象。</li>
<li><code>anyMatch(Predicate&lt;? super T&gt; predicate)</code>：判断流中是否存在至少一个元素满足指定的条件。返回一个boolean值。</li>
<li><code>allMatch(Predicate&lt;? super T&gt; predicate)</code>：判断流中是否所有元素都满足指定的条件。返回一个boolean值。</li>
<li><code>noneMatch(Predicate&lt;? super T&gt; predicate)</code>：判断流中是否没有元素满足指定的条件。返回一个boolean值。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 = List.of(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>);</span><br><span class="line">System.out.println(list1.stream().findFirst());<span class="comment">// 输出：Optional[3]</span></span><br><span class="line">System.out.println(list1.stream().findAny()); <span class="comment">// 输出：Optional[3]</span></span><br><span class="line">System.out.println(list1.stream().anyMatch(x -&gt; x % <span class="number">3</span> == <span class="number">0</span>));<span class="comment">// 输出：true</span></span><br><span class="line">System.out.println(list1.stream().allMatch(x -&gt; x % <span class="number">3</span> == <span class="number">0</span>));<span class="comment">// 输出：false</span></span><br><span class="line">System.out.println(list1.stream().noneMatch(x -&gt; x % <span class="number">3</span> == <span class="number">0</span>));<span class="comment">// 输出：false</span></span><br><span class="line"><span class="comment">// 如果流为空，则返回的 Optional 对象也为空。</span></span><br><span class="line">List&lt;Integer&gt; list2 = List.of();</span><br><span class="line">System.out.println(list2.stream().findFirst()); <span class="comment">// 输出：Optional.empty</span></span><br><span class="line">System.out.println(list2.stream().findAny());<span class="comment">// 输出：Optional.empty</span></span><br><span class="line">System.out.println(list2.stream().anyMatch(x -&gt; x % <span class="number">3</span> == <span class="number">0</span>));<span class="comment">// 输出：false</span></span><br><span class="line">System.out.println(list2.stream().allMatch(x -&gt; x % <span class="number">3</span> == <span class="number">0</span>)); <span class="comment">// 输出：true</span></span><br><span class="line">System.out.println(list2.stream().noneMatch(x -&gt; x % <span class="number">3</span> == <span class="number">0</span>));<span class="comment">// 输出：true</span></span><br><span class="line"><span class="comment">// 如果list是null,在执行流操作时，会抛出NullPointerException异常。</span></span><br></pre></td></tr></table></figure></div>

<h3 id="4-3-规约"><a href="#4-3-规约" class="headerlink" title="4.3.规约"></a>4.3.规约</h3><ul>
<li><code>reduce(BinaryOperator&lt;T&gt; accumulator)</code>：将流中的元素按照指定的规则进行合并，返回合并后的结果。如果流为空，返回的 Optional 对象也为空。<ul>
<li>参数：<code>BinaryOperator&lt;T&gt; accumulator</code>,<code>BinaryOperator</code>继承于 <code>BiFunction</code>, 这里实现 <code>BiFunction.apply(param1,param2)</code> 接口即可。支持lambda表达式，形如：(result,item)-&gt;{…} 。</li>
<li>返回值：返回Optional对象，由于结果存在空指针的情况（当集合为空时）因此需要使用Optional。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"> List&lt;Integer&gt; list=List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//将数组进行累加求和</span></span><br><span class="line"><span class="comment">//由于返回的是 Optional ，因此需要get()取出值。</span></span><br><span class="line">Integer total=list.stream().reduce((result,item)-&gt;result+item).get();</span><br><span class="line">System.out.println(total)</span><br><span class="line"> <span class="comment">// 输出：15</span></span><br><span class="line"> </span><br><span class="line"> List&lt;String&gt; strings = List.of(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line"> <span class="comment">// 使用 reduce 方法将字符串列表中的字符串拼接成一个新的字符串</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> strings.stream().reduce(<span class="string">&quot;&quot;</span>, (partialResult, str) -&gt; partialResult + str);</span><br><span class="line"> System.out.println(result);</span><br><span class="line"> <span class="comment">// 输出：Hello World!</span></span><br></pre></td></tr></table></figure></div></li>
<li><code>reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code>：对流中的元素进行累积操作，使用指定的初始值，并返回累积结果。如果流为空，返回的是初始值.<ul>
<li>参数1：T identity 为一个初始值（默认值） ，当集合为空时，就返回这个默认值，当集合不为空时，该值也会参与计算。</li>
<li>参数2：BinaryOperator<T> accumulator 这个与一个参数的reduce相同。</li>
<li>返回值：并非 Optional，由于有默认值 identity ，因此计算结果不存在空指针的情况。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list=List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">Integer total=list.stream().reduce(<span class="number">0</span>,(result,item)-&gt;result+item);</span><br><span class="line">System.out.println(total);<span class="comment">//结果为：15 </span></span><br><span class="line"></span><br><span class="line">list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">total=list.stream().reduce(<span class="number">0</span>,(result,item)-&gt;result+item);</span><br><span class="line">System.out.println(total);<span class="comment">//数组为空时，结果返回默认值0  </span></span><br></pre></td></tr></table></figure></div></li>
<li><code>reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator,BinaryOperator&lt;U&gt; combiner)</code>：这个方法允许更复杂的规约操作，可以用于计算任意类型的累加器值，而不仅仅是原始数据类型。同时，<strong>由于存在并行执行的可能性，需要确保累加器函数和组合器函数的实现是线程安全的</strong>。<ul>
<li>第一个参数和第二个参数的定义同上，第三个参数比较特殊，后面慢慢讲。</li>
<li>可以看到该方法有两个泛型 T 和 U ：<br>（1）泛型T是集合中元素的类型，<br>（2）泛型U是计算之后返回结果的类型，U的类型由第一个参数 identity 决定。<br>也就是说，三个参数的reduce()可以返回与集合中的元素不同类型的值，方便我们对复杂对象做计算式和转换。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; list= List.of(</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">1</span>)</span><br><span class="line">              ,<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">2</span>)</span><br><span class="line">              ,<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">3</span>)</span><br><span class="line">              ,<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>,<span class="number">4</span>)</span><br><span class="line">              ,<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小红&quot;</span>,<span class="number">5</span>));</span><br><span class="line">Integer total=list.stream()</span><br><span class="line">        .reduce(</span><br><span class="line">                Integer.valueOf(<span class="number">0</span>)  <span class="comment">/*初始值 identity*/</span></span><br><span class="line">                ,(integer, person)-&gt;integer+ person.getAge() <span class="comment">/*累加计算 accumulator*/</span></span><br><span class="line">                ,(integer1,integer2)-&gt;integer1+integer2 <span class="comment">/*第三个参数 combiner*/</span></span><br><span class="line">        );</span><br><span class="line">System.out.println(total);<span class="comment">//结果：15</span></span><br></pre></td></tr></table></figure></div>
<p>其实这相当于</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Integer total=list.stream().mapToInt(Person::getAge).sum();</span><br><span class="line">System.out.println(total);<span class="comment">//结果也是：15  </span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>第三个参数 <code>BinaryOperator&lt;U&gt; combiner</code> 是个什么鬼？<br>这个参数的lambda表达式我是这么写的：<code>(integer1,integer2)-&gt;integer1+integer2</code><br>现在我将其打印出来：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Integer total=list.stream()</span><br><span class="line">        .reduce(</span><br><span class="line">                Integer.valueOf(<span class="number">0</span>)</span><br><span class="line">                ,(integer, person)-&gt;integer+ person.getAge()</span><br><span class="line">                ,(integer1,integer2)-&gt; &#123;</span><br><span class="line">                    <span class="comment">//这个println居然没有执行！！！</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;integer1=&quot;</span> + integer1 + <span class="string">&quot;, integer2=&quot;</span> + integer2);</span><br><span class="line">                    <span class="keyword">return</span> integer1 + integer2;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">System.out.println(total);<span class="comment">//结果：15</span></span><br></pre></td></tr></table></figure></div>
<p>发现这个参数的lambda表达式根本就没有执行？！<br>我换了一种方式，换成 parallelStream ，然后把线程id打印出来：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Integer total=list.parallelStream()</span><br><span class="line">        .reduce(</span><br><span class="line">                  Integer.valueOf(<span class="number">0</span>)</span><br><span class="line">                ,(integer, person)-&gt;integer+ person.getAge()</span><br><span class="line">                ,(integer1,integer2)-&gt; &#123;</span><br><span class="line">                      <span class="comment">//由于用的 parallelStream ，可发生并行计算，所以我增加线程id的打印：</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;threadId=&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;, integer1=&quot;</span>+integer1+<span class="string">&quot;, integer2=&quot;</span>+integer2);</span><br><span class="line">                    <span class="keyword">return</span> integer1 + integer2;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">System.out.println(total);</span><br><span class="line"><span class="comment">/*结果如下：</span></span><br><span class="line"><span class="comment">threadId=1, integer1=4, integer2=5</span></span><br><span class="line"><span class="comment">threadId=30, integer1=1, integer2=2</span></span><br><span class="line"><span class="comment">threadId=1, integer1=3, integer2=9</span></span><br><span class="line"><span class="comment">threadId=1, integer1=3, integer2=12</span></span><br><span class="line"><span class="comment">15*/</span></span><br></pre></td></tr></table></figure></div>
<p>把 stream 换成并行的 parallelStream，<br>可以看出，有两个线程在执行任务：线程1和线程30 ，<br>每个线程会分配几个元素做计算，<br>如上面的线程30分配了元素1和2，线程1分配了3、4、5。<br>至于线程1为什么会有两个3，是由于线程30执行完后得到的结果为3（1+2），而这个3又会作为后续线程1的入参进行汇总计算。<br>可以多跑几次，每次执行的结果不一定相同，如果看不出来规律，可以尝试增加集合中的元素个数，数据量大更有利于并行计算发挥作用。</p>
<p><mark>因此，第三个参数 <code>BinaryOperator&lt;U&gt; combiner</code> 的作用为：汇总所有线程的计算结果得到最终结果，</mark><br>并行计算会启动多个线程执行同一个计算任务，每个线程计算完后会有一个结果，最后要将这些结果汇总得到最终结果。</p>
<p>我们再来看一个有意思的结果，把第一个参数 identity 从0换成1：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Integer total=list.parallelStream()</span><br><span class="line">    .reduce(</span><br><span class="line">                    Integer.valueOf(<span class="number">1</span>)</span><br><span class="line">            ,(integer, person)-&gt;&#123; System.out.println(<span class="string">&quot;$ threadId=&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;, integer=&quot;</span>+integer+<span class="string">&quot;, scoreBean.getScore()=&quot;</span>+person.getAge());</span><br><span class="line">                      <span class="keyword">return</span> integer+ person.getAge();&#125;</span><br><span class="line">                  ,(integer1,integer2)-&gt; &#123;</span><br><span class="line">                            <span class="comment">//由于用的 parallelStream ，可发生并行计算，所以我增加线程id的打印：</span></span><br><span class="line">                      System.out.println(<span class="string">&quot;threadId=&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;, integer1=&quot;</span>+integer1+<span class="string">&quot;, integer2=&quot;</span>+integer2);</span><br><span class="line">                      <span class="keyword">return</span> integer1 + integer2;</span><br><span class="line">                  &#125;</span><br><span class="line">          );</span><br><span class="line">  System.out.println(total);</span><br><span class="line">  <span class="comment">/*结果如下：</span></span><br><span class="line"><span class="comment">  $ threadId=30, integer=1, scoreBean.getScore()=2</span></span><br><span class="line"><span class="comment">  $ threadId=1, integer=1, scoreBean.getScore()=3</span></span><br><span class="line"><span class="comment">  $ threadId=32, integer=1, scoreBean.getScore()=5</span></span><br><span class="line"><span class="comment">  $ threadId=33, integer=1, scoreBean.getScore()=4</span></span><br><span class="line"><span class="comment">  $ threadId=31, integer=1, scoreBean.getScore()=1</span></span><br><span class="line"><span class="comment">  threadId=33, integer1=5, integer2=6</span></span><br><span class="line"><span class="comment">  threadId=31, integer1=2, integer2=3</span></span><br><span class="line"><span class="comment">  threadId=33, integer1=4, integer2=11</span></span><br><span class="line"><span class="comment">  threadId=33, integer1=5, integer2=15</span></span><br><span class="line"><span class="comment">  20*/</span></span><br></pre></td></tr></table></figure></div>
<p>预期结果应该是16（初始值1+原来的结果15），但实际结果为20，多加了4次1，猜测是多加了四次初始值，<br>从打印的结果可以发现：<br>（1）并行计算时用了5个线程（线程id依次为：30, 1, 32, 33, 31），汇总合并时用了两个线程（线程id为33和31）<br>（2）并行计算的每一个线程都用了初始值参与计算，因此多加了4次初始值。</p>
<blockquote>
<p>总结：<br>使用 parallelStream 时，初始值 identity 应该设置一个不影响计算结果的值，比如本示例中设置为 0 就不会影响结果。<br>我觉得这个初始值 identity 有两个作用：<code>确定泛型U的类型</code> 和 <code>避免空指针</code>。<br>但是如果初始值本身就是一个复杂对象那该怎么办呢？<br>比如是初始值是一个数组，那么应该设定为一个空数组。如果是其他复杂对象那就得根据你reduce的具体含义来设定初始值了。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t) </span><br><span class="line"><span class="comment">//combiner.apply(u1,u2) 接收两个相同类型U的参数 </span></span><br><span class="line"><span class="comment">//accumulator.apply(u, t) 接收两个不同类型的参数U和T，U是返回值的类型，T是集合中元素的类型</span></span><br><span class="line"><span class="comment">//这个等式恒等，parallelStream计算时就不会产生错误结果</span></span><br></pre></td></tr></table></figure></div></blockquote>
<h3 id="4-4-聚合"><a href="#4-4-聚合" class="headerlink" title="4.4.聚合"></a>4.4.聚合</h3><ul>
<li><code>max(Comparator&lt;? super T&gt; comparator)</code>: 返回流中最大的元素，如果流为空，则返回一个空的Optional对象。</li>
<li><code>max(Comparator&lt;? super T&gt; comparator)</code>: 返回流中最小的元素，如果流为空，则返回一个空的Optional对象。</li>
<li><code>count()</code>: 返回个数【long类型】</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line">  System.out.println(list.stream().max(Integer::compare));<span class="comment">// 输出：Optional[5]</span></span><br><span class="line">  System.out.println(list.stream().min(Comparator.comparing(Integer::intValue)).get());<span class="comment">// 输出：1</span></span><br><span class="line">  System.out.println(list.stream().count());<span class="comment">// 输出：5</span></span><br><span class="line">  list = List.of();</span><br><span class="line">  System.out.println(list.stream().max(Integer::compare));<span class="comment">// 输出：Optional.empty</span></span><br></pre></td></tr></table></figure></div>

<h3 id="4-5-收集"><a href="#4-5-收集" class="headerlink" title="4.5.收集"></a>4.5.收集</h3><h4 id="4-5-1-toArray"><a href="#4-5-1-toArray" class="headerlink" title="4.5.1.toArray"></a>4.5.1.toArray</h4><ul>
<li><code>toArray()</code>: 返回一个Object[]数组，其中包含Stream中的所有元素。</li>
<li><code>toArray(IntFunction&lt;A[]&gt; generator)</code>：可以指定返回数组的类型。参数 generator 是一个数组生成器函数，它根据提供的数组长度创建一个新数组。这使得我们可以在返回的数组中指定元素的类型。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; list = List.of(</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>),</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">24</span>),</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">25</span>)</span><br><span class="line">     );</span><br><span class="line">     Object[] array1 =list.stream().toArray();</span><br><span class="line">     System.out.println(Arrays.toString(array1));</span><br><span class="line">     <span class="comment">// 输出：[Person&#123;name = 张三, age = 23&#125;, Person&#123;name = 李四, age = 24&#125;, Person&#123;name = 王五, age = 25&#125;]</span></span><br><span class="line">     Person[] array2 = list.stream().toArray(v -&gt; <span class="keyword">new</span> <span class="title class_">Person</span>[v]);</span><br><span class="line">     System.out.println(Arrays.toString(array2));</span><br><span class="line">     <span class="comment">// 输出：[Person&#123;name = 张三, age = 23&#125;, Person&#123;name = 李四, age = 24&#125;, Person&#123;name = 王五, age = 25&#125;]</span></span><br></pre></td></tr></table></figure></div>
<h4 id="4-5-2-toList"><a href="#4-5-2-toList" class="headerlink" title="4.5.2.toList"></a>4.5.2.toList</h4><ul>
<li><code>toList()</code>: 返回一个包含Stream中所有元素的List。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Stream.of(<span class="number">32</span>, <span class="number">11</span>, <span class="number">23</span>, <span class="number">434</span>, <span class="number">54</span>).toList();</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// 输出：[32, 11, 23, 434, 54]</span></span><br></pre></td></tr></table></figure></div>

<h4 id="4-5-3-collect"><a href="#4-5-3-collect" class="headerlink" title="4.5.3.collect"></a>4.5.3.collect</h4><ul>
<li><code>collect(Collector&lt;? super T, A, R&gt; collector)</code>: 将Stream中的元素收集到一个容器中，并返回该容器。</li>
</ul>
<h5 id="4-5-3-1-统计"><a href="#4-5-3-1-统计" class="headerlink" title="4.5.3.1.统计"></a>4.5.3.1.统计</h5><ul>
<li><code>Collectors.counting()</code>: 返回流中元素的个数。</li>
<li><code>Collectors.summingInt(ToIntFunction&lt;? super T&gt; mapper)</code>: 返回流中元素的和。</li>
<li><code>Collectors.summingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code>: 返回流中元素的和。</li>
<li><code>Collectors.summingLong(ToLongFunction&lt;? super T&gt; mapper)</code>: 返回流中元素的和。</li>
<li><code>Collectors.averagingInt(ToIntFunction&lt;? super T&gt; mapper)</code>: 返回流中元素的平均值。</li>
<li><code>Collectors.averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code>: 返回流中元素的平均值。</li>
<li><code>Collectors.averagingLong(ToLongFunction&lt;? super T&gt; mapper)</code>: 返回流中元素的平均值。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 个数</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">collect</span> <span class="operator">=</span> numbers.stream().collect(Collectors.counting());</span><br><span class="line">System.out.println(<span class="string">&quot;collect = &quot;</span> + collect);<span class="comment">// collect = 5</span></span><br><span class="line"><span class="comment">// 求和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream().collect(Collectors.summingInt(Integer::intValue));</span><br><span class="line">System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum);<span class="comment">// Sum: 15</span></span><br><span class="line"><span class="comment">// 平均值</span></span><br><span class="line"><span class="type">double</span> <span class="variable">average</span> <span class="operator">=</span> numbers.stream().collect(Collectors.averagingInt(Integer::intValue));</span><br><span class="line">System.out.println(<span class="string">&quot;Average: &quot;</span> + average);<span class="comment">// Average: 3.0</span></span><br></pre></td></tr></table></figure></div>
<h5 id="4-5-3-2分组"><a href="#4-5-3-2分组" class="headerlink" title="4.5.3.2分组"></a>4.5.3.2分组</h5><ul>
<li><code>Collectors.groupingBy(Function&lt;? super T, ? extends K&gt; classifier)</code>: 根据给定的分类函数对Stream中的元素进行分组，并返回一个Map，其中键是分类函数的结果，值是包含对应分类的元素的List。</li>
<li><code>Collectors.partitioningBy(Predicate&lt;? super T&gt; predicate)</code>: 根据给定的断言函数对Stream中的元素进行分区，并返回一个Map，其中键是true和false，值是包含对应分类的元素的List。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; words = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按单词的首字母分组</span></span><br><span class="line">Map&lt;Character, List&lt;String&gt;&gt; groupedByFirstLetter = words.stream()</span><br><span class="line">        .collect(Collectors.groupingBy(word -&gt; word.charAt(<span class="number">0</span>)));</span><br><span class="line">System.out.println(<span class="string">&quot;Grouped by first letter: &quot;</span> + groupedByFirstLetter);</span><br><span class="line"><span class="comment">// 输出：Grouped by first letter: &#123;a=[apple], b=[banana], c=[cherry], g=[grape], o=[orange]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按单词的长度进行分区</span></span><br><span class="line">Map&lt;Boolean, List&lt;String&gt;&gt; partitionedByLength = words.stream()</span><br><span class="line">        .collect(Collectors.partitioningBy(word -&gt; word.length() &gt; <span class="number">5</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;Partitioned by length (&gt;5): &quot;</span> + partitionedByLength);</span><br><span class="line"><span class="comment">//输出：Partitioned by length (&gt;5): &#123;false=[apple, grape], true=[banana, orange, cherry]&#125;</span></span><br></pre></td></tr></table></figure></div>

<h5 id="4-5-3-3连接"><a href="#4-5-3-3连接" class="headerlink" title="4.5.3.3连接"></a>4.5.3.3连接</h5><ul>
<li><code>Collectors.joining(CharSequence delimiter)</code>: 将stream中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; list = List.of(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">24</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">25</span>)</span><br><span class="line">      );</span><br><span class="line"><span class="type">String</span> <span class="variable">collect</span> <span class="operator">=</span> list.stream().map(p -&gt; p.getName()).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">System.out.println(collect);<span class="comment">// 张三,李四,王五</span></span><br><span class="line">List&lt;String&gt; list1 = List.of(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">collect1</span> <span class="operator">=</span> list1.stream().collect(Collectors.joining(<span class="string">&quot;-&quot;</span>));</span><br><span class="line">System.out.println(collect1);<span class="comment">// A-B-C</span></span><br></pre></td></tr></table></figure></div>
<h5 id="4-5-3-4-规约"><a href="#4-5-3-4-规约" class="headerlink" title="4.5.3.4.规约"></a>4.5.3.4.规约</h5><p>Collectors类提供的reducing方法，相比于stream本身的reduce方法，增加了对自定义归约的支持。</p>
<ul>
<li><strong><code>Collectors.reducing(BinaryOperator&lt;T&gt; op)</code></strong>：这是最基本的 <code>reducing</code> 方法。它接受一个二元运算符，对流中的所有元素进行归约。该方法将返回一个收集器Optional，它使用提供的运算符对流中的元素进行归约。</li>
<li><strong><code>Collectors.reducing(T identity, BinaryOperator&lt;T&gt; op)</code></strong>：此方法是 <code>reducing</code> 方法的扩展，允许你指定一个初始值。提供的初始值将用作归约操作的起始值。如果流为空，则结果将是提供的初始值。</li>
<li><strong><code>Collectors.reducing(U identity, Function&lt;? super T, ? extends U&gt; mapper, BinaryOperator&lt;U&gt; op)</code></strong>：这个方法允许你在进行归约之前先将元素映射到另一种类型。你可以指定一个映射函数，并提供一个初始值。然后，它将使用映射函数将元素映射为指定类型，再使用提供的初始值对映射后的结果进行归约。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只传一个参数：定义运算规则</span></span><br><span class="line">System.out.println(list.stream().collect(Collectors.reducing(Integer::sum)));<span class="comment">// Optional[10]</span></span><br><span class="line"><span class="comment">// 等价于：System.out.println(list.stream().reduce(Integer::sum));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递两个参数：定义一个初始值和运算规则</span></span><br><span class="line">System.out.println(list.stream().collect(Collectors.reducing(<span class="number">0</span>, Integer::sum)));<span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 等价于：System.out.println(list.stream().reduce(0, Integer::sum));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递三个参数：定义一个初始值、映射函数和运算规则</span></span><br><span class="line">System.out.println(list.stream().collect(Collectors.reducing(<span class="number">0</span>, x -&gt; x * x, Integer::sum))); <span class="comment">//10</span></span><br><span class="line"><span class="comment">// 等价于：System.out.println(list.stream().map(x -&gt; x * x).reduce(0, Integer::sum));先映射在规约</span></span><br></pre></td></tr></table></figure></div>

<h5 id="4-5-3-5-归集"><a href="#4-5-3-5-归集" class="headerlink" title="4.5.3.5.归集"></a>4.5.3.5.归集</h5><ul>
<li><code>Collectors.toList()</code>: 将Stream中的元素收集到一个List中，并返回该List,元素可以重复,有序。</li>
<li><code>Collectors.toSet()</code>: 将Stream中的元素收集到一个Set中，并返回该Set，元素不能重复，无序</li>
<li><code>Collectors.toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper)</code>: 将Stream中的元素收集到一个Map中，并返回该Map。如果键重复会抛出 IllegalStateException 异常<ul>
<li>参数一表示键的生成规则</li>
<li>参数二表示值的生成规则</li>
<li><strong>Function</strong><ul>
<li>泛型一：表示流中每一个数据的类型</li>
<li>泛型二：表示Map集合中键的数据类型</li>
</ul>
</li>
<li><strong>重写方法apply</strong><ul>
<li>形参：依次表示流里面的每一个数据</li>
<li>方法体：生成键&#x2F;值的代码</li>
<li>返回值：已经生成的键&#x2F;值</li>
</ul>
</li>
</ul>
</li>
<li><code>Collectors.toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction)</code>: 收集到 Map 集合中，允许指定一个合并函数来处理键冲突。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list, <span class="string">&quot;张无忌-男-15&quot;</span>, <span class="string">&quot;周芷若-女-14&quot;</span>, <span class="string">&quot;赵敏-女-13&quot;</span>, <span class="string">&quot;张强-男-20&quot;</span>,</span><br><span class="line">        <span class="string">&quot;张三丰-男-100&quot;</span>, <span class="string">&quot;张翠山-男-40&quot;</span>, <span class="string">&quot;张良-男-35&quot;</span>, <span class="string">&quot;王二麻子-男-37&quot;</span>, <span class="string">&quot;谢广坤-男-41&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//收集List集合当中</span></span><br><span class="line"><span class="comment">//需求：</span></span><br><span class="line"><span class="comment">//我要把所有的男性收集起来</span></span><br><span class="line">List&lt;String&gt; newList1 = list.stream()</span><br><span class="line">        .filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(newList1);<span class="comment">// [张无忌-男-15, 张强-男-20, 张三丰-男-100, 张翠山-男-40, 张良-男-35, 王二麻子-男-37, 谢广坤-男-41]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//收集Set集合当中</span></span><br><span class="line"><span class="comment">//需求：</span></span><br><span class="line"><span class="comment">//我要把所有的男性收集起来</span></span><br><span class="line">Set&lt;String&gt; newList2 = list.stream().filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">        .collect(Collectors.toSet());</span><br><span class="line">System.out.println(newList2);<span class="comment">// [张强-男-20, 张良-男-35, 张三丰-男-100, 张无忌-男-15, 谢广坤-男-41, 张翠山-男-40, 王二麻子-男-37]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//收集Map集合当中</span></span><br><span class="line"><span class="comment">//我要把所有的男性收集起来</span></span><br><span class="line"><span class="comment">//键：姓名。 值：年龄</span></span><br><span class="line">Map&lt;String, Integer&gt; map = list.stream()</span><br><span class="line">        .filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))                </span><br><span class="line">        .collect(Collectors.toMap(</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, String&gt;() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Integer&gt;() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> Integer.parseInt(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">2</span>]);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;));</span><br><span class="line">System.out.println(map); <span class="comment">// &#123;张强=20, 张良=35, 张翠山=40, 王二麻子=37, 张三丰=100, 张无忌=15, 谢广坤=41&#125;</span></span><br><span class="line"><span class="comment">// lambda表达式简化</span></span><br><span class="line">Map&lt;String, Integer&gt; map2 = list.stream()</span><br><span class="line">        .filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">        .collect(Collectors.toMap(</span><br><span class="line">                s -&gt; s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>],</span><br><span class="line">                s -&gt; Integer.parseInt(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">2</span>])));</span><br><span class="line"></span><br><span class="line">System.out.println(map2); <span class="comment">// &#123;张强=20, 张良=35, 张翠山=40, 王二麻子=37, 张三丰=100, 张无忌=15, 谢广坤=41&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集到 Map 集合中，处理键冲突</span></span><br><span class="line">List&lt;Person&gt; persons = List.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">35</span>)</span><br><span class="line">        );</span><br><span class="line">Map&lt;String, Integer&gt; personMapWithMergeFunction = persons.stream()</span><br><span class="line">        .collect(Collectors.toMap(Person::getName, Person::getAge, (existing, replacement) -&gt; existing));<span class="comment">// 如果已经存在，保留原先存在的值</span></span><br><span class="line">System.out.println(personMapWithMergeFunction); <span class="comment">// &#123;Alice=30, Bob=25&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="5-Java-Stream-底层实现"><a href="#5-Java-Stream-底层实现" class="headerlink" title="5.Java Stream 底层实现"></a>5.Java Stream 底层实现</h2><p><strong>参考文章：</strong><a class="link"   href="https://www.cnblogs.com/CarpenterLee/p/6637118.html" >深入理解Java Stream流水线<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <tags>
        <tag>学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SHA-256 使用教程</title>
    <url>/2024/07/16/%E4%BD%BF%E7%94%A8SHA-256%E5%8A%A0%E5%AF%86%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="SHA-256-使用教程"><a href="#SHA-256-使用教程" class="headerlink" title="SHA-256 使用教程"></a>SHA-256 使用教程</h2><h3 id="引入Maven依赖"><a href="#引入Maven依赖" class="headerlink" title="引入Maven依赖"></a>引入Maven依赖</h3><div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SHA-256加密--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.17.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> DigestUtils.sha256Hex(<span class="string">&quot;123456&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>这里的 <code>DigestUtils</code>类需要使用 apache 下的，而不是 spring-framework</p>
]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>工具集</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2024/03/15/java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="不同类型数组的初始化值"><a href="#不同类型数组的初始化值" class="headerlink" title="不同类型数组的初始化值"></a>不同类型数组的初始化值</h3><p>  整数型：默认初始化值<strong>0</strong><br>  小数型：默认初始化值<strong>0.0</strong><br>  字符型：默认初始化值<code>/u0000</code>,即<strong>空格</strong><br>  布尔型：默认初始化值 <strong>false</strong><br>  引用型(除上面类型之外)：默认初始化值<strong>null</strong></p>
<h3 id="基本数据类型和引用数据类型的区别"><a href="#基本数据类型和引用数据类型的区别" class="headerlink" title="基本数据类型和引用数据类型的区别"></a>基本数据类型和引用数据类型的区别</h3><ol>
<li><p><strong>基本数据类型（Primitive Types）：</strong></p>
<ul>
<li>Java的基本数据类型是预定义的，并且它们是直接存储数据值的。</li>
<li>基本数据类型包括整型（int、short、long、byte）、浮点型（float、double）、字符型（char）和布尔型（boolean）。</li>
<li>基本数据类型的变量存储的是实际的数据值，它们在内存中的存储是在栈（Stack）中。</li>
<li><strong>基本数据类型是值传递，传递的是实际的数据值。</strong></li>
</ul>
</li>
<li><p><strong>引用类型（Reference Types）：</strong></p>
<ul>
<li>引用类型是由类（Class）、接口（Interface）、数组（Array）和枚举（Enum）等引用数据类型所构成的。</li>
<li>引用类型的变量存储的是对象的引用（内存地址），而不是对象本身的实际数据。</li>
<li>引用类型的对象在内存中的存储是在堆（Heap）中。</li>
<li>引用类型的变量本质上是指向对象的引用，它们可以指向同一个对象，也可以指向不同的对象。</li>
<li><strong>引用类型是对象的引用传递，传递的是对象的引用。</strong></li>
</ul>
</li>
</ol>
<blockquote>
<p>   区别总结如下：</p>
<ul>
<li><strong>基本数据类型</strong>（Primitive Types）：<ul>
<li>存储的是实际的数据值。</li>
<li>在内存中存储在栈中。</li>
<li>是值传递，传递的是实际的数据值。</li>
</ul>
</li>
<li><strong>引用类型</strong>（Reference Types）：<ul>
<li>存储的是对象的引用（内存地址）。</li>
<li>对象存储在堆中。</li>
<li>是引用传递，传递的是对象的引用。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="idea的常用快捷键"><a href="#idea的常用快捷键" class="headerlink" title="idea的常用快捷键"></a>idea的常用快捷键</h3><ul>
<li><code>Ctrl + P</code>:查看形参</li>
<li><code>Ctrl + D</code>:复制当前行到下一行</li>
<li><code>Ctrl + Y</code>:删除代码</li>
<li><code>Ctrl + Shift + ,</code>:一键生成标准的JavaBean代码[需要下载ptg插件]</li>
<li><code>Alt + Insert</code>:生成标准的JavaBean代码</li>
<li><code>Ctrl + Alt + V</code>:自动将该表达式或代码块提取为一个新的变量</li>
<li><code>Ctrl + Alt + L</code>:格式化代码</li>
<li><code>Ctrl + Alt + M</code>:提取方法</li>
<li><code>Alt + Enter</code>:快速修复</li>
<li><code>Ctrl + Insert</code>:自动生成代码</li>
<li><code>Tab</code>:自动补全代码</li>
<li><code>Ctrl + B</code>:跳转到声明处</li>
<li><code>Ctrl + Alt + T</code>:选定结构(<code>if</code>语句,<code>while</code>语句)</li>
<li><code>Alt + 鼠标拖动</code>:多重选择[对多个对象同时进行删除或修改]</li>
<li><code>Ctrl + Shift + ↑/↓ </code>:代码上下移动</li>
<li><code>选中 + Shift + F6</code>:向下整体修改</li>
<li><code>Ctrl + N</code>:查找并导航到指定的类</li>
<li><code>Ctrl + F12</code>:调出当前编辑文件的结构视图或者是类的成员列表</li>
<li><code>Ctrl + 鼠标点击</code>：点击方法的话可以查看在当前项目中哪里被引用，如果再次之上在按下快捷键 <code>Ctrl + Alt +F7</code>，可以查看在项目和仓库中哪里被引用</li>
<li><code>Ctrl + Alt + 向左</code>：返回上一张页面</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区：<strong>用于描述存储已被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据的内存区域</strong><br>永久代(JDK8以前)&#x2F;元空间(JDK8及以后)：<strong>是方法区的具体实现</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240413115206.png"
                     
                ></p>
<blockquote>
<p><strong><mark>在JDK 8之前，方法区的实现通常是永久代。而在JDK 8及之后，方法区的实现主要是元空间。</mark></strong></p>
<p>将永久代替换为元空间的主要原因是解决了永久代存在的一些问题，使Java虚拟机更适应现代应用程序的需求。</p>
<ol>
<li><p><strong>内存管理方式</strong>：</p>
<ul>
<li><strong>永久代</strong>：<mark>永久代的内存空间是在Java堆内的一部分</mark>，它受到了Java堆内存的大小限制。</li>
<li><strong>元空间</strong>：<mark>元空间通常位于本地内存中</mark>，不再与Java堆绑定，因此不受Java堆内存的限制。这使得元空间可以根据需要动态扩展，避免了永久代固定大小带来的限制。</li>
</ul>
</li>
<li><p><strong>垃圾回收机制</strong>：</p>
<ul>
<li><strong>永久代</strong>：<mark>永久代中的垃圾回收通常由Full GC（全局垃圾回收）来执行</mark>，效率较低，并且可能会导致长时间的停顿。</li>
<li><strong>元空间</strong>：元空间的内存管理不再依赖于Java虚拟机的垃圾回收机制，而是<mark>由本地内存的管理机制来负责</mark>。这降低了垃圾回收的成本，并提高了应用程序的性能和稳定性。</li>
</ul>
</li>
<li><p><strong>动态调整大小</strong>：</p>
<ul>
<li><strong>永久代</strong>：<mark>永久代的大小是固定的，无法动态调整</mark>。这可能会导致在某些情况下出现永久代溢出的问题。</li>
<li><strong>元空间</strong>：<mark>元空间可以根据应用程序的需要动态调整大小，不再受到固定大小的限制</mark>。这提高了虚拟机的灵活性，并减少了出现内存溢出的风险。</li>
</ul>
</li>
<li><p><strong>存储内容</strong>：</p>
<ul>
<li><strong>永久代</strong>：永久代主要用于存储类的元数据信息和静态变量。</li>
<li><strong>元空间</strong>：元空间用于存储类的元数据信息，例如类的结构、方法信息、注解等。<mark>与永久代相比，元空间更加灵活，并且可以存储更多类型的元数据信息</mark>。</li>
</ul>
</li>
</ol>
<p>总的来说，替换永久代为元空间是为了提高Java虚拟机在处理大量类加载和卸载操作时的性能和可用性。元空间的动态调整大小、本地内存管理以及不依赖于Java虚拟机的垃圾回收机制等特性，使得它更适合应对现代应用程序的需求。</p>
</blockquote>
<h3 id="串池"><a href="#串池" class="headerlink" title="串池"></a>串池</h3><p><strong>基本概念</strong>：</p>
<ul>
<li>串池（String Pool）是Java中的一种特殊的内存区域，用于存储字符串常量。它是字符串常量池的另一种称呼，因为在Java中，字符串常量池主要用于存储字符串常量。[串池中的字符串是不可变的]</li>
<li>当我们创建一个字符串常量时，如果该字符串常量在字符串常量池中不存在，则会在字符串常量池中创建一个新的字符串对象，并将该字符串常量放入其中。如果字符串常量池中已经存在相同内容的字符串对象，则不会创建新的对象，而是直接返回已存在的对象的引用。[<strong>只有一份，全局共享</strong>]</li>
<li>只有<code>String</code>类型的字符串才会被添加到字符串常量池中。<code>StringBuffer</code>和<code>StringBuilder</code>类型的字符串不会自动添加到字符串常量池中。这是因为 StringBuffer 和 StringBuilder 是可变的字符串，它们的内容在运行时可以被修改，而字符串常量池中的字符串是不可变的。</li>
</ul>
<p><strong>内存管理</strong>：</p>
<ul>
<li>在JDK7版本开始从方法区中挪到了堆内存</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h4><p>Java字符串就是Unicode字符序列。Java里没有内置的字符串类型，而是在标准的类库中提供了一个预定义类，String。每个用<strong>双引号””括起来</strong>的都是<strong>String类的一个实例</strong>。<br>字符串在日常开发中最常用， Java字符串的一个重要特点就是<strong>字符串不可变</strong></p>
<h4 id="2-字符串的创建"><a href="#2-字符串的创建" class="headerlink" title="2 字符串的创建"></a>2 字符串的创建</h4><ul>
<li>通过字符串字面量创建字符串常量。</li>
<li>通过调用String类的构造函数。</li>
<li>使用字符串连接运算符<code>+</code>创建字符串。[底层通常是使用StringBuilder(或 StringBuffer)进行字符串的拼接]</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;<span class="comment">//通过字符串字面量创建字符串常量。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);<span class="comment">//通过调用String类的构造函数。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot; &quot;</span> + <span class="string">&quot;world&quot;</span>;<span class="comment">//使用字符串连接运算符`+`创建字符串。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h4 id="3-字符串存储的内存原理"><a href="#3-字符串存储的内存原理" class="headerlink" title="3 字符串存储的内存原理"></a>3 字符串存储的内存原理</h4><ul>
<li>直接赋值或字符串连接操作中使用的是字符字面量（即单引号括起来的字符）的方式创建的字符串会复用串池中已存在的字符串常量</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">// 字符串 &quot;abc&quot; 存储在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;b&#x27;</span> + <span class="string">&#x27;c&#x27;</span>;<span class="comment">// 在编译时自动转换为字符串常量 &quot;abc&quot;，在串池中已经存在&quot;abc&quot;，直接复用</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//&quot;==&quot;号在比较引用类型时比较的时地址，这里的true表示s1和s2指向的对象相同</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>new出来的不会复用，而是在堆中开辟一个新的空间</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">// 使用 new 关键字创建一个新的字符串对象，不会存储在字符串常量池中</span></span><br><span class="line">System.out.println(s1 == s3); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure></div>

<h4 id="4-字符串操作"><a href="#4-字符串操作" class="headerlink" title="4 字符串操作"></a>4 字符串操作</h4><ul>
<li><code>length()</code>:用于获取字符串的长度，即字符串中包含的字符数。</li>
<li><code>substring(int beginIndex, int endIndex)</code>:方法用于截取字符串的子串，从 beginIndex 开始（包括），到 endIndex 结束（不包括）。</li>
<li><code>concat(String str)</code>:方法用于连接两个字符串，将参数字符串 str 连接到调用方法的字符串末尾。</li>
<li><code>indexOf(String str)</code>:方法用于查找指定子串 str 在字符串中第一次出现的位置，如果找到了，返回该子串的起始索引；如果没有找到，返回 -1。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();<span class="comment">//13</span></span><br><span class="line"><span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> str.substring(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">//&quot;Hello&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> str.concat(<span class="string">&quot; Welcome&quot;</span>); <span class="comment">//&quot;Hello, world! Welcome&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str.indexOf(<span class="string">&quot;world&quot;</span>); <span class="comment">//7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h4 id="5-String、StringBuffer、StringBuilder的区别"><a href="#5-String、StringBuffer、StringBuilder的区别" class="headerlink" title="5 String、StringBuffer、StringBuilder的区别"></a>5 String、StringBuffer、StringBuilder的区别</h4><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><p><code>String</code> 类是 Java 中最常用的字符串类，它表示一个不可变的字符序列。这意味着一旦创建了一个 <code>String</code> 对象，它的值就无法更改。因此，每次对字符串进行修改时都会创建一个新的字符串对象，旧的字符串对象则会被丢弃。这种不可变性使得字符串在多线程环境下是安全的，并且可以作为常量使用。<br><strong>用途</strong>：</p>
<ul>
<li>表示字符串常量。</li>
<li>在字符串操作不频繁的场景下使用，例如配置文件、类文件的路径等。</li>
</ul>
<h5 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h5><p><code>StringBuffer</code> 类是 Java 中可变字符串的实现，它允许我们在字符串中进行添加、修改和删除操作。与 <code>String</code> 不同，<code>StringBuffer</code> 是可变的，可以动态地改变其内容，而不会创建新的对象。因此，<code>StringBuffer</code> 适用于需要频繁进行字符串操作的场景，例如在循环中构建字符串、拼接大量字符串等。<br><strong>用途</strong>：</p>
<ul>
<li>多线程环境下需要进行频繁的字符串拼接或修改操作时使用。</li>
</ul>
<h5 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h5><p><code>StringBuilder</code> 类与 <code>StringBuffer</code> 类功能类似，也是可变字符串的实现。与 <code>StringBuffer</code> 不同的是，<code>StringBuilder</code> 是非线程安全的，但是它的性能通常更好。因此，如果在单线程环境中进行字符串操作，通常优先选择 <code>StringBuilder</code>。<br><strong>用途</strong>：</p>
<ul>
<li>单线程环境下需要频繁进行字符串操作时使用。<blockquote>
<p><strong>线程问题</strong></p>
<ul>
<li>StringBuffer<br><code>StringBuffer</code> 是线程安全的，因为它的方法都是同步的，即在方法内部使用了 <code>synchronized</code> 关键字来确保在多线程环境下操作字符串时的安全性。这意味着当多个线程同时访问同一个 <code>StringBuffer</code> 对象时，它们的操作会被正确地同步，不会发生数据不一致的情况。</li>
<li>StringBuilder<br><code>StringBuilder</code> 是非线程安全的，因为它的方法没有进行同步处理。这样的设计可以提升性能[它不会引入额外的同步开销，这使得它的性能可能会稍微优于 StringBuffer。]，但也意味着在多线程环境下同时访问同一个 <code>StringBuilder</code> 对象时，可能会出现竞态条件（race condition），导致数据不一致或其他意外行为。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="字符串图解"><a href="#字符串图解" class="headerlink" title="字符串图解"></a>字符串图解</h4><p><strong>直接赋值</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240413194420.png"
                     
                ><br><strong>字符数组和new</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240413194445.png"
                     
                ><br><strong>字符串拼接的底层原理</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240413194459.jpeg"
                     
                ><br><strong>字符串原理</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240413194514.jpeg"
                     
                ><br><strong>面试题</strong>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240413194534.jpeg"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240413194545.jpeg"
                     
                ></p>
<h3 id="static-静态变量"><a href="#static-静态变量" class="headerlink" title="static 静态变量"></a>static 静态变量</h3><h4 id="1-static关键字主要有两种作用："><a href="#1-static关键字主要有两种作用：" class="headerlink" title="1 static关键字主要有两种作用："></a>1 static关键字主要有两种作用：</h4><ul>
<li>为某特定数据类型或对象分配<strong>唯一</strong>的存储空间，而与创建对象的个数无关。</li>
<li>实现某个方法或属性与类关联在一起而不是对象关联在一起，因此不需要实例化对象，只需要用类名就可以调用静态的属性或方法。</li>
</ul>
<blockquote>
<p><strong>static的注意事项:</strong></p>
<ul>
<li>静态方法只能访问静态变量和静态方法</li>
<li>非静态方法可以访问静态变量或者静态方法,也可以访问非静态的成员变量和非静态的成员方法</li>
<li>静态方法中是没有this关键字<br> [总结]:<br>    静态方法中,只能访问静态。<br><br>非静态方法可以访问所有。<br>静态方法中没有this关键字</li>
</ul>
</blockquote>
<h4 id="2-1-成员变量"><a href="#2-1-成员变量" class="headerlink" title="2.1 成员变量"></a>2.1 成员变量</h4><p>Java类提供了两种类型的变量：<code>用static</code>关键字修饰的<code>静态变量</code>和<code>不用static</code>关键字修饰的<code>实例变量</code>。</p>
<ul>
<li><strong>静态变量属于类</strong>，在内存中只有一个复制，只要静态变量所在的类被加载，这个静态变量就会被分配空间，因此就可以被使用了。对静态变量的引用有两种方式，分别是”<strong>类.静态变量</strong>“[<strong>推荐</strong>]和”<strong>对象.静态变量</strong>“。</li>
<li><strong>实例变量属于对象</strong>，只有对象被创建后，实例变量才会被分配内存空间，才能被使用，它在内存中存在多个复制，只有用”<strong>对象.实例变量</strong>“的方式来引用。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//非静态属性不可直接用类名直接调用,可以用利用对象调用</span></span><br><span class="line">        <span class="comment">//Student.score;  报错</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> stu1.score;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态属性可直接用类名调用,也可以用对象调用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Student.age;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age1</span> <span class="operator">=</span> stu1.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>静态变量特点:</strong></p>
<ul>
<li>被该类所有对象共享</li>
<li>不属于对象,属于类</li>
<li>随着类的加载而加载,优先于对象存在</li>
<li>jdk8之前：放在方法区<br> jdk8及以后：存放在堆中反射的class对象（即类加载后会在堆中生成一个对应的class对象）的尾部。</li>
</ul>
<p><strong>静态变量调用方式:</strong></p>
<ul>
<li>类名调用[推荐]</li>
<li>对象名调用</li>
</ul>
</blockquote>
<h4 id="2-2-成员方法"><a href="#2-2-成员方法" class="headerlink" title="2.2 成员方法"></a>2.2 成员方法</h4><p>Java中提供了<code>static（静态）</code>方法和<code>非static（非静态）</code>方法。</p>
<ul>
<li>static方法是类的方法，不需要创建对象就可以被类名调用</li>
<li>而非static方法是对象的方法，只有对象被创建出来后才可以被使用</li>
<li><strong>static方法中不能使用this和super关键字，不能调用非static方法</strong>，只能访问所属类的静态成员变量和成员方法，因为当static方法被调用时，这个类的对象可能还没被创建，即使已经被创建了，也无法确定调用哪个对象的方法。同理，<strong>static方法也不能访问非static类型的变量</strong></li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="comment">//System.out.println(age); 报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//静态方法可以直接用类名调用，也可以用对象调用</span></span><br><span class="line">        Student.say();</span><br><span class="line">        stu1.say();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//非静态方法只能用对象调用</span></span><br><span class="line">        <span class="comment">//Student.run(); 报错</span></span><br><span class="line">        stu1.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p><strong>单例设计模式：</strong><br>static一个很重要的用途就是实现单例设计模式。<strong>单例模式的特点是该类只能有一个实例</strong>，为了实现这一功能，必须隐藏类的构造函数，即把构造函数声明为private，并提供一个创建对象的方法，<strong>由于构造对象被声明为private，外界无法直接创建这个类型的对象，只能通过该类提供的方法来获取类的对象</strong>，要达到这样的目的只能把创建对象的方法声明为<code>static</code>，程序实例如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">			instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p><strong>静态方法特点:</strong></p>
<ul>
<li>多用在测试类和工具类中</li>
<li>Javabean类中很少会用</li>
</ul>
<p><strong>静态方法调用方式:</strong></p>
<ul>
<li>类名调用[推荐]</li>
<li>对象名调用</li>
</ul>
</blockquote>
<h4 id="2-3-static代码块"><a href="#2-3-static代码块" class="headerlink" title="2.3 static代码块"></a>2.3 static代码块</h4><p>static代码块在类中是独立于成员变量和成员函数的代码块的。静态代码块先执行(优先级比构造方法还高),静态代码块中只能调用静态属性和方法，不能调用非静态的。<br><strong>且<code>只执行一次</code>，非静态代码块在在每次创建新对象的时候都会执行一次</strong><br>可以应用于数据的初始化</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;匿名代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//静态代码块先执行，且只执行一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果:</span></span><br><span class="line"><span class="comment">    静态代码块</span></span><br><span class="line"><span class="comment">    匿名代码块</span></span><br><span class="line"><span class="comment">    构造器</span></span><br><span class="line"><span class="comment">    &lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;</span></span><br><span class="line"><span class="comment">    匿名代码块</span></span><br><span class="line"><span class="comment">    构造器</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>
<h4 id="2-4-static内部类"><a href="#2-4-static内部类" class="headerlink" title="2.4 static内部类"></a>2.4 static内部类</h4><ul>
<li><strong>static内部类可以不依赖于外部类实例对象而被实例化</strong>，而通常的内部类需要外部类实例化后才能实例化。</li>
<li>静态内部类不能访问外部类的普通成员变量，<strong>只能访问外部类中的静态成员和静态成员方法</strong>，因为静态内部类是与类一起加载的。</li>
<li><strong>只有内部类才能被申明为static</strong>。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object inter;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">sinter</span>&#123;</span><br><span class="line">        sinter()&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是静态内部类&quot;</span>);</span><br><span class="line">            <span class="comment">//只能访问外部类中的静态成员和静态成员方法</span></span><br><span class="line">            System.out.println(age);</span><br><span class="line">            say();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">inter</span>&#123;</span><br><span class="line">        inter()&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是非静态内部类&quot;</span>);</span><br><span class="line">            System.out.println(age+score);</span><br><span class="line">            say();</span><br><span class="line">            run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">text</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//静态内部类可直接实例化</span></span><br><span class="line">        Student.<span class="type">sinter</span> <span class="variable">sinter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>.sinter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//非静态内部类需要创建一个外部类对象再实例化</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        Student.<span class="type">inter</span> <span class="variable">inter</span> <span class="operator">=</span> student.<span class="keyword">new</span> <span class="title class_">inter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h3 id="继承问题"><a href="#继承问题" class="headerlink" title="继承问题"></a>继承问题</h3><h4 id="1-继承的概念"><a href="#1-继承的概念" class="headerlink" title="1 继承的概念"></a>1 继承的概念</h4><p>继承是<strong>面向对象三大特征之一</strong>，可以使得<strong>子类具有父类的属性和方法</strong>，还可以在<strong>子类中重新定义（重写），以及追加属性和方法（添加额外的父类没有的子类特有的方法）</strong></p>
<h4 id="2-实现格式"><a href="#2-实现格式" class="headerlink" title="2 实现格式"></a>2 实现格式</h4><ul>
<li>继承通过<code>extends</code>关键字实现</li>
<li>用法:<code>class 子类 extends 父类 &#123;&#125;</code><br>  举例: class Dog extends Animal {}</li>
</ul>
<h4 id="3-子类的特点"><a href="#3-子类的特点" class="headerlink" title="3 子类的特点"></a>3 子类的特点</h4><ul>
<li>可以继承父类的<strong>成员变量</strong>[如果子类中有同名的成员变量,父类的变量会被隐藏]和<strong>虚方法表中的成员方法</strong>[非private、非static、非final]</li>
<li>子类可以有自己的成员变量和方法</li>
<li>子类可以<strong>重写从父类继承下来的成员方法</strong>[如果发生了重写,则会覆盖父类继承下来的成员方法]</li>
<li><strong>子类并不会继承父类的构造方法</strong>[因为父类的构造方法名与子类名存在冲突],因此我们创建子类时需手动添加子类的构造方法</li>
</ul>
<blockquote>
<p><strong>注意:</strong><br>子类中可以使用父类中的<strong>静态方法[static修饰]</strong>,但这是因为静态方法属于类而不是对象，子类可以直接通过父类名来调用父类的静态方法,这种调用方式不涉及继承关系，只是通过类名来访问类的静态成员。它们并不会参与继承的机制。</p>
</blockquote>
<h4 id="4-继承中成员变量访问的特点"><a href="#4-继承中成员变量访问的特点" class="headerlink" title="4 继承中成员变量访问的特点"></a>4 继承中成员变量访问的特点</h4><ul>
<li><code>遵循就近原则:局部变量-&gt;成员变量-&gt;父类</code><ul>
<li>先在子类的局部变量找，要是找到就用这个局部变量的值（就算有一个名字一模一样的成员变量，那也不会去访问哪个成员变量的）</li>
<li>然后要是在局部变量里面找不到的话，就去成员变量去去找</li>
<li>要是成员变量找不到的话，就去父类的成员变量去找</li>
<li>要是父类没有就找父类的父类</li>
<li>……</li>
<li>要是都没有找到就报错</li>
</ul>
</li>
</ul>
<h4 id="5-this-super"><a href="#5-this-super" class="headerlink" title="5 this &amp; super"></a>5 this &amp; super</h4><ul>
<li><code>this</code>:代表本类对象(且是调用this所在方法的那个对象)的引用</li>
<li><code>super</code>:代表对象父类的引用,可以调用上一级的那个类的方法或属性</li>
</ul>
<p><strong>用法</strong>:可以解决无法访问子类和父类中相同名称的成员的问题</p>
<ul>
<li>成员变量:<ul>
<li>this.成员变量 -&gt; 访问本类成员变量</li>
<li>super.成员变量 -&gt; 访问父类成员变量</li>
</ul>
</li>
<li>成员方法:<ul>
<li>this.成员方法 -&gt; 访问本类成员方法</li>
<li>super.成员方法 -&gt; 访问父类成员方法</li>
</ul>
</li>
<li>构造方法:<ul>
<li>this(…) -&gt; 访问本类构造方法</li>
<li>super(…) -&gt; 访问父类构造方法<blockquote>
<p><strong>注意：</strong><br>不能在<code>静态方法</code>中使用this和super关键字。<br>因为静态方法是属于类而不是对象实例的,而<code>this</code>和<code>super</code>关键字是关于对象实例的引用。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>构造方法中的默认super</strong><br>继承中构造方法的访问特点:<br>​子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化，原因在于，<strong>每一个子类构造方法的第一条语句默认都是：super()。但是你只要自己写了super(……)调用父类的带参构造方法,那个默认隐藏的super()就失效了。</strong><br><mark>注意：子类中所有的构造方法默认隐藏地有一个super()，都会访问父类中无参的构造方法[如果手动添加了一个super(……)调用父类的带参构造方法,那个默认隐藏的super()就会失效]</mark></p>
<blockquote>
<p><strong>问题：如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢？</strong></p>
<ul>
<li>通过使用super关键字去显示的调用父类的带参构造方法</li>
<li>在父类中自己提供一个无参构造方法</li>
</ul>
<p><strong>推荐方案：</strong><br>​自己给出无参构造方法</p>
<hr>
<p><strong>补充说明</strong><br>除了已经提到的内容外，还有一些关于 <code>this</code> 和 <code>super</code> 的使用注意事项：</p>
<ol>
<li><strong>this() 和 super() 不能同时出现在同一个构造方法中</strong>：在同一个构造方法中，<code>this()</code> 和 <code>super()</code> 只能出现一个，并且必须是构造方法的第一条语句。</li>
<li><strong>this() 和 super() 只能用于构造方法</strong>：<code>this()</code> 和 <code>super()</code> 关键字只能用于构造方法中，不能用于普通方法。</li>
<li><strong>this 和 super 不能用于静态方法</strong>：<code>this</code> 和 <code>super</code> 关键字是关于对象实例的引用，而静态方法属于类而不是对象实例，因此无法在静态方法中使用这两个关键字。</li>
<li><strong>super 关键字可以在构造方法之外使用</strong>：<code>super</code> 关键字除了可以在构造方法中调用父类构造方法之外，还可以在子类的其他方法中使用来调用父类的方法或属性。</li>
</ol>
</blockquote>
<h4 id="6-方法的重写"><a href="#6-方法的重写" class="headerlink" title="6 方法的重写"></a>6 方法的重写</h4><ul>
<li><strong>继承关系</strong>：方法重写是建立在类之间的继承关系上。子类可以继承父类的方法并对其进行重写。</li>
<li><strong>方法签名</strong>：子类中重写的方法必须与父类中被重写的方法具有相同的方法签名，包括方法名、参数列表和返回类型。[<strong>方法签名是指方法的名称以及参数的类型和顺序</strong>]。</li>
<li><strong>访问修饰符</strong>：子类中重写的方法的访问修饰符不能比父类中被重写方法的访问修饰符更严格。例如，如果父类中的方法是public，那么子类中重写的方法也必须是public，不能是protected或者private。</li>
<li><strong>异常</strong>：子类中重写的方法不能抛出比父类中被重写方法更宽泛的异常，但可以抛出更窄的异常，或者不抛出异常。</li>
<li><strong>返回类型</strong>：在Java 5之前，返回类型必须完全匹配。但在Java 5及以后版本，可以使用协变返回类型，即子类中重写的方法的返回类型可以是父类中被重写方法返回类型的子类型。</li>
<li><strong>重写的Override注解</strong>:用来检测当前的方法，是否是重写的方法，起到【校验】的作用。就是检查你写的方法有没有严格符合重写的格式。<br>下面是一个简单的示例来说明方法重写：</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        animal.makeSound(); <span class="comment">// Output: Animal makes a sound</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.makeSound(); <span class="comment">// Output: Dog barks</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p><strong>注意</strong>:<br>在Java中，<mark>不能重写静态方法</mark>。虽然子类可以定义与父类中静态方法具有相同的名称、参数格式和类型和返回值的方法，但这并不是方法重写，而是方法隐藏。<br>静态方法是与类相关联的方法，它们不是对象的一部分。当子类定义了一个与父类中静态方法同名的静态方法时，子类的方法将隐藏父类中的方法，而不是重写它。在调用静态方法时，编译器会根据引用类型来确定使用哪个方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent&#x27;s static method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child&#x27;s static method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Parent.staticMethod(); <span class="comment">// Output: Parent&#x27;s static method</span></span><br><span class="line">        Child.staticMethod();  <span class="comment">// Output: Child&#x27;s static method</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Parent</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">        parent.staticMethod(); <span class="comment">// Output: Parent&#x27;s static method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上面的示例中，即使我们使用<code>Parent类型</code>的引用指向<code>Child对象</code>，调用的仍然是<code>Parent类中的静态方法</code>。<mark>这是因为静态方法的调用是通过编译时类型（在编译时确定的类型）来决定的，而不是运行时类型（实际对象的类型）</mark>。</p>
</blockquote>
<h4 id="7-继承的优劣"><a href="#7-继承的优劣" class="headerlink" title="7 继承的优劣"></a>7 继承的优劣</h4><ul>
<li><strong>好处:</strong><ul>
<li>提高了代码的复用性(多个类相同的成员可以放到同一个父类中)</li>
<li>提高了代码的维护性(如果方法的代码需要修改，修改父类的一处方法即可)</li>
</ul>
</li>
<li><strong>弊端:</strong><ul>
<li>继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性。</li>
</ul>
</li>
</ul>
<h4 id="8-java继承的注意事项"><a href="#8-java继承的注意事项" class="headerlink" title="8 java继承的注意事项"></a>8 java继承的注意事项</h4><ul>
<li>Java中类只支持单继承，不支持多继承（但是可以实现多个接口，单继承，多实现）<ul>
<li>错误范例：class A extends B, C { } <mark>[Java不允许存在多继承]</mark></li>
</ul>
</li>
<li>Java中所有类的根类都是<code>Object</code>类</li>
<li>Java中类支持多层继承</li>
<li>继承相关图解如下:</li>
</ul>
<details class="[orange]" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>[继承相关图解] </summary>
              <div class='content'>
              <p><strong>子类可以从父类继承:</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-05%20225901.png"
                     
                ><br><strong>方法的继承:</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-07%20235906.png"
                     
                ><br><strong>方法的重写:</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/Snipaste_2024-04-06_22-08-02.png"
                     
                ><br><strong>this &amp; super:</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-08%20174612.png"
                     
                ><br><strong>super内存图:</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-08%20172737.png"
                     
                ></p>
              </div>
            </details>

<h3 id="多态问题"><a href="#多态问题" class="headerlink" title="多态问题"></a>多态问题</h3><h4 id="1-多态的概念"><a href="#1-多态的概念" class="headerlink" title="1 多态的概念"></a>1 多态的概念</h4><ul>
<li><strong>同类型的对象,表现出的不同形态</strong></li>
<li>表现形式:<ul>
<li><code>父类类型 对象名称 = 子类对象</code></li>
<li>Fu f &#x3D; new Zi();</li>
</ul>
</li>
<li>多态的前提:<ul>
<li>有继承关系</li>
<li>由父类引用指向子类对象</li>
<li>有方法重写</li>
</ul>
</li>
<li>多态的好处:<br>使用父类型作为参数,可以接收所有子类对象,体现多态的拓展性与便利</li>
</ul>
<h4 id="2-多态调用成员的特点"><a href="#2-多态调用成员的特点" class="headerlink" title="2 多态调用成员的特点"></a>2 多态调用成员的特点</h4><ul>
<li>变量调用:<strong>编译看左边,运行也看左边</strong></li>
<li>方法调用:<strong>编译看左边,运行看右边</strong></li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Animal&quot;</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal&#x27;s static method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Dog&quot;</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog&#x27;s static method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line"></span><br><span class="line">        System.out.println(animal1.name); <span class="comment">// 编译时看左边，运行时也看左边，输出: &quot;Animal&quot;</span></span><br><span class="line">        animal1.makeSound(); <span class="comment">// 编译时看左边，运行时看右边，输出: &quot;Dog barks&quot;</span></span><br><span class="line">        animal1.staticMethod(); <span class="comment">// 编译时看左边，运行时也看左边，输出: &quot;Animal&#x27;s static method&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="3-多态的弊端"><a href="#3-多态的弊端" class="headerlink" title="3 多态的弊端:"></a>3 多态的弊端:</h4><ul>
<li><strong>不能调用子类的特有方法[因为在编译的时侯会先检查左边的父类中有没有这个方法,如果没有直接报错]</strong></li>
<li>解决方案:<br>  将变量转换为子类类型<br>  Dog d &#x3D; (Dog) a;    [只能强转为new出来的那个类型,强转类型与真实对象类型不一致会报错]</li>
</ul>
<h4 id="4-强转类型"><a href="#4-强转类型" class="headerlink" title="4 强转类型"></a>4 强转类型</h4><ul>
<li><code>instanceof</code>:用于在运行时确定一个对象是否是某个类的实例或者其子类的实例。它的语法形式为：</li>
<li>用法:<code>object instanceof ClassName</code><br><code>instanceof</code>运算符返回一个布尔值，如果 object 是 ClassName 类型的实例或者其子类的实例，则返回 true，否则返回 false。[可搭配if语句使用]</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Animal&quot;</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Dog&quot;</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fetch</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog fetches a stick&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (animal1 <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal1;</span><br><span class="line">            dog.fetch(); <span class="comment">// 如果 animal1 是 Dog 类型的实例，则调用 fetch() 方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>在jdk14以后有以下新特性</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (animal1 <span class="keyword">instanceof</span> Dog) &#123;              <span class="keyword">if</span> (animal1 <span class="keyword">instanceof</span> Dog d) </span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal1;       &lt;=&gt;     <span class="comment">//先判断a是否为Dog类型，如果是，则强转成Dog类型，转换之后变量名为d</span></span><br><span class="line">                                           <span class="comment">//如果不是，则不强转，结果直接是false</span></span><br><span class="line">&#125;                                          </span><br></pre></td></tr></table></figure></div></blockquote>
<h3 id="包与导包"><a href="#包与导包" class="headerlink" title="包与导包"></a>包与导包</h3><h4 id="1-包"><a href="#1-包" class="headerlink" title="1 包"></a>1 包</h4><h5 id="1-1-包的概念"><a href="#1-1-包的概念" class="headerlink" title="1.1 包的概念"></a>1.1 包的概念</h5><p>包就是文件夹。用来管理各种不同功能的Java类,方便后期维护。</p>
<h5 id="1-2-包的定义格式"><a href="#1-2-包的定义格式" class="headerlink" title="1.2 包的定义格式"></a>1.2 包的定义格式</h5><ul>
<li>包名的规则: <code>公司域名反写+包的作用</code>,需要全部英文小写,见名知意。<ul>
<li>eg：ink.lusy.blog</li>
</ul>
</li>
</ul>
<h5 id="1-3-带包编译-带包运行"><a href="#1-3-带包编译-带包运行" class="headerlink" title="1.3 带包编译&amp;带包运行"></a>1.3 带包编译&amp;带包运行</h5><ul>
<li>带包编译：javac -d . 全类名.java<ul>
<li>eg：java -d . ink.lusy.blog.HelloWorld.java</li>
</ul>
</li>
<li>带包运行：java 全类名<ul>
<li>eg：java ink.lusy.blog.HelloWorld</li>
</ul>
</li>
<li>全类名：包名+类名</li>
</ul>
<h4 id="2-导包"><a href="#2-导包" class="headerlink" title="2 导包"></a>2 导包</h4><h5 id="2-1-导包的意义"><a href="#2-1-导包的意义" class="headerlink" title="2.1 导包的意义"></a>2.1 导包的意义</h5><ul>
<li>使用不同包下的类时，使用的时候要写类的全路径，写起来太麻烦了</li>
<li>为了简化带包的操作，Java就提供了导包的功能<blockquote>
<p><strong>注意</strong>：如果同时使用两个包中的同名类，需要用全类名。[导包将不再适用]</p>
</blockquote>
</li>
</ul>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p><code>final</code>：表示最终的、不可改变的</p>
<h4 id="1-修饰类"><a href="#1-修饰类" class="headerlink" title="1 修饰类"></a>1 修饰类</h4><p><strong>作用</strong>：不能再被其他类继承</p>
<ul>
<li>表明该类为最终类，不能再被其他类继承</li>
<li>该类中的所有方法都是最终方法(隐式地被<code>final</code>修饰)</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li><strong>工具类（Utility Classes）</strong>: 如果某个类仅提供一组静态方法或者常量，并且不需要被继承修改，可以将其定义为final，例如Java中的java.lang.Math类就是一个典型的工具类。</li>
<li><strong>不可变类（Immutable Classes）</strong>: 不可变类是指其实例一旦创建就不能被修改的类，一般来说，不可变类应该是final的，以确保它们的状态不会被修改。</li>
<li><strong>涉及安全敏感信息的类</strong>: 如果某个类涉及到处理安全敏感信息，例如密码、密钥等，为了确保安全性，应该将其定义为final，避免被子类继承修改。</li>
<li><strong>单例模式类（Singleton Classes）</strong>: 单例模式中的类通常需要保证只有一个实例存在，并且提供全局访问点，为了确保单例的正确性，可以将单例类定义为final，防止被继承修改。</li>
<li><strong>为了提高性能的类</strong>: 在一些性能敏感的场景下，为了确保类的行为不被修改并且获得更好的性能，可以将其定义为final，使得编译器可以进行更多的优化。</li>
<li><strong>经常需要修改的类（迭代更新会经常改动的类）</strong>：final类可以避免继承链的耦合性，减少了父类变更导致子类需要同步修改的风险，符合”低耦合，高内聚”的设计原则。</li>
</ul>
<h4 id="2-修饰方法"><a href="#2-修饰方法" class="headerlink" title="2 修饰方法"></a>2 修饰方法</h4><p><strong>作用</strong>：子类不能重写(覆盖)该方法<br><strong>应用场景</strong>：对继承没有太大意义的方法，或者父类自身特有的方法，这些方法不需要给子类使用，从而定义为最终方法，在类继承时，可以降低耦合度</p>
<h4 id="3-修饰变量"><a href="#3-修饰变量" class="headerlink" title="3 修饰变量"></a>3 修饰变量</h4><ul>
<li>被<code>final</code>修饰的变量统称常量。</li>
<li><strong>常量的命名规范</strong>:<ul>
<li><p>单个单词:全部大写</p>
</li>
<li><p>多个单词:全部大写，单词之间用下划线隔开</p>
<blockquote>
<p>实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性，</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="3-1-修饰局部变量"><a href="#3-1-修饰局部变量" class="headerlink" title="3.1 修饰局部变量"></a>3.1 修饰局部变量</h5><p><strong>作用</strong>：<code>final</code>修饰的变量只能被赋值一次，是不可改变的<br><strong>优点</strong>：不需要重复的创建对象。</p>
<blockquote>
<p><strong>注意</strong>：<br>这里说的final修饰的变量不可改变分为两种：</p>
<ul>
<li>对于基本数据类型：指的是数值不可改变</li>
<li>对于引用数据类型：指的是变量存储的地址不可改变，对象内部的数据可以改变<br>[变量存的值不可改变，对于基本数据类型而言，变量存的是数值，对于引用数据类型而言，变量存的是地址]</li>
</ul>
</blockquote>
<h5 id="3-2-修饰全局变量-属性"><a href="#3-2-修饰全局变量-属性" class="headerlink" title="3.2 修饰全局变量(属性)"></a>3.2 修饰全局变量(属性)</h5><p>作用与上述局部变量一致，但需要注意以下3点</p>
<ul>
<li>final修饰全局变量，必须手动赋初始值</li>
<li>对于final修饰的全局变量，要么直接赋值，要么通过构造方法赋值</li>
<li>对于未直接赋值的final类型的全局变量，所有的构造方法都必须对该变量进行赋值</li>
</ul>
<h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-09%20105030.png"
                     
                ></p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>在Java中，代码块是一段用花括号 <code>&#123;&#125;</code> 括起来的代码，它可以在不同的位置出现，并且有不同的类型，包括局部代码块、构造代码块和静态代码块。</p>
<h4 id="1-局部代码块（Local-Blocks）："><a href="#1-局部代码块（Local-Blocks）：" class="headerlink" title="1 局部代码块（Local Blocks）："></a>1 局部代码块（Local Blocks）：</h4><ul>
<li>局部代码块是定义在方法体内的代码块，通常用于限定变量的作用范围。</li>
<li>局部代码块中声明的变量的作用范围仅限于该代码块内部。</li>
<li>局部代码块在执行完毕后，其中声明的变量会被销毁，不再占用内存空间。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exampleMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 开始局部代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;x inside local block: &quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结束局部代码块</span></span><br><span class="line">    <span class="comment">// 这里无法访问局部代码块中的变量 x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-构造代码块（Initializer-Blocks）："><a href="#2-构造代码块（Initializer-Blocks）：" class="headerlink" title="2 构造代码块（Initializer Blocks）："></a>2 构造代码块（Initializer Blocks）：</h4><ul>
<li>构造代码块是定义在类中，没有任何修饰符（如static、public等）的代码块，它在每次创建对象时都会被执行。</li>
<li>构造代码块主要用于初始化对象的共同属性，在每个构造函数之前执行。</li>
<li>构造代码块不能被显式调用，它会在对象创建时自动执行。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleClass</span> &#123;</span><br><span class="line">    <span class="comment">// 构造代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor block executed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleClass</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor executed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExampleClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExampleClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-静态代码块（Static-Blocks）："><a href="#3-静态代码块（Static-Blocks）：" class="headerlink" title="3 静态代码块（Static Blocks）："></a>3 静态代码块（Static Blocks）：</h4><ul>
<li>静态代码块是定义在类中，使用 static 关键字修饰的代码块，它在类加载时执行，且只执行一次。</li>
<li>静态代码块主要用于进行类的初始化操作，如加载驱动程序、初始化静态变量等。</li>
<li>静态代码块在程序启动时自动执行，无需显式调用。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleClass</span> &#123;</span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static block executed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行 main 方法时会触发类的加载，从而执行静态代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Inside main method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h3><h4 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1 基本概念"></a>1 基本概念</h4><ul>
<li>抽象方法：将<strong>共性的</strong>行为（方法）抽取到父类之后。由于每一个子类执行的内容是不一样，所以,在父类中不能确定<strong>具体的方法体</strong>，该方法就可以定义为抽象方法。<blockquote>
<p>抽象方法就是以abstract修饰的方法，这种方法<mark>只声明返回的数据类型、方法名称和所需的参数</mark>，没有方法体，也就是说抽象方法只需要声明而不需要实现</p>
</blockquote>
</li>
<li>抽象类:如果一个类中存在抽象方法,那么该类就必须声明为抽象类</li>
</ul>
<h4 id="2-定义格式"><a href="#2-定义格式" class="headerlink" title="2 定义格式"></a>2 定义格式</h4><ul>
<li>抽象方法：<code>public abstract 返回值类型 方法名(参数列表);</code>[分号;不能忘记]</li>
<li>抽象类：<code>public abstract class 类名 &#123;&#125;</code></li>
</ul>
<h4 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3 注意事项"></a>3 注意事项</h4><ul>
<li><strong>抽象类不能实例化</strong></li>
<li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类<br>[未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。比较少用]</li>
<li>抽象类可以有构造方法[给子类继承]</li>
<li>抽象类的子类<ul>
<li>要么重写抽象类中的所有抽象方法</li>
<li>要么是抽象类</li>
</ul>
</li>
</ul>
<h4 id="4-意义"><a href="#4-意义" class="headerlink" title="4 意义"></a>4 意义</h4><ul>
<li>抽取共性时，无法确定方法体，就可以把方法定义为抽象的。</li>
<li>强制让子类按照某种格式进行重写。[提高代码可读性]</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="1-基本概念-2"><a href="#1-基本概念-2" class="headerlink" title="1 基本概念"></a>1 基本概念</h4><p>简单的说，接口就是一种被规范的标准，它定义了一组行为或功能，任何符合这个标准的类都可以被看作是这个接口的实现。<strong>接口的表现在于对行为的抽象</strong>。<br>[类是对属性的抽象，接口是对行为的抽象]</p>
<h4 id="2-定义和使用"><a href="#2-定义和使用" class="headerlink" title="2 定义和使用"></a>2 定义和使用</h4><ul>
<li>接口用关键字<code>interface</code>来定义：<ul>
<li><strong>pubilc interface 接口名 {}</strong></li>
<li><strong>interface 接口名 {}</strong></li>
<li>两种定义方式的区别：接口的访问权限不一样</li>
</ul>
</li>
<li><strong>接口不能实例化</strong></li>
<li>接口和类之间是<strong>实现关系</strong>,通过<code>implements</code>关键字表示<ul>
<li><strong>public class 类名 implements 接口名1 接口名2 …… {}</strong></li>
</ul>
</li>
<li>接口的子类(实现类)<ul>
<li>要么重写接口中的所有抽象方法</li>
<li>要么是抽象类</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="comment">// 接口中的常量</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159</span>;<span class="comment">//前面有默认修饰符：public static final [在编译环节会隐式添加]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口中的抽象方法</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span>;<span class="comment">//前面有默认修饰符：public abstract [在编译环节会隐式添加]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现接口中的抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用接口中的常量 -&gt; 静态变量可以直接用类名调用[推荐]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;PI 常量的值: &quot;</span> + Shape.PI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 Circle 对象</span></span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5.0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用实现接口的方法</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> circle.calculateArea();</span><br><span class="line">        System.out.println(<span class="string">&quot;圆的面积: &quot;</span> + area);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="3-成员特点"><a href="#3-成员特点" class="headerlink" title="3 成员特点"></a>3 成员特点</h4><ul>
<li>成员变量<ul>
<li>只能是常量  </li>
<li>默认修饰符：<strong><code>public</code> static final</strong></li>
</ul>
</li>
<li>构造方法<ul>
<li>没有</li>
</ul>
</li>
<li>成员方法<ul>
<li>只能是抽象方法[JDK7以前]</li>
<li>默认修饰符：<strong>public abstract</strong></li>
<li><code>JDK8的新特性</code>: 接口中可以定义有方法体的方法（默认、静态）</li>
<li><code>JDK9的新特性</code>: 接口中可以定义私有方法</li>
</ul>
</li>
</ul>
<h4 id="4-接口和类之间的关系"><a href="#4-接口和类之间的关系" class="headerlink" title="4 接口和类之间的关系"></a>4 接口和类之间的关系</h4><ul>
<li>类和类的关系<br>  继承关系,只能单继承,不能多继承,但是可以多层继承</li>
<li>类和接口的关系<br>  实现关系,可以单实现,也可以多实现,还可以在继承一个类的同时实现多个接口</li>
<li>接口和接口的关系<br>  继承关系,可以单继承,也可以多继承<br>  <strong>public interface a <code>extends</code> b,c,d…..{}</strong></li>
</ul>
<blockquote>
<p><strong>接口多继承的好处</strong>：<br>定义了许多接口，如果一个设备要同时实现那么多接口将是不小的开销，对于同能同类的可以把他用一个接口继承起来，这样这个接口就要了那些接口的全部功能，我们使用类只要实现一个就可以了。</p>
</blockquote>
<h4 id="5-JDK8以后接口中新增的方法"><a href="#5-JDK8以后接口中新增的方法" class="headerlink" title="5 JDK8以后接口中新增的方法"></a>5 JDK8以后接口中新增的方法</h4><h5 id="5-1-默认方法"><a href="#5-1-默认方法" class="headerlink" title="5.1 默认方法"></a>5.1 默认方法</h5><ul>
<li>允许在接口中定义<strong>默认方法</strong>，需要使用关键字<code>default</code>修饰<ul>
<li>作用：解决接口升级的问题[允许在接口中添加新的方法而不会破坏现有的实现类。]</li>
</ul>
</li>
<li>默认方法的定义格式<ul>
<li><strong>public <code>default</code> 返回值类型 方法名(参数列表) { }</strong></li>
<li>eg：public <code>default</code> void show() { }</li>
</ul>
</li>
<li>调用方法<ul>
<li>实现类直接调用接口默认方法即可。[类名.默认方法名(参数列表)]</li>
</ul>
</li>
<li>默认方法的注意事项<ul>
<li>默认方法不是抽象方法，所以<strong>不强制被重写</strong>。但是如果被重写，重写的时候要去掉<code>default</code>关键字</li>
<li>public可以省略，default不能省略</li>
<li>如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写</li>
</ul>
</li>
</ul>
<h5 id="5-2-静态方法"><a href="#5-2-静态方法" class="headerlink" title="5.2 静态方法"></a>5.2 静态方法</h5><ul>
<li>允许在接口中定义<strong>静态方法</strong>，需要使用关键字<code>static</code>修饰<ul>
<li>调用时无需实例化接口的实现类[通常用于实现工具类或提供通用功能的方法]</li>
</ul>
</li>
<li>静态方法的定义格式<ul>
<li><strong>public <code>static</code> 返回值类型 方法名(参数列表) { }</strong></li>
<li>eg：public <code>static</code> void show() { }</li>
</ul>
</li>
<li>调用方法<ul>
<li>只能通过接口名调用</li>
</ul>
</li>
<li>静态方法的注意事项<ul>
<li>静态方法只能通过接口名调用，不能通过实现类名或者对象名调用</li>
<li>public可以省略，static不能省略</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>默认方法和静态方法功能上的区别</strong></p>
<p><strong>默认方法（Default Methods）</strong>：</p>
<ul>
<li>默认方法是接口中带有默认实现的方法，它们允许在接口中添加新的方法而不会破坏现有的实现类。</li>
<li>默认方法可以被实现类选择性地覆盖，以满足特定需求。</li>
<li>默认方法主要用于接口的演进，允许向现有接口添加新的功能而不会影响已有的实现类。</li>
</ul>
<p><strong>静态方法（Static Methods）</strong>：</p>
<ul>
<li>静态方法是在接口中带有 <code>static</code> 关键字修饰的方法，它们不是接口的实例方法，而是与接口直接关联的方法。</li>
<li>静态方法可以直接通过接口名称调用，无需实例化接口的实现类。</li>
<li>静态方法通常用于实现工具类或提供通用功能的方法。</li>
</ul>
</blockquote>
<h4 id="6-JDK9以后接口中新增的方法"><a href="#6-JDK9以后接口中新增的方法" class="headerlink" title="6 JDK9以后接口中新增的方法"></a>6 JDK9以后接口中新增的方法</h4><p><strong>接口中可以定义私有方法</strong></p>
<ul>
<li>权限范围：<strong>私有方法的访问权限仅限于接口内部</strong></li>
<li>作用：避免了代码的重复编写、隐藏接口的实现细节</li>
<li>私有方法的注意事项：<strong>私有方法无法被实现类覆盖或继承</strong>，它们只能在接口内部使用。</li>
</ul>
<h5 id="6-1-普通的私有方法-对标JDK8中的默认方法"><a href="#6-1-普通的私有方法-对标JDK8中的默认方法" class="headerlink" title="6.1 普通的私有方法[对标JDK8中的默认方法]"></a>6.1 普通的私有方法[对标JDK8中的默认方法]</h5><ul>
<li>格式：<strong>private 返回值类型 方法名(参数列表) { }</strong></li>
<li>eg：private void show() { }</li>
</ul>
<h5 id="6-2-静态的私有方法-对标JDK8中的静态方法"><a href="#6-2-静态的私有方法-对标JDK8中的静态方法" class="headerlink" title="6.2 静态的私有方法[对标JDK8中的静态方法]"></a>6.2 静态的私有方法[对标JDK8中的静态方法]</h5><ul>
<li>格式：<strong>private <code>static</code> 返回值类型 方法名(参数列表) { }</strong></li>
<li>eg：private <code>static</code> void show() { }</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p><strong>类的五大成员</strong>：<br>属性、方法、构造方法、代码块、内部类</p>
<p><strong>内部类的基本概念</strong>：<br>在一个类的里面，再定义一个类。[在A类的内部定义B类，B类就被称为内部类]</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//这里的Outer是外部类，Inner是内部类</span></span><br></pre></td></tr></table></figure></div>

<p><strong>内部类的作用</strong>：<br>内部类表示的事物是外部类的一部分，且内部类单独存在又没有任何意义<br>比如：汽车的发动机，ArrayList的迭代器。人的心脏</p>
<p><strong>内部类的访问特点</strong>：</p>
<ul>
<li>内部类可以直接访问外部类的成员，包括私有</li>
<li>外部类要访问内部类的成员，必须要创建对象[静态内部类中的静态成员不需要创建对象]</li>
</ul>
<h4 id="1-成员内部类"><a href="#1-成员内部类" class="headerlink" title="1 成员内部类"></a>1 成员内部类</h4><ul>
<li>写在成员位置的，属于外部类的成员。</li>
<li>成员内部类可以被一些修饰符所修饰。[private、默认、protectd、public、static]</li>
<li>在成员内部类里面，JDK16之前不能定义静态变量，JDK16开始才可以定义静态变量</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">pubilc <span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    <span class="type">int</span> carColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span>&#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engageAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="1-1-获取成员内部类对象"><a href="#1-1-获取成员内部类对象" class="headerlink" title="1.1 获取成员内部类对象"></a>1.1 获取成员内部类对象</h5><ul>
<li>直接创建格式：<code>外部类名.内部类名 对象名 = new 外部类名().new 内部类名();</code></li>
<li>在外部类中编写方法，对外提供内部类的对象。[适用于内部类被private等修饰时使用]</li>
</ul>
<h5 id="1-2-外部类成员变量和内部类成员变量重名时，在内部类如何访问"><a href="#1-2-外部类成员变量和内部类成员变量重名时，在内部类如何访问" class="headerlink" title="1.2 外部类成员变量和内部类成员变量重名时，在内部类如何访问"></a>1.2 外部类成员变量和内部类成员变量重名时，在内部类如何访问</h5><ul>
<li><code>外部类名.this.变量名</code><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240414120751.png"
                     
                ></li>
</ul>
<h4 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2 静态内部类"></a>2 静态内部类</h4><ul>
<li>静态内部类只能访问外部类中的静态变量和静态方法，要访问外部类的非静态成员，则需要通过创建外部类的实例来进行访问。</li>
<li>静态内部类是一种特殊的成员内部类。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">pubilc <span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    <span class="type">int</span> carColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Engine</span>&#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engageAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="2-1-创建静态内部类对象的格式"><a href="#2-1-创建静态内部类对象的格式" class="headerlink" title="2.1 创建静态内部类对象的格式"></a>2.1 创建静态内部类对象的格式</h5><ul>
<li><code>外部类名.内部类名 对象名 = new 外部类名.内部类名();</code></li>
</ul>
<h5 id="2-2-成员调用"><a href="#2-2-成员调用" class="headerlink" title="2.2 成员调用"></a>2.2 成员调用</h5><ul>
<li>调用非静态成员的格式：先创建对象，用对象调用</li>
<li>调用静态成员的格式：<code>外部类名.内部类名.方法名()\变量名;</code></li>
</ul>
<h4 id="3-局部内部类"><a href="#3-局部内部类" class="headerlink" title="3 局部内部类"></a>3 局部内部类</h4><ul>
<li>将内部类定义在方法里面就叫做局部内部类，类似于方法里面的局部变量</li>
<li>外界是无法直接使用，需要在方法内部创建对象并使用，</li>
<li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</li>
</ul>
<h4 id="4-匿名内部类"><a href="#4-匿名内部类" class="headerlink" title="4 匿名内部类"></a>4 匿名内部类</h4><ul>
<li>隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置[更常见]</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名内部类的格式</span></span><br><span class="line"><span class="keyword">new</span> 类名\接口名() &#123;</span><br><span class="line">    重写方法;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//最后的分号;，切记不能漏掉</span></span><br></pre></td></tr></table></figure></div>
<h5 id="4-1-格式细节"><a href="#4-1-格式细节" class="headerlink" title="4.1 格式细节"></a>4.1 格式细节</h5><ul>
<li>包含了继承或实现，方法重写，创建对象。</li>
<li>整体就是一个类的子类对象或者接口的实现类对象</li>
</ul>
<h5 id="4-2-应用场景"><a href="#4-2-应用场景" class="headerlink" title="4.2 应用场景"></a>4.2 应用场景</h5><p>当方法的参数是接口或者类时，<br>以接口为例，可以传递这个接口的实现类对象<br><strong>如果实现类只要用一次，就可以用匿名内部类简化代码。</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个匿名内部类实例</span></span><br><span class="line">        <span class="type">EventListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(String event)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Event received: &quot;</span> + event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用该实例</span></span><br><span class="line">        fireEvent(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fireEvent</span><span class="params">(EventListener listener)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟事件触发</span></span><br><span class="line">        listener.onEvent(<span class="string">&quot;Button clicked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义事件监听接口</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(String event)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/03/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>.</p>
<p><del>sds</del></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>Java正则表达式</title>
    <url>/2024/03/24/java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="Java正则表达式"><a href="#Java正则表达式" class="headerlink" title="Java正则表达式"></a>Java正则表达式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li>正则表达式是一种描述字符串模式的语言。</li>
<li>正则表达式可以用来搜索、编辑或处理文本。</li>
<li>Java 提供了 java.util.regex 包，它包含了 Pattern 和 Matcher 类，用于处理正则表达式的匹配操作。</li>
</ul>
<h4 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h4><ul>
<li>验证用户输入的数据是否合法。[检验字符串是否满足某种格式]</li>
<li>提取数据中的有效信息。</li>
<li>替换字符串中的部分字符。[对文本进行格式化]</li>
</ul>
<h4 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="3.基本语法"></a>3.基本语法</h4><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td><code>[]</code></td>
<td>里面的内容出现<strong>一次</strong>，<code>[]</code> 内不能嵌套使用 [ ]</td>
<td>[a-z]: a-z之间的任意字符</td>
</tr>
<tr>
<td><code>()</code></td>
<td>分组[按左括号计算组数,从1开始]</td>
<td>a(bc)+: bc为第一组,<code>+</code>作用在第一组<code>(bc)</code>上</td>
</tr>
<tr>
<td><code>^</code></td>
<td>取反，在表示取反的时候必须与 <code>[]</code> 搭配使用，位于 <code>[]</code> 的开头</td>
<td>[^a-z]: 不是a-z之间的任意字符</td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>交集,不能写单个的 <code>&amp;</code></td>
<td>[a-z&amp;&amp;[^bc]]: a-z之间的任意字符,但排除bc</td>
</tr>
<tr>
<td><span style="color:rgb(233,105,0)">|</span></td>
<td>写在方括号外面表示并集,不能写两个的 <span style="color:rgb(233,105,0)">||</span></td>
<td>[a-zA-Z]: a-z或A-Z之间的任意字符。 x|X: 大小写x都可以。 <mark><strong>注意:</strong> [a-z|A-Z]中的 <span style="color:rgb(233,105,0)">|</span> 只是一个普通的字符,并不表示并集。</mark></td>
</tr>
<tr>
<td><code>.</code></td>
<td>任意一个字符[回车符号不匹配]</td>
<td>a.b: 可以是acb、a0b、a吖b等。</td>
</tr>
<tr>
<td><code>\</code></td>
<td>转义字符</td>
<td>\\d : 匹配一个数字字符[0-9]。其中第一个<code>\</code>是用作转义字符，用于将后面的<code>\</code>转义成普通字符。第二个<code>\</code>后面紧跟着的d表示匹配一个数字字符。在正则表达式中，\d 是一个特殊的元字符，用于匹配数字字符。</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>数字</td>
<td>\\d: 匹配一个数字字符[0-9]。</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>非数字</td>
<td>\\D: 匹配一个非数字字符[^0-9]。</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>空格</td>
<td>\\s: 匹配一个空白字符[ \t\n\x0B\f\r]。</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>非空格</td>
<td>\\S: 匹配一个非空白字符[^ \t\n\x0B\f\r]。</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>字母数字下划线</td>
<td>\\w: 匹配一个单词字符[a-zA-Z_0-9]。</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>非字母数字下划线</td>
<td>\\W: 匹配一个非单词字符[^a-zA-Z_0-9]。</td>
</tr>
<tr>
<td><code>?</code></td>
<td>0或1次[作用在前者]</td>
<td>a?b: ab或b。?作用在a上，表示a为可选字符。</td>
</tr>
<tr>
<td><code>*</code></td>
<td>0或n次[作用在前者]</td>
<td>a*b: ab、abb、abbbb、…。*作用在a上，表示a为0或n次。</td>
</tr>
<tr>
<td><code>+</code></td>
<td>1或n次[作用在前者]</td>
<td>a+b: ab、abb、abbbb、…。+作用在a上，表示a为1或n次。</td>
</tr>
<tr>
<td><code>&#123;n&#125;</code></td>
<td>n次[作用在前者,填写具体次数]</td>
<td>a{2}b: abb。{n}作用在a上，表示a为n次。</td>
</tr>
<tr>
<td><code>&#123;n,m&#125;</code></td>
<td>n到m次[作用在前者,填写范围]</td>
<td>a{2,4}b: abb、abbb、abbbb。{n,m}作用在a上，表示a为n到m次。</td>
</tr>
<tr>
<td><code>&#123;n,&#125;</code></td>
<td>n次及以上[作用在前者,填写范围]</td>
<td>a{2,}b: abb、abbb、abbbb、…。{n,}作用在a上，表示a为n次以上。</td>
</tr>
<tr>
<td><code>&#123;,m&#125;</code></td>
<td>0到m次[作用在前者,填写范围]</td>
<td>a{,4}b: abb、abbb、abbbb、…。{,m}作用在a上，表示a为0到m次。</td>
</tr>
<tr>
<td><code>(?i)</code></td>
<td>忽略大小写[作用在后者]</td>
<td>(?i)abc: 匹配abc或ABC、…。a((?i)b)c: 只忽略b的大小写。</td>
</tr>
<tr>
<td><code>[\u4E00-\u9FFF·]</code></td>
<td>中文</td>
<td>[\u4E00-\u9FFF·]</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>Java的反斜杠<code>\</code>:</strong></p>
<ul>
<li>在其他语言中，\ 表示：<strong>我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。</strong></li>
<li>在 Java 中，\ 表示：<strong>我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。</strong></li>
</ul>
<p>所以，在其他的语言中（如 Perl），一个反斜杠 \ 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 \\ 代表其他语言中的一个 \，这也就是为什么表示一位数字的正则表达式是 \\d，而表示一个普通的反斜杠是 \\。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">System.out.print(<span class="string">&quot;\\&quot;</span>);    <span class="comment">// 输出为 \</span></span><br><span class="line">System.out.print(<span class="string">&quot;\\\\&quot;</span>);  <span class="comment">// 输出为 \\</span></span><br></pre></td></tr></table></figure></div>
<p><strong><code>^</code> 的两层含义：</strong></p>
<ul>
<li><strong>在方括号中</strong>：<code>^</code> 用于定义一个字符集合的取反。它位于方括号 <code>[]</code> 的开头（即字符集的第一个位置）时，表示匹配不在该字符集合中的任意字符。</li>
<li><strong>在方括号外</strong>：<code>^</code> 作为行开头的锚点（anchor），用于匹配字符串的开头（或在多行模式下，匹配每一行的开头）</li>
</ul>
</blockquote>
<h4 id="4-常用到的类"><a href="#4-常用到的类" class="headerlink" title="4.常用到的类"></a>4.常用到的类</h4><ul>
<li>Pattern: 正则表达式的编译表示。</li>
<li>Matcher: 正则表达式的匹配表示。</li>
</ul>
<h5 id="4-1-Pattern类-mk-20240904110906"><a href="#4-1-Pattern类-mk-20240904110906" class="headerlink" title="4.1. Pattern类 ^mk-20240904110906"></a>4.1. Pattern类 ^mk-20240904110906</h5><p><code>Pattern</code>类表示正则表达式模式，并提供了一系列静态方法来编译和处理正则表达式。</p>
<ul>
<li><strong>编译正则表达式：</strong> 使用<code>Pattern.compile()</code>方法来编译正则表达式字符串，并返回一个<code>Pattern</code>对象。<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;ab+c&quot;</span>);<span class="comment">// 参数是你要匹配的正则表达式字符串。</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h5 id="4-2-Matcher类"><a href="#4-2-Matcher类" class="headerlink" title="4.2. Matcher类"></a>4.2. Matcher类</h5><p><code>Matcher</code>类用于对字符串进行匹配操作，并提供了一系列方法来执行匹配和检索操作。</p>
<ul>
<li><p><strong>创建Matcher对象：</strong> 使用<code>Pattern.matcher()</code>方法将要匹配的字符串与<code>Pattern</code>对象相关联，创建一个<code>Matcher</code>对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;abbbbbbcsa&quot;</span>);<span class="comment">// 参数是你要匹配的字符串。</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>匹配操作：</strong></p>
<ul>
<li><code>matches()</code>: <ul>
<li><strong>作用</strong>: <code>matches()</code> 方法尝试将<strong>整个</strong>输入序列与指定的正则表达式进行匹配。</li>
<li><strong>返回值</strong>: 该方法返回一个布尔值 (<code>true</code> 或 <code>false</code>)。如果整个输入序列与模式完全匹配，则返回 <code>true</code>；否则返回 <code>false</code>。</li>
<li><strong>示例</strong>:</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\d+&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(input);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isMatch</span> <span class="operator">=</span> matcher.matches();  <span class="comment">// isMatch = true</span></span><br><span class="line"><span class="comment">//在这个例子中，matches() 方法会返回 true，因为整个字符串 &quot;12345&quot; 都是由数字组成，完全匹配模式 \\d+。</span></span><br></pre></td></tr></table></figure></div></li>
<li><code>find()</code>: 尝试查找输入序列中与模式匹配的子序列。<br>- <strong>作用</strong>: <code>find()</code> 方法尝试在输入序列中查找与模式匹配的子序列。与 <code>matches()</code> 不同，它不要求整个输入序列匹配，而是只需找到一个部分匹配即可。<br>- <strong>返回值</strong>: 该方法返回一个布尔值 (<code>true</code> 或 <code>false</code>)。如果找到了匹配的子序列，则返回 <code>true</code>，否则返回 <code>false</code>。<br>- <strong>多次调用</strong>: <code>find()</code> 可以多次调用，每次调用会继续查找下一个匹配的子序列，直到返回 <code>false</code> 为止。<br>- <strong>示例</strong>:<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;a12b34c&quot;</span>;</span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\d+&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(input);</span><br><span class="line"><span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">    System.out.println(matcher.group()); <span class="comment">// 输出 &quot;12&quot; 和 &quot;34&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">在这个例子中，find() 方法找到两个匹配的子序列 <span class="string">&quot;12&quot;</span> 和 <span class="string">&quot;34&quot;</span>。</span><br></pre></td></tr></table></figure></div></li>
<li><code>group()</code>: 返回当前匹配的子字符串。 ^mk-20240904000921<br>- <strong>作用</strong>: <code>group()</code> 方法用于返回当前匹配的子字符串。这通常是在 <code>matches()</code> 或 <code>find()</code> 方法之后调用的，用于提取实际匹配的内容。<br>- <strong>返回值</strong>: 返回当前匹配的子字符串。<br>- <strong>注意</strong>: <code>group()</code> 方法依赖于之前的匹配操作（如 <code>find()</code> 或 <code>matches()</code>）。如果没有进行成功的匹配，调用 <code>group()</code> 会抛出 <code>IllegalStateException</code>。<br>- <strong>示例</strong>:<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;hello123&quot;</span>;</span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d+)&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(input);</span><br><span class="line"><span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">    System.out.println(matcher.group()); <span class="comment">// 输出 &quot;123&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">在这个例子中，find() 找到了子字符串 <span class="string">&quot;123&quot;</span>，而 group() 返回了该匹配的子字符串</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><strong>检索操作：</strong></p>
<ul>
<li><code>start()</code>: 返回当前匹配的子字符串的起始索引。</li>
<li><code>end()</code>: 返回当前匹配的子字符串的结束索引后一位。<ul>
<li>字符串长度&#x3D; .end ( ) - .start ( )</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;The quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line"><span class="comment">// 匹配单词中的元音字母</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;the&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(text);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 输出匹配的子字符串的起始和结束索引</span></span><br><span class="line"><span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Start index: &quot;</span> + matcher.start()); <span class="comment">//输出: 31 -&gt; &#x27;t&#x27;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;End index: &quot;</span> + matcher.end());<span class="comment">// 输出: 34 -&gt; &#x27; &#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><strong>替换操作：</strong></p>
<ul>
<li><code>replaceAll(String replacement)</code>: 将匹配的子字符串替换为指定的字符串, 并返回新的字符串。</li>
<li><code>replaceFirst(String replacement)</code>: 将匹配的第一个子字符串替换为指定的字符串，并返回新的字符串。</li>
<li><code>appendReplacement(StringBuffer sb, String replacement)</code>: 将匹配的子字符串替换为指定的字符串，并将替换后的字符串添加到 <code>StringBuffer</code> 或 <code>StringBuilder</code> 对象中，通常与 find( ) 方法一起使用。每次调用 <code>appendReplacement()</code> 时，<code>Matcher</code> 会找到下一个匹配的子字符串，将其替换为 <code>replacement</code>，并把从上一次匹配结束位置到这次匹配开始之间的内容（未匹配部分）以及替换后的内容追加到 <code>StringBuffer sb</code> 中。<blockquote>
<p>它允许你逐步地控制替换的过程，并且可以在多次匹配和替换之间动态修改 <code>replacement</code> 的内容</p>
</blockquote>
</li>
<li><code>appendTail(StringBuffer sb)</code>: 当所有匹配和替换都完成后，<code>appendTail()</code> 会将输入字符串中最后一次匹配之后的所有剩余部分追加到 <code>StringBuffer</code> 或 <code>StringBuilder</code> 对象中，完成整个字符串的构建。 ^mk-20240904000942<blockquote>
<p>这个方法通常与 <code>appendReplacement()</code> 一起使用，用于完成整个替换过程。</p>
</blockquote>
</li>
</ul>
  <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// replaceAll(String replacement)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;abc123xyz456&quot;</span>;</span><br><span class="line">	<span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\d+&quot;</span>);</span><br><span class="line">	<span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(input);</span><br><span class="line">	<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> matcher.replaceAll(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">	System.out.println(result); <span class="comment">// 输出 &quot;abc#xyz#&quot;  </span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// replaceFirst(String replacement)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;abc123xyz456&quot;</span>;</span><br><span class="line">	<span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\d+&quot;</span>);</span><br><span class="line">	<span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(input);</span><br><span class="line">	<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> matcher.replaceFirst(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">	System.out.println(result); <span class="comment">// 输出 &quot;abc#xyz456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// appendReplacement(StringBuffer sb, String replacement)</span></span><br><span class="line"><span class="comment">// appendTail(StringBuffer sb)</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;abc123xyz456def&quot;</span>;</span><br><span class="line"> <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\d+&quot;</span>);</span><br><span class="line"> <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(input);</span><br><span class="line"> <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">     matcher.appendReplacement(sb, <span class="string">&quot;#&quot;</span>);</span><br><span class="line">     <span class="comment">// 此时 sb 的内容依次变为:</span></span><br><span class="line">     <span class="comment">// 第一次匹配 &quot;123&quot;: &quot;abc#&quot;</span></span><br><span class="line">     <span class="comment">// 第二次匹配 &quot;456&quot;: &quot;abc#xyz#&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 所有匹配处理完后，使用 appendTail 将剩余部分追加到 sb 中</span></span><br><span class="line"> matcher.appendTail(sb);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 最终的 sb.toString() 是 &quot;abc#xyz#def&quot;</span></span><br><span class="line"> System.out.println(sb.toString());</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h5 id="4-3-正则表达式标志"><a href="#4-3-正则表达式标志" class="headerlink" title="4.3. 正则表达式标志"></a>4.3. 正则表达式标志</h5><p>正则表达式编译时可以使用一些标志来修改匹配的行为。这些标志通常作为第二个参数传递给<code>Pattern.compile()</code>方法。</p>
<ul>
<li><p><strong>忽略大小写（CASE_INSENSITIVE &#x2F; (?i)）：</strong> 使匹配不区分大小写。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;cat&quot;</span>, Pattern.CASE_INSENSITIVE);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(?i)cat&quot;</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>多行模式（MULTILINE &#x2F; (?m)）：</strong> 使<code>^</code>和<code>$</code>匹配每行的开始和结束，而不是整个输入序列的开始和结束。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^dog&quot;</span>, Pattern.MULTILINE);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(?m)^dog&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;dog\ncat\ndog&quot;</span>;</span><br><span class="line"><span class="type">Pattern</span> <span class="variable">patternDefault</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^dog&quot;</span>);      <span class="comment">// 默认模式下，&quot;^&quot; 只匹配整个文本的开始</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">patternMultiline</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^dog&quot;</span>, Pattern.MULTILINE); <span class="comment">// 多行模式下，&quot;^&quot; 匹配每一行的开始</span></span><br><span class="line"></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcherDefault</span> <span class="operator">=</span> patternDefault.matcher(text);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcherMultiline</span> <span class="operator">=</span> patternMultiline.matcher(text);</span><br><span class="line"></span><br><span class="line">System.out.println(matcherDefault.find());  <span class="comment">// 输出 true，只匹配第一行 &quot;dog&quot;</span></span><br><span class="line">System.out.println(matcherMultiline.find()); <span class="comment">// 输出 true，因为匹配了第一行的 &quot;dog&quot;</span></span><br><span class="line">System.out.println(matcherMultiline.find()); <span class="comment">// 再次输出 true，因为匹配了第三行的 &quot;dog&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * 在默认模式下，由于正则表达式中 ^ 的存在，只能调用一次matcherDefault.find()，而调用多次matcherDefault.find()是没有意义的  </span></span><br><span class="line"><span class="comment"> * 在多行模式下，find函数的调用并不是说一次只能匹配一行，而是可以跨行匹配直到找到匹配字符串后返回，或者遍历完整个字符串为止  </span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>单行模式（DOTALL &#x2F; (?s)）：</strong> 使<code>.</code>匹配包括换行符在内的所有字符。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;.*&quot;</span>, Pattern.DOTALL);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(?s).*&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello\nWorld&quot;</span>;</span><br><span class="line"><span class="type">Pattern</span> <span class="variable">patternDefault</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;.*&quot;</span>);       <span class="comment">// 默认模式下，&quot;.&quot; 不匹配换行符</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">patternDotAll</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;.*&quot;</span>, Pattern.DOTALL);  <span class="comment">// 单行模式下，&quot;.&quot; 可以匹配换行符</span></span><br><span class="line"></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcherDefault</span> <span class="operator">=</span> patternDefault.matcher(text);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcherDotAll</span> <span class="operator">=</span> patternDotAll.matcher(text);</span><br><span class="line"></span><br><span class="line">System.out.println(matcherDefault.matches());  <span class="comment">// 输出 false，因为 &quot;.&quot; 无法匹配换行符</span></span><br><span class="line">System.out.println(matcherDotAll.matches());   <span class="comment">// 输出 true，因为 &quot;.&quot; 可以匹配换行符</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>这些是一些常见的标志，但Java支持更多其他标志，可以根据需要使用。标志可以组合使用，例如<code>Pattern.compile(&quot;pattern&quot;, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE)</code>。</p>
<h4 id="5-捕获分组和非捕获分组"><a href="#5-捕获分组和非捕获分组" class="headerlink" title="5.捕获分组和非捕获分组"></a>5.捕获分组和非捕获分组</h4><h5 id="5-1-捕获分组-后续还要继续使用本组的数据"><a href="#5-1-捕获分组-后续还要继续使用本组的数据" class="headerlink" title="5.1. 捕获分组[后续还要继续使用本组的数据]"></a>5.1. 捕获分组[后续还要继续使用本组的数据]</h5><p><strong>基本概念:</strong></p>
<ul>
<li>每组都是由<code>()</code>括起来。</li>
<li>捕获分组：捕获分组会记住匹配的文本，并可以在匹配后引用这些文本。<br><strong>分组规则:</strong> ^mk-20240904000918</li>
<li>从1开始,连续不间断</li>
<li>以左括号为基准,最左边的是第一组,其次为第二组,以此类推<br><strong>使用规则:</strong></li>
<li>正则表达式内部使用: \\组号</li>
<li>正则表达式外部使用: $组号</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部使用</span></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexInternalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\b\\w+\\b) \\1&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;hello hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Matched: &quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No match found.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部使用</span></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexExternalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\b\\w+\\b) \\1&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;hello hello world world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> matcher.replaceAll(<span class="string">&quot;$1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h5 id="5-2-非捕获分组-分组后不再使用本组数据"><a href="#5-2-非捕获分组-分组后不再使用本组数据" class="headerlink" title="5.2. 非捕获分组[分组后不再使用本组数据]"></a>5.2. 非捕获分组[分组后不再使用本组数据]</h5><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td><code>(?:regex)</code></td>
<td>匹配<code>regex</code>,获取所有文本,包括<code>regex</code></td>
<td>Java(?:8|11|17)</td>
</tr>
<tr>
<td><code>(?=regex)</code></td>
<td>匹配<code>regex</code>,只获取前面部分文本,不包括<code>regex</code></td>
<td>Java(?&#x3D;8|11|17)</td>
</tr>
<tr>
<td><code>(?!regex)</code></td>
<td>获取不匹配<code>regex</code>的文本的前面部分,不包括<code>regex</code></td>
<td>Java(?!8|11|17)</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，&quot;</span> +</span><br><span class="line">                <span class="string">&quot;因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//?: 匹配`regex`,获取所有文本,包括`regex`</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">regex2</span> <span class="operator">=</span> <span class="string">&quot;Java(?:8|11|17)&quot;</span>;<span class="comment">//Java8 Java11 Java17 Java17</span></span><br><span class="line">    <span class="comment">//?= 匹配`regex`,只获取前面部分文本,不包括`regex`</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">regex1</span> <span class="operator">=</span> <span class="string">&quot;Java(?=8|11|17)&quot;</span>;<span class="comment">//Java Java Java Java</span></span><br><span class="line">    <span class="comment">//?! 获取不匹配`regex`的文本的前面部分,不包括`regex`</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">regex3</span> <span class="operator">=</span> <span class="string">&quot;Java(?!8|11|17)&quot;</span>;<span class="comment">//Java</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(regex1);</span><br><span class="line"></span><br><span class="line">    <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> p.matcher(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (matcher.find())&#123;</span><br><span class="line">        System.out.print(matcher.group()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>公共字段填充</title>
    <url>/2024/07/17/%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85/</url>
    <content><![CDATA[<h2 id="回顾AOP切面编程"><a href="#回顾AOP切面编程" class="headerlink" title="回顾AOP切面编程"></a>回顾AOP切面编程</h2><h3 id="获取方法名、参数值、参数值类型、目标注解对象、目标方法所在类、返回值类型"><a href="#获取方法名、参数值、参数值类型、目标注解对象、目标方法所在类、返回值类型" class="headerlink" title="获取方法名、参数值、参数值类型、目标注解对象、目标方法所在类、返回值类型"></a>获取方法名、参数值、参数值类型、目标注解对象、目标方法所在类、返回值类型</h3><h4 id="1-引入Maven依赖"><a href="#1-引入Maven依赖" class="headerlink" title="1. 引入Maven依赖"></a>1. 引入Maven依赖</h4><div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="2-创建一个自定义注解类CacheableTest"><a href="#2-创建一个自定义注解类CacheableTest" class="headerlink" title="2. 创建一个自定义注解类CacheableTest"></a>2. 创建一个自定义注解类CacheableTest</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheableTest &#123;</span><br><span class="line">    String <span class="title function_">key</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">expireTime</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">3600</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-创建一个controller类，并加入该方法"><a href="#3-创建一个controller类，并加入该方法" class="headerlink" title="3. 创建一个controller类，并加入该方法"></a>3. 创建一个controller类，并加入该方法</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/findPage2&quot;)</span></span><br><span class="line"><span class="meta">@CacheableTest(key=&quot;haha&quot;,value = &quot;hehe&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findPage2</span><span class="params">(Integer pageNumber, Double pageSize)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;findPage2请求成功！！！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;请求成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="4-创建一个切面类-TestAOP"><a href="#4-创建一个切面类-TestAOP" class="headerlink" title="4. 创建一个切面类 TestAOP"></a>4. 创建一个切面类 TestAOP</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAop</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * ink.lusy.helloController.*(..))&quot;)</span>    <span class="comment">//第一个星号指返回值类型为任意</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(value = &quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint joinpoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------Before开始-----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;方法名：&quot;</span>+ joinpoint.getSignature().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;参数值集合：&quot;</span>+ Arrays.asList(joinpoint.getArgs()));</span><br><span class="line">        System.out.println(<span class="string">&quot;参数值1类型：&quot;</span>+ joinpoint.getArgs()[<span class="number">0</span>].getClass().getTypeName());</span><br><span class="line">        System.out.println(<span class="string">&quot;参数值2类型：&quot;</span>+ joinpoint.getArgs()[<span class="number">1</span>].getClass().getTypeName());</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">classType</span> <span class="operator">=</span> joinpoint.getTarget().getClass().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取目标方法所在类：&quot;</span>+ classType);</span><br><span class="line">        <span class="comment">//获取目标注解对象，CacheableTest是自定义的一个注解</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) joinpoint.getSignature();</span><br><span class="line">        <span class="type">CacheableTest</span> <span class="variable">cacheable</span> <span class="operator">=</span> methodSignature.getMethod().getAnnotation(CacheableTest.class);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">returnType</span> <span class="operator">=</span> methodSignature.getReturnType();</span><br><span class="line">        System.out.println(<span class="string">&quot;目标注解对象：&quot;</span>+ cacheable);</span><br><span class="line">        System.out.println(<span class="string">&quot;返回值类型 = &quot;</span> + returnType);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------Before结束-----------&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(value = &quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfter</span><span class="params">(JoinPoint joinpoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------After开始------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------After结束-------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>执行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gitee.com/lusy37/typora/raw/master/202411092229413.png"
                      alt="image-20241109222954073"
                ></p>
<blockquote>
<p>在请求时pageSize写的是1，这里自动转成1.0</p>
</blockquote>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h3><p>在添加、修改 <code>管理员、用户、菜品</code> 等数据时，总是要重复的修改相同的字段：<code>CreateTime</code>、<code>UpdateTime</code>、<code>CreateUser</code>、<code>UpdateUser</code></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用AOP切面编程在施行对应的新增、修改 SQL语句之前，给对应字段做出统一的处理</p>
<h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><ol>
<li><strong>引入Maven依赖</strong></li>
</ol>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><strong>创建一个枚举类OperationType：区分新增、更新操作</strong></li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OperationType</span> &#123;</span><br><span class="line">    <span class="comment">//更新操作</span></span><br><span class="line">    UPDATE,</span><br><span class="line">    <span class="comment">//插入操作</span></span><br><span class="line">    INSERT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><strong>创建一个自定义注解类AutoFill：自定义注解，用于标识某个方法需要进行功能字段自动填充处理</strong></li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoFill &#123;</span><br><span class="line">    <span class="comment">// 数据库操作类型</span></span><br><span class="line">    OperationType <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li><strong>创建一个切面类 AutoFillAspect：自定义切面，实现公共字段自动填充处理</strong></li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoFillAspect</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; &quot; +</span></span><br><span class="line"><span class="meta">            &quot;@annotation(com.sky.annotation.AutoFill)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFillPointcut</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知，在通知中进行公共字段的赋值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;autoFillPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFill</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="comment">// 可先进行调试，是否能进入该方法，提前在mapper方法添加@AutoFill注解</span></span><br><span class="line">        log.info(<span class="string">&quot;开始进行公共字段的赋值&quot;</span>);</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();<span class="comment">//方法签名对象</span></span><br><span class="line">        <span class="type">AutoFill</span> <span class="variable">autoFill</span> <span class="operator">=</span> signature.getMethod().getAnnotation(AutoFill.class);<span class="comment">//获取方法上的注解对象</span></span><br><span class="line">        <span class="type">OperationType</span> <span class="variable">operationType</span> <span class="operator">=</span> autoFill.value();<span class="comment">//获取数据库操作类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取到当前被拦截的方法的参数--实体对象</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="keyword">if</span> (args &lt;mark&gt; <span class="literal">null</span> || args.length &lt;/mark&gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">entity</span> <span class="operator">=</span> args[<span class="number">0</span>]; <span class="comment">// 约定好要使用公共字段填充，就必须把操作的对象放在第一个参数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备赋值的数据</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据当前不同的操作类型，为对应的属性通过反射来赋值</span></span><br><span class="line">        <span class="keyword">if</span> (operationType == OperationType.INSERT) &#123;</span><br><span class="line">            <span class="comment">//为4个公共字段赋值</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setCreateTime</span> <span class="operator">=</span> entity.getClass()</span><br><span class="line">                    .getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);</span><br><span class="line">                </span><br><span class="line">                <span class="type">Method</span> <span class="variable">setCreateUser</span> <span class="operator">=</span> entity.getClass()</span><br><span class="line">                    .getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);</span><br><span class="line">                </span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass()</span><br><span class="line">                    .getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);</span><br><span class="line">                </span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass().</span><br><span class="line">                    getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//通过反射为对象属性赋值</span></span><br><span class="line">                setCreateTime.invoke(entity,now);</span><br><span class="line">                setCreateUser.invoke(entity,currentId);</span><br><span class="line">                setUpdateTime.invoke(entity,now);</span><br><span class="line">                setUpdateUser.invoke(entity,currentId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(operationType == OperationType.UPDATE)&#123;</span><br><span class="line">            <span class="comment">//为2个公共字段赋值</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass()</span><br><span class="line">                    .getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);</span><br><span class="line">                </span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass()</span><br><span class="line">                    .getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//通过反射为对象属性赋值</span></span><br><span class="line">                setUpdateTime.invoke(entity,now);</span><br><span class="line">                setUpdateUser.invoke(entity,currentId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(entity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li><strong>使用示例：</strong></li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Insert(&quot;insert into employee (name, username, password, phone, sex, id_number, create_time, update_time, create_user, update_user) &quot; +</span></span><br><span class="line"><span class="meta">        &quot;VALUES &quot; +</span></span><br><span class="line"><span class="meta">        &quot;(#&#123;name&#125;,#&#123;username&#125;, #&#123;password&#125;, #&#123;phone&#125;, #&#123;sex&#125;, #&#123;idNumber&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)&quot;)</span></span><br><span class="line"><span class="meta">@AutoFill(value = OperationType.INSERT)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Employee employee)</span>;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>工具集</tag>
      </tags>
  </entry>
  <entry>
    <title>发送邮箱API</title>
    <url>/2024/07/17/%E5%8F%91%E9%80%81%E9%82%AE%E7%AE%B1.API/</url>
    <content><![CDATA[<h2 id="SpringBoot整合Email-邮件发送"><a href="#SpringBoot整合Email-邮件发送" class="headerlink" title="SpringBoot整合Email 邮件发送"></a>SpringBoot整合Email 邮件发送</h2><h4 id="一-准备"><a href="#一-准备" class="headerlink" title="一.准备"></a>一.准备</h4><p>在创建SpringBoot项目 选择依赖时 发现其选择依赖时有邮件发送与Springboot整合的jar包，我们勾选即可  </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/004d852ca5d8d75bcc27694f478ae359.png"
                      alt="在这里插入图片描述"
                ></p>
<p>如果未勾选也不要紧，咱们手动导入</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>本项目是基于页面测试的，所以我又引入了相关web依赖 ，简化实体类代码引入了lombok依赖</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="二-邮件发送需要的配置"><a href="#二-邮件发送需要的配置" class="headerlink" title="二.邮件发送需要的配置"></a>二.邮件发送需要的配置</h4><p>因为各大邮件都有其对应安全系统，不是项目中想用就可以用的，我们必须要拿到其对应的客户端授权码才行，拿到授权码，在项目中配置SMTP服务协议以及主机配置账户 ，就可以在项目中使用各大邮件运营商进行发送邮件了获取客户端授权码过程由于国内使用163邮箱以及qq邮箱较多所以本文中仅仅展示这两个运营商获取客户端授权码的步骤</p>
<h5 id="获取163邮箱授权码"><a href="#获取163邮箱授权码" class="headerlink" title="获取163邮箱授权码"></a>获取163邮箱授权码</h5><p>登陆163邮箱查看勾选服务是否开启，如未开启则勾选  </p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/3086d522528624d9ded83b82a7c75d45.png"
                      alt="在这里插入图片描述|575"
                ><br> 因为我在做本项目是已经是开启了，所以这里是叫我重置客户端授权码了  </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/93f716ac53113fc56adf89d55dadd22c.png"
                      alt="在这里插入图片描述|575"
                ><br> 在未设置授权码时点击此页面回叫你使用当前邮箱账号绑定的手机号发送一条短信确认发送后，确认成功后，便可自定义163邮箱的客户端授权码了  </p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/715472cb14cbc28faa5d2db5abefdc3a.png"
                      alt="在这里插入图片描述|500"
                >  </p>
<h5 id="获取QQ邮箱授权码"><a href="#获取QQ邮箱授权码" class="headerlink" title="获取QQ邮箱授权码"></a>获取QQ邮箱授权码</h5><p>登陆qq邮箱后，点击设置 选择 账户选项<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/4894044e13985e03f3dd56eab4bdc3a2.png"
                      alt="在这里插入图片描述|525"
                ><br> 向下拉选择开启POP3&#x2F;SMTP 服务<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/aebee07c86f6528f08421ef0b78f7bd0.png"
                      alt="在这里插入图片描述|525"
                ><br> 点击开启也会进入验证 验证成功后即可看到自己qq邮箱的客户端授权码了  </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/07787939fc15b5b6fe6a31ad2508f699.png"
                      alt="在这里插入图片描述|500"
                ><br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/1f6aacb703ab1862da9fc766f30ba17b.png"
                      alt="在这里插入图片描述|525"
                >  </p>
<p>我们在拿到授权码后，就可以在我们Springboot工程中的配置文件 aplication.yml 或者properties文件中配置了</p>
<h5 id="YML配置"><a href="#YML配置" class="headerlink" title="YML配置"></a>YML配置</h5><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mail:</span><br><span class="line">    #smtp服务主机  qq邮箱则为smtp.qq.com</span><br><span class="line">    host: smtp.163.com</span><br><span class="line">    #服务协议</span><br><span class="line">    protocol: smtp</span><br><span class="line">    # 编码集</span><br><span class="line">    default-encoding: UTF-8</span><br><span class="line">    #发送邮件的账户</span><br><span class="line">    username: xxxxxxx@163.com</span><br><span class="line">    #授权码</span><br><span class="line">    password: xxxxxx</span><br><span class="line">    test-connection: true</span><br><span class="line">    properties:</span><br><span class="line">      mail:</span><br><span class="line">        smtp:</span><br><span class="line">          auth: true</span><br><span class="line">          starttls:</span><br><span class="line">            enable: true</span><br><span class="line">            required: true</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="三-代码编写"><a href="#三-代码编写" class="headerlink" title="三.代码编写"></a>三.代码编写</h4><p>下面开始Springboot项目中发送邮件的代码编写其实也非常简单 ，Springboot已经给我们邮件发送进行了非常好的整合了，我们只需要注入邮件发送接口调用其中的方法，就能轻松而愉悦的进行邮件发送了！</p>
<p>我们只需要在任意交由Spring管理的类（例如你的service层等）下注入以下接口即可</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JavaMailSender mailSender;</span><br></pre></td></tr></table></figure></div>

<p>由于每一封邮件都有固定的内容 例如 收件人信息 邮件内容 邮件标题那么我们充分利用java面向对象的特性，我们吧邮件发送抽取为一个对象代码采用了lombok进行简化</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToEmail</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 邮件接收方，可多人</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> String[] tos;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 邮件主题</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> String subject;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 邮件内容</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> String content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>肯定有人纳闷了，那么接收方有了，发送方呢？<br>发送一方，肯定就是我们自身拿到的授权码账号啊 ，我们获取账户客户端授权码其目的就是为了让代码代替我们自身邮箱向其他邮箱发送信息而已。</p>
<p>获取发送方账户信息</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String from;</span><br></pre></td></tr></table></figure></div>

<p>统一说明： JsonReturn 为我项目自定义的Ajax 响应，结合 RestController或者Responsebody向前端返回统一的JSON格式数据</p>
<h5 id="普通邮件发送"><a href="#普通邮件发送" class="headerlink" title="普通邮件发送"></a>普通邮件发送</h5><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> JsonReturn <span class="title function_">commonEmail</span><span class="params">(ToEmail toEmail)</span> &#123;</span><br><span class="line">    <span class="comment">//创建简单邮件消息</span></span><br><span class="line">    <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line">    <span class="comment">//谁发的</span></span><br><span class="line">    message.setFrom(from);</span><br><span class="line">    <span class="comment">//谁要接收</span></span><br><span class="line">    message.setTo(toEmail.getTos());</span><br><span class="line">    <span class="comment">//邮件标题</span></span><br><span class="line">    message.setSubject(toEmail.getSubject());</span><br><span class="line">    <span class="comment">//邮件内容</span></span><br><span class="line">    message.setText(toEmail.getContent());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      mailSender.send(message);</span><br><span class="line">      <span class="keyword">return</span> JsonReturn.buildSuccess(toEmail.getTos(), <span class="string">&quot;发送普通邮件成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MailException e) &#123;</span><br><span class="line">                                    </span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> JsonReturn.buildFailure(<span class="string">&quot;普通邮件方失败&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/59a4bfdaec5167bb0f76195ef478f632.png"
                      alt="在这里插入图片描述|525"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/87a0adc91922602bae1a260efa2b18fc.png"
                      alt="在这里插入图片描述"
                >  
 </p>
]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>工具集</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 多线程</title>
    <url>/2024/05/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Java-多线程"><a href="#Java-多线程" class="headerlink" title="Java 多线程"></a>Java 多线程</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-1-程序、进程、线程"><a href="#1-1-程序、进程、线程" class="headerlink" title="1.1.程序、进程、线程"></a>1.1.程序、进程、线程</h3><ul>
<li>程序(program)<ul>
<li>程序是为完成特定任务，使用某种语言编写的一组指令的集合。即指 <strong>一段静态的代码</strong>（还没有运行起来），静态对象。</li>
</ul>
</li>
<li>进程(process)<ul>
<li>进程是程序的一次执行过程，也就是说程序运行起来了，加载到内存中，并占用了CPU的资源。这是一个动态的过程：有自身的产生、存在和消亡的过程，这也就是一个进程的生命周期。</li>
<li><strong>进程是系统资源分配的单位</strong> ，系统在运行时会为每一个进程分配不同的内存区域。</li>
</ul>
</li>
<li>线程(thread)<ul>
<li>线程可进一步细化线程，是一个程序内部的执行路径。</li>
<li>若一个进程同一时间并行执行了多个线程，那么这个进程就是支持多线程的。</li>
<li><strong>线程是CPU调度和执行的单位，每一个线程都拥有独立的运行栈和程序计数器(pc)</strong>，线程切换的开销小。</li>
<li>一个进程中，所有的线程<strong>共享相同的内存单元&#x2F;内存地址空间</strong>，它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程之间的通信更加便捷、高效。但多个线程操作共享的系统资源也带来了一些潜在的<strong>安全隐患</strong>，例如：数据竞争和死锁等问题。</li>
<li>配合JVM内存结构了解<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240509225613.png"
                     
                ><br>class文件会通过类加载器加载到内存空间。<br>其中内存区域中的每一个线程都会有一个独立的虚拟机栈和程序计数器。<br>每一个进程都会有一个方法区和堆，多个线程共享同一个进程下的方法区和堆。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>多线程与多进程的比较：</strong></p>
<ul>
<li>创建线程的开销通常小于创建进程的开销，因为线程共享了进程的资源。</li>
<li>线程之间的通信相对容易，因为它们共享同一进程的地址空间。</li>
<li>多进程的稳定性高于多线程，因为一个进程的崩溃通常不会影响其他进程，但线程的崩溃可能导致整个程序的崩溃。</li>
</ul>
</blockquote>
<h3 id="1-2-并行与并发"><a href="#1-2-并行与并发" class="headerlink" title="1.2.并行与并发"></a>1.2.并行与并发</h3><ul>
<li>并行：多个CPU同时执行多个任务。eg：多个人做不同的事。</li>
<li>并发：一个CPU（采用时间片）同时执行多个任务。eg：一个人做多个事。</li>
</ul>
<h3 id="1-3-CPU单核和多核的理解"><a href="#1-3-CPU单核和多核的理解" class="headerlink" title="1.3.CPU单核和多核的理解"></a>1.3.CPU单核和多核的理解</h3><ul>
<li>单核CPU在同一时间只能执行一个线程的任务，同时间段内有多个线程需要CPU去运行时，CPU也只能交替地执行这些线程中的一个线程，并不能真正实现并行执行，但由于CPU的执行速度非常快，多个线程之间的切换可能会发生得非常快，给人的感觉就像是同时运行一样，造成单核的CPU可以实现多线程的假象。</li>
<li>多核CPU则可以同时执行多个线程的任务，每个核心都能独立地执行线程，从而更好地发挥多线程的效率。在多核CPU上，可以实现真正的并行执行，每个核心都可以独立地执行一个线程的任务，提高了系统的整体性能。</li>
</ul>
<p>对于Java应用程序java.exe来讲，至少会存在三个线程：main（）主线程、gcc（）垃圾回收线程、异常处理线程【如果发生异常时会影响主线程】。</p>
<h3 id="1-4-用户线程与守护线程"><a href="#1-4-用户线程与守护线程" class="headerlink" title="1.4.用户线程与守护线程"></a>1.4.用户线程与守护线程</h3><ul>
<li>用户线程：用户自定义创建的进程，它们由用户代码启动并执行。JVM会在终止之前等待任何用户进程完成其任务。【<strong>主线程停止，用户线程并不会直接停止，会继续执行，直到完成其任务或显式被中止</strong>】</li>
<li>守护线程：守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程。守护线程通常用于执行一些不需要在程序结束前完全执行的后台任务。【<strong>当所有的用户线程都执行完毕并且主线程退出时，JVM 会自动停止所有的守护线程，即使它们还没有执行完任务</strong>】 eg：Java的gc()垃圾回收线程就是一个守护线程。</li>
</ul>
<h3 id="1-5-多线程的优点"><a href="#1-5-多线程的优点" class="headerlink" title="1.5.多线程的优点"></a>1.5.多线程的优点</h3><ul>
<li>提高应用程序的响应。对图像化界面更有意义，可以增强用户体验。</li>
<li>提高计算机CPU的利用率。</li>
<li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。</li>
</ul>
<h3 id="1-6-应用场景"><a href="#1-6-应用场景" class="headerlink" title="1.6.应用场景"></a>1.6.应用场景</h3><ul>
<li>程序需要同时执行两个或多个任务</li>
<li>IO密集型程序：1.解决超时 2.防止阻塞</li>
<li>需要一些后台运行的程序时</li>
<li>迅雷多线程下载、数据库连接池、分批发送短信等</li>
</ul>
<h2 id="2-线程的生命周期"><a href="#2-线程的生命周期" class="headerlink" title="2. 线程的生命周期"></a>2. 线程的生命周期</h2><h3 id="2-1-线程的状态图"><a href="#2-1-线程的状态图" class="headerlink" title="2.1.线程的状态图"></a>2.1.线程的状态图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240511201316.png"
                     
                ></p>
<h3 id="2-2-线程状态详细说明"><a href="#2-2-线程状态详细说明" class="headerlink" title="2.2.线程状态详细说明"></a>2.2.线程状态详细说明</h3><h4 id="新建（New）"><a href="#新建（New）" class="headerlink" title="新建（New）"></a>新建（New）</h4><ul>
<li>使用new创建一个线程（Thread）之后，但还没有调用start()方法时。</li>
<li>该状态下线程对象已经被创建，但还未开始执行。</li>
</ul>
<h4 id="可运行（Runnable）"><a href="#可运行（Runnable）" class="headerlink" title="可运行（Runnable）"></a>可运行（Runnable）</h4><ul>
<li>当线程调用start()方法之后，线程就处于可运行状态，会创建方法调用栈和程序计数器，这个状态还可继续拆分成2个状态：<ul>
<li>就绪（Ready）：处于线程就绪队列、等待分配CPU时间片</li>
<li>运行（Running）：线程获得CPU时间片，开始执行run()方法，可能变为阻塞状态、就绪状态、死亡状态</li>
</ul>
</li>
</ul>
<h4 id="阻塞（Blocked）"><a href="#阻塞（Blocked）" class="headerlink" title="阻塞（Blocked）"></a>阻塞（Blocked）</h4><ul>
<li>纯粹的阻塞状态通常是指线程被动地暂时停止执行，直到某些条件满足为止，而不涉及等待一段时间或等待其他线程的唤醒。存在以下两种情况：<ul>
<li>等待获得锁</li>
<li>调用一个阻塞式IO</li>
</ul>
</li>
<li>阻塞状态线程无法直接转为运行状态，需要先转为就绪状态</li>
</ul>
<h4 id="等待（Waiting）"><a href="#等待（Waiting）" class="headerlink" title="等待（Waiting）"></a>等待（Waiting）</h4><ul>
<li>线程进入等待状态通常是因为需要等待其他线程满足某些条件或执行某些操作，等待的时间是不确定的。</li>
<li>进入等待状态的方法：<ul>
<li><p><code>Object.wait()方法</code>：</p>
<ul>
<li>只能在synchronized代码块或synchronized方法中调用。</li>
<li>调用前必须获得对象的锁，否则会抛出IllegalMonitorStateException异常。</li>
<li>wait()方法调用时会释放持有的对象锁。</li>
<li>调用wait()方法，需要等待<code>notify()</code>或<code>notifyAll()</code>方法唤醒。</li>
</ul>
</li>
<li><p><code>Thread.join()方法</code>:</p>
<ul>
<li>可以在任何时候调用，通常用于等待指定的线程【即调用join()方法的线程】执行完毕。</li>
<li>调用前不需要获得任何锁，但会等待目标线程执行完毕后返回。</li>
<li>若调用前持有对象锁，并不会释放持有的对象锁。</li>
</ul>
</li>
<li><p><code>LockSupport.park()/LockSupport.park(Thread thread)方法</code>：</p>
<ul>
<li>可以在任何时候调用，通常和LockSupport类一起使用。</li>
<li>无参时当前线程进入等待状态，有参时指定线程进入等待状态。</li>
<li>调用前不需要获得任何锁。</li>
<li>若调用前持有对象锁，并不会释放持有的对象锁。</li>
<li>调用LockSupport.park()方法，需要等待<code>LockSupport.unpark(Thread thread)</code>方法唤醒，这种方式唤醒打断标记为false。</li>
<li>也可以使用 <code>thread.interrupt ()</code> 进行唤醒，但是这样子打断标记会标记为 true。</li>
</ul>
<blockquote>
<ul>
<li>如果打断标记已经是 true, 则 park 会失效</li>
<li>如果在 park 之前调用了 unpark 方法，那么 park 将不会使线程进入等待状态，而是继续执行，也就是说 unpark 方法可以提前调用</li>
</ul>
 <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;打断状态：&quot;</span> + Thread.currentThread().isInterrupted());<span class="comment">//打断状态：true</span></span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    </span><br><span class="line">    t1.interrupt();<span class="comment">////打断状态：true</span></span><br><span class="line">    <span class="comment">//LockSupport.unpark(t1);//打断状态：false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出：</span></span><br><span class="line"><span class="comment"> * park...</span></span><br><span class="line"><span class="comment"> * unpark...</span></span><br><span class="line"><span class="comment"> * 打断状态：true</span></span><br><span class="line"><span class="comment"> * unpark...</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div></blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="超时等待（TIME-WAITING）"><a href="#超时等待（TIME-WAITING）" class="headerlink" title="超时等待（TIME_WAITING）"></a>超时等待（TIME_WAITING）</h4><ul>
<li>线程进入超时等待状态是因为需要等待一段时间后再继续执行，等待的时间是确定的。</li>
<li>进入超时等待状态的方法：<ul>
<li><code>Thread.sleep(long millis)</code>:<ul>
<li>让当前线程睡眠指定的毫秒数。</li>
<li>调用该方法后，当前线程会暂停执行指定的毫秒数，然后继续执行。</li>
<li>这个方法不会释放持有的锁。</li>
</ul>
</li>
<li><code>Object.wait(long timeout)</code>:<ul>
<li>使当前线程等待指定的毫秒数，或者直到其他线程调用了相同对象的<code>notify()</code>或<code>notifyAll()</code>方法。</li>
<li>当前线程会进入超时等待状态，直到等待时间超时，或者其他线程调用了相同对象的<code>notify()</code>或<code>notifyAll()</code>方法。</li>
<li>调用wait()方法会释放持有的对象锁，直到被唤醒后重新获取锁才会继续执行。</li>
</ul>
</li>
<li><code>Thread.join(long millis)</code>:<ul>
<li>等待调用join()方法的线程执行完毕，或者直到指定的毫秒数之后。【若参数为0，则表示永远等待】</li>
<li>如果调用join()方法的线程在指定的时间内执行完毕，则当前线程会恢复执行。</li>
<li>这个方法不会释放持有的锁。</li>
</ul>
</li>
<li><code>LockSupport.parkNanos(long nanos)</code>:<ul>
<li>使当前线程进入超时等待状态，直到指定的<strong>纳秒数</strong>后或者被中断。</li>
<li>这个方法不会释放持有的锁。</li>
</ul>
</li>
<li><code>LockSupport.parkUntil(long deadline)</code>:<ul>
<li>参数 deadline 是一个表示时间戳的长整型数值，单位是毫秒。</li>
<li>使当前线程进入超时等待状态，直到指定的时间点后或者被中断。</li>
<li>这个方法不会释放持有的锁。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="死亡（Dead）"><a href="#死亡（Dead）" class="headerlink" title="死亡（Dead）"></a>死亡（Dead）</h4><ul>
<li>当一个线程已经执行完run()&#x2F;call()方法中的所有操作时，该线程就处于死亡状态。</li>
<li>线程抛出一个未捕获的Exception或Error，线程就会死亡。</li>
<li>一旦线程处于死亡状态，线程对象就会被垃圾回收器移除。</li>
</ul>
<h3 id="2-3-状态之间的转换及调用方法："><a href="#2-3-状态之间的转换及调用方法：" class="headerlink" title="2.3.状态之间的转换及调用方法："></a>2.3.状态之间的转换及调用方法：</h3><ul>
<li><strong>New -&gt; Runnable：</strong> 调用start()方法启动线程。</li>
<li><strong>Runnable -&gt; Running：</strong> 线程被操作系统调度并获取CPU时间片。</li>
<li><strong>Running -&gt; Blocked：</strong> 线程等待获取锁或执行阻塞式IO操作。</li>
<li><strong>Running -&gt; Waiting：</strong> 调用wait()、join()、park()等方法，线程进入等待状态。</li>
<li><strong>Running -&gt; Timed_Waiting：</strong> 调用Thread.sleep(long)、wait(timeout)等方法，线程进入超时等待状态。</li>
<li><strong>Blocked -&gt; Runnable：</strong> 获取到锁或IO操作完成，线程重新进入可运行状态。</li>
<li><strong>Waiting -&gt; Runnable：</strong> 其他线程调用notify()、notifyAll()、interrupt()方法，或者等待时间到达，线程重新进入可运行状态。</li>
<li><strong>Timed_Waiting -&gt; Runnable：</strong> 等待时间到达，线程重新进入可运行状态。</li>
<li><strong>Running&#x2F;Blocked&#x2F;Waiting&#x2F;Timed Waiting -&gt; Dead：</strong> 线程执行完run()方法中的所有代码，或者抛出未捕获的异常，线程进入死亡状态。</li>
</ul>
<h3 id="2-4-几个方法的比较"><a href="#2-4-几个方法的比较" class="headerlink" title="2.4.几个方法的比较"></a>2.4.几个方法的比较</h3><ul>
<li><strong>Thread.sleep(long millis)</strong>：一定是当前线程调用此方法，当前线程进入TIMED_WAITING状态，但不释放对象锁，millis后线程自动苏醒进入就绪状态。作用：<strong>给其它线程执行机会的最佳方式</strong>。</li>
<li><strong>Thread.yield()</strong>：一定是当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让CPU再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。<strong>实际中无法保证yield()达到让步目的</strong>，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。该方法与sleep()类似，只是不能由用户指定暂停多长时间。</li>
<li><strong>thread.join()&#x2F;thread.join(long millis)</strong>：当前线程里调用其它线程T的join方法，当前线程进入WAITING&#x2F;TIMED_WAITING状态，<strong>当前线程不会释放已经持有的对象锁</strong>。线程T执行完毕或者millis时间到，当前线程一般情况下进入RUNNABLE状态，也有可能进入BLOCKED状态（因为join是基于wait实现的）。</li>
<li><strong>obj.wait()</strong>：当前线程调用对象的wait()方法，<strong>当前线程释放对象锁</strong>，进入等待队列。依靠notify()&#x2F;notifyAll()唤醒或者wait(long timeout) timeout时间到自动唤醒。</li>
<li><strong>obj.notify()</strong>：唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。</li>
<li><strong>LockSupport.park()&#x2F;LockSupport.parkNanos(long nanos),LockSupport.parkUntil(long deadlines)</strong>：当前线程进入WAITING&#x2F;TIMED_WAITING状态。<strong>对比wait方法,不需要获得锁</strong>就可以让线程进入WAITING&#x2F;TIMED_WAITING状态，需要通过LockSupport.unpark(Thread thread)唤醒。</li>
</ul>
<p><strong>进入等待状态的几个方法比较</strong>：</p>
<ul>
<li>方法比较<ul>
<li>Thread.sleep(long millis)<ul>
<li>释放资源问题：不会释放资源</li>
<li>底层调用：是一个native方法</li>
<li>是否需要声明异常：方法声明要捕获异常</li>
<li>线程状态：TIMED_WAITING</li>
<li>作用范围：任意地方</li>
</ul>
</li>
<li>Object.wait(long millis)<ul>
<li>释放资源问题：会释放资源，被唤醒后需要重新竞争资源</li>
<li>底层调用：超时的wait(long millis)是一个native方法 wait调用的是wait(0)</li>
<li>是否需要声明异常：方法声明有中断异常</li>
<li>线程状态：无参时是Waiting，有参时是TIMED_WAITING</li>
<li>作用范围：是synchronized的 通知机制中的方法</li>
<li>唤醒操作：notify()、notifyAll()，不能在wait()前面执行</li>
</ul>
</li>
<li>LockSupport.park()<ul>
<li>释放资源问题：不会释放资源</li>
<li>底层调用：底层调用的Unsafe下的native的park()方法进入等待状态，park(Thread thread)指定线程进入等待状态</li>
<li>是否需要声明异常：不需要</li>
<li>线程状态：在synchronized中，获取到锁的线程调用该方法进入waiting状态，其他线程都是Bolcked状态<br>  如果是ReentratLock锁，因为是重入锁，所有线程都是waiting状态</li>
<li>作用范围：任意范围</li>
<li>唤醒操作：LockSupport.unpark(Thread thread)可以在LockSupport.park( )之前调用</li>
</ul>
</li>
<li>Condition.await()<ul>
<li>释放资源问题：会释放资源</li>
<li>底层调用：底层使用的是LockSupport.park( )</li>
<li>是否需要声明异常：需要</li>
<li>线程状态：waiting</li>
<li>作用范围：需要在Lock块中执行，用来lock对象的</li>
<li>唤醒操作：signal()、signalAll()，不能在await()前面执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-Thread类"><a href="#3-Thread类" class="headerlink" title="3.Thread类"></a>3.Thread类</h2><h3 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1.基本概念"></a>3.1.基本概念</h3><ul>
<li>Thread类是Java中用于表示线程的类。通过Thread类，可以创建新的线程、启动线程的执行、控制线程的状态和执行等。除了线程对象本身的操作，Thread类还提供了对线程组（ThreadGroup）的支持，以便更好地管理和组织线程。</li>
</ul>
<p><strong>什么是线程组（ThreadGroup）：</strong></p>
<ul>
<li>线程组是线程的集合，它用于对线程进行逻辑上的分组。线程组可以包含其他线程组，形成一棵树状结构。每个线程组可以有一个父线程组，除了顶级线程组外，其他线程组必须有一个明确定义的父线程组。</li>
</ul>
<p><strong>线程组的作用：</strong></p>
<ul>
<li><strong>组织管理</strong>：通过线程可以更好地组织和管理多个线程,便于对线程进行批量操作和控制</li>
<li><strong>权限控制</strong>：线程组可以应用安全策略和权限控制，限制线程组中线程的行为</li>
<li><strong>资源分配</strong>：线程组可以分配资源，例如线程组中的线程可以共享资源，例如文件、数据库连接等</li>
<li><strong>异常处理</strong>：线程组可以统一处理线程中抛出的未捕获异常，提高异常处理的效率和统一性</li>
</ul>
<p><strong>线程组的父子关系：</strong></p>
<ul>
<li><strong>父子关系</strong>：每个线程组可以有一个父线程组，除了顶级线程组外，其他线程组必须有一个明确定义的父线程组。这种关系通过ThreadGroup类来实现，构成了线程组的树形结构</li>
<li><strong>组织结构</strong>：线程组可以包含其他线程组，形成多层次的组织结构，便于对线程进行层次化管理</li>
</ul>
<p><strong>父线程组的作用：</strong></p>
<ul>
<li><strong>创建与销毁子线程组</strong>：父线程组可以创建和销毁子线程组，从而实现对线程组的管理</li>
<li><strong>管理权限</strong>：父线程组可以授予或限制子线程组的权限，例如访问特定的资源或执行特定的操纵</li>
<li><strong>监控和控制</strong>：父线程组可以监控和控制子线程组的状态和行为，例如暂停、恢复或终止子线程组的所有线程</li>
</ul>
<p><strong>子线程组的作用：</strong></p>
<ul>
<li><strong>资源隔离</strong>：子线程组可以限制父线程组的访问权限，确保父线程组无法访问子线程组的资源</li>
<li><strong>继承行为</strong>：子线程组可以继承父线程组的一些属性：例如优先级、守护状态等，这些使得子线程组可以继承父线程组的行为，并根据需要进行调整</li>
</ul>
<h3 id="3-2-Thread的构造方法"><a href="#3-2-Thread的构造方法" class="headerlink" title="3.2.Thread的构造方法"></a>3.2.Thread的构造方法</h3><ul>
<li><code>Thread()</code>：创建一个默认设置的线程对象实例，默认线程名为Thread-0，默认优先级为5，默认状态为NEW。</li>
<li><code>Thread(String name)</code>：创建一个线程对象，该线程对象的线程名为name，默认优先级为5，默认状态为NEW。</li>
<li><code>Thread(Runnable target)</code>：创建一个线程对象，该线程对象通过指定的Runnable对象来执行。</li>
<li><code>Thread(Runnable target, String name)</code>：创建一个线程对象，该线程对象通过指定的Runnable对象来执行，并且指定线程名为name。</li>
<li><code>Thread(ThreadGroup group，String name)</code>：创建一个指定的线程组group，并且指定线程名为name。</li>
<li><code>Thread(ThreadGroup group, Runnable target)</code>：创建一个指定的线程组group，该线程对象通过指定的Runnable对象来执行。</li>
<li><code>Thread(ThreadGroup group, Runnable target, String name)</code>：创建一个指定的线程组group，该线程对象通过指定的Runnable对象来执行，并且指定线程名为name。</li>
<li><code>Thread(ThreadGroup group, Runnable target, String name, long stackSize)</code>：创建一个指定的线程组group，该线程对象通过指定的Runnable对象来执行，并且指定线程名为name，并且指定线程的堆栈大小为stackSize。【如果不想指定堆栈大小，可以传递0，由虚拟机自行决定】</li>
</ul>
<blockquote>
<p><strong>说明</strong>：关于线程组（ThreadGroup），一个线程组代表一组线程。此外，一个线程组还可以包括其他线程组。线程组形成一棵树，其中除了初始线程组之外的每一个线程组都有一个父级。允许线程直接访问有关其自己的线程组的信息，但不能直接访问有关其线程组的父级线程组或其他线程组的信息。</p>
</blockquote>
<h3 id="3-3-Thread的常用方法"><a href="#3-3-Thread的常用方法" class="headerlink" title="3.3.Thread的常用方法"></a>3.3.Thread的常用方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>String getName()</code></td>
<td>返回线程的名称。</td>
</tr>
<tr>
<td><code>void setName(String name)</code></td>
<td>设置线程的名称。</td>
</tr>
<tr>
<td><code>static Thread currentThread()</code></td>
<td>返回当前正在执行的线程对象。</td>
</tr>
<tr>
<td><code>public final void start()</code></td>
<td>启动线程，使其进入就绪状态并开始执行 run () 方法。如果线程已经启动，再次调用 start () 方法会抛出 IllegalThreadStateException 异常。</td>
</tr>
<tr>
<td><code>public final void run()</code></td>
<td>线程的执行体，包含了线程需要执行的任务逻【直接调用 run () 方法，并不创建一个新线程，只是在当前线程中执行 run () 方法的内容】辑。</td>
</tr>
<tr>
<td><code>static void sleep(long millis)</code></td>
<td>使当前线程暂停执行指定的毫秒数。调用 sleep () 方法会使当前线程进入超时等待状态，不会释放持有的锁。如果在 sleep 期间被其他线程中断，则会抛出 InterruptedException 异常，并且清除当前线程的中断状态。</td>
</tr>
<tr>
<td><code>public static boolean interrupt()</code></td>
<td>中断线程。调用该方法会将线程的中断状态设置为true，如果当前线程正在sleep、wait、join等方法中阻塞，则会立即抛出InterruptedException异常并清除中断状态。</td>
</tr>
<tr>
<td><code>public boolean isInterrupt()</code></td>
<td>中断线程。调用该方法会将线程的中断状态设置为true，如果当前线程正在sleep、wait、join等方法中阻塞，则会立即抛出InterruptedException异常但不会清除中断状态。</td>
</tr>
<tr>
<td><code>void setPriority(int newPriority)</code></td>
<td>设置线程的优先级。优先级范围是 1~10，其中 1 为最低优先级，10 为最高优先级，默认优先级为 5。Java 线程优先级的设置只是一个建议，实际的调度由底层操作系统决定，不同操作系统对线程优先级的支持程度不同。</td>
</tr>
<tr>
<td><code>final int getPriority()</code></td>
<td>返回线程的优先级。</td>
</tr>
<tr>
<td><code>final void setDaemon(boolean on)</code></td>
<td>设置线程是否为守护线程。如果将线程设为守护线程，当所有的非守护线程结束时，守护线程会被自动终止。默认情况下，用户线程是非守护线程，而守护线程是为了辅助用户线程的运行而存在的。</td>
</tr>
<tr>
<td><code>public final boolean isAlive()</code></td>
<td>判断线程是否处于活动状态。如果线程已经启动且尚未终止，则返回 true；否则返回 false。</td>
</tr>
<tr>
<td><code>public static void yield()</code></td>
<td>提示线程调度器当前线程愿意放弃当前 CPU 资源。调用 yield () 方法会让出当前线程的 CPU 时间片，使得其他具有相同或更高优先级的线程有机会执行，但是并不能保证一定会立即让出 CPU，实际中使用 yield () 方法的效果可能受到操作系统和 JVM 的调度策略影响。</td>
</tr>
<tr>
<td><code>public static void join()</code></td>
<td>等待调用 join () 方法的线程执行完毕。调用 join () 方法会使当前线程进入等待状态，直到调用 join () 方法的线程执行完毕，当前线程才会继续执行。如果调用 join () 方法的线程被中断，则会抛出 InterruptedException 异常，并清除当前线程的中断状态。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>普及</strong><br>Java中线程采用内核线程模型来实现用户程序中的线程，因此一些常用方法依托于虚拟机原生实现，统称Native方法。<br>Native方法是指在Java中声明但实现是由其他语言（如C、C++）编写的方法。这些方法的实现由本地代码提供，通常是为了与底层系统交互或使用底层系统资源。在Java中，可以使用<code>native</code>关键字声明一个方法为本地方法，然后在另外的本地语言中实现它。Native方法通常用于与操作系统、硬件或其他非Java程序进行交互，或者执行一些Java无法直接完成的底层操作。</p>
</blockquote>
<h4 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h4><ul>
<li>yiedld方法是一个Native方法，由C++底层进行关于操作系统层面的逻辑处理。yield的字面意思是退让。调用该方法会向调度程序提示当前线程愿意放弃其当前对处理器的使用，但调度程序可以随意忽略此提示。【无法保证yield达到让步目的】</li>
<li>yield是一种启发式尝试，使用它可以改善线程之间的相对进展，否则会过度使用CPU。在使用yield方法时通常有以下两种使用场景：<ul>
<li>yield的使用应于详细的分析和基准测试相结合，以确保实际上具有预期的效果，但很少使用这种方法。对于调试或测试目的可能有用，它可能有助于重现由于竞争条件导致的问题错误。</li>
<li>在设计并发控制结构（例如 java.util.concurrent.locks包中的结构）时，它也可能会有所帮助。</li>
</ul>
</li>
</ul>
  <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestYield</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">MyThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;thread-1&quot;</span>);</span><br><span class="line">      <span class="type">MyThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;thread-2&quot;</span>);</span><br><span class="line">      thread1.start();</span><br><span class="line">      thread2.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">          <span class="built_in">super</span>(name);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (i % <span class="number">2</span> ** <span class="number">0</span>) &#123;</span><br><span class="line">                  Thread.<span class="keyword">yield</span>(); <span class="comment">// 实际中无法保证yield()达到让步目的</span></span><br><span class="line">                  System.out.println(getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><ul>
<li>join方法让一个线程加入到另一个线程之前执行，在此线程执行期间，其他线程进入等待状态，当然也可以指定join方法的参数（指定执行等待的超时时间），最多等待几毫秒让该线程终止，若参数为0，意味着永远等待。</li>
<li>此实现使用以this.isAlive为条件的this.wait调用循环，当线程终止，将调用this.notifyAll方法。建议应用程序不要在Thread实例上使用wait、notify或notifyAll方法。如果任何线程中断了当前线程，则会抛出InterruptedException异常并清除当前线程的中断状态。</li>
</ul>
  <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJoin</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">MyThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;thread-1&quot;</span>);</span><br><span class="line">      <span class="type">MyThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;thread-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">      thread1.start();</span><br><span class="line">      thread1.join();<span class="comment">// 阻塞当前线程main，直到thread1执行完</span></span><br><span class="line">      thread2.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">          <span class="built_in">super</span>(name);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">              System.out.println(getName());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h4><ul>
<li>当调用线程的sleep方法时，使当前执行的线程休眠（暂时停止执行）指定的毫秒数，取决于系统计时器和调度程序的精度和准确性。如果任何线程中断了当前线程，会抛出InterruptedException异常并清除当前线程的中断状态。</li>
</ul>
<h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h4><ul>
<li>使用interrupt()方法来中断线程，除非当前线程正在中断自己，否则会调用该线程的checkAccess方法，这个方法可能会抛出SecurityException异常。主要有以下几种场景：<ul>
<li>如果一个线程被Object类的wait、Thread类的join、sleep、yield方法调用时，如果当前线程被中断，那么就会抛出InterruptedException异常。</li>
<li>如果该线程在InterruptibleChannel的IO操作中被中断，则通道关闭，线程的中断状态将被设置，线程抛出java.nio.channels.ClosedByInterruptException异常。</li>
<li>如果该线程在java.nio.channels.Selector的select操作中被中断，则该线程的中断状态将被设置，并且它将立即从选择操作中返回，可能带有非零值，就像调用了选择器的唤醒方法一样。如果前面的条件都不成立，则将设置该线程的中断状态。</li>
</ul>
</li>
</ul>
  <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Native;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInterrupt</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">java.lang.InterruptedException: sleep interrupted</span></span><br><span class="line"><span class="comment">at java.base/java.lang.Thread.sleep0(Native Method)</span></span><br><span class="line"><span class="comment">at java.base/java.lang.Thread.sleep(Thread.java:509)</span></span><br><span class="line"><span class="comment">at TestInterrupt.lambda$main$0(TestInterrupt.java:6)</span></span><br><span class="line"><span class="comment">at java.base/java.lang.Thread.run(Thread.java:1583)*/</span></span><br></pre></td></tr></table></figure></div>

<h3 id="3-4-优先级"><a href="#3-4-优先级" class="headerlink" title="3.4.优先级"></a>3.4.优先级</h3><ul>
<li>Java中创建的线程，每个线程都有一个优先级，具有较高优先级的线程优先于具有较低优先级的线程执行。<br><strong>但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</strong></li>
<li>当在某个线程中运行的代码创建一个新的Thread对象时，新线程的优先级最初设置为等于创建线程的优先级。当然，也可以通过调用新线程的setPriority()方法来改变优先级。</li>
<li>Java线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</li>
<li>Thread类中定义了以下三个默认优先级：<ul>
<li><code>public final static int MIN_PRIORITY = 1;</code></li>
<li><code>public final static int NORM_PRIORITY = 5;</code>【创建线程的默认优先级】</li>
<li><code>public final static int MAX_PRIORITY = 10;</code></li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">        t2.start(); <span class="comment">// 输出：MyThread2 run priority=5【没有设置优先级默认是5】</span></span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        t1.setPriority(<span class="number">6</span>);</span><br><span class="line">        t1.start(); <span class="comment">// 输出: MyThread1 run priority=6</span></span><br><span class="line">                    <span class="comment">//       MyThread2 run priority=6【这里的MyThread2在MyThread1的线程里面创建，没有调用方法默认继承父线程的优先级】</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread1 run priority=&quot;</span>+<span class="built_in">this</span>.getPriority());</span><br><span class="line">        MyThread2 thread2=<span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread2 run priority=&quot;</span>+<span class="built_in">this</span>.getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="4-线程的调度"><a href="#4-线程的调度" class="headerlink" title="4.线程的调度"></a>4.线程的调度</h2><h3 id="4-1-CPU的调度策略"><a href="#4-1-CPU的调度策略" class="headerlink" title="4.1.CPU的调度策略"></a>4.1.CPU的调度策略</h3><p>线程无论基于何种模型创建，都有其调度策略，线程的调度指的是操作系统为线程分配使用权的过程。通常调度方式包含两种：</p>
<ul>
<li><strong>协同式调度(Cooperative Threads Scheduling)：</strong><ul>
<li>使用协同式调度方式的线程调度由其本身来控制，线程在自身工作执行完成后，主动通知系统切换到另一个线程，这种方式实现简单，便于控制。但是过度依赖线程本身来控制调度，如果某个线程执行任务的程序存在问题就会一直阻塞，导致其他线程无法正常执行。</li>
</ul>
</li>
<li><strong>抢占式调度(Preemptive Threads Scheduling)：</strong><ul>
<li>使用抢占式调度方式的多线程系统，线程的调度由系统分配执行时间，线程的切换由系统决定。在这种调度方式下，线程的执行时间可控，不会因为单个线程问题导致应用程序阻塞。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>什么是时间片：</strong><br>时间片（Time Slice）是指操作系统中用于调度进程或线程的一段固定长度的时间。在抢占式调度中，每个进程或线程被分配一个时间片，该时间片决定了它能够连续执行的最大时间。当一个进程或线程的时间片用完后，操作系统会中断其执行，并将CPU资源分配给下一个就绪状态的进程或线程。</p>
<p>时间片的长度通常是固定的，但在某些调度算法中也可以是可变的。时间片的大小会影响到系统的响应时间、吞吐量和公平性。较短的时间片能够提高系统的响应速度，但会增加上下文切换的开销；而较长的时间片能够减少上下文切换的频率，但可能导致某些进程或线程长时间占用CPU资源，影响其他任务的响应速度。</p>
</blockquote>
<h3 id="4-2-Java的调度算法"><a href="#4-2-Java的调度算法" class="headerlink" title="4.2.Java的调度算法"></a>4.2.Java的调度算法</h3><ul>
<li>同优先级线程组成FIFO队列（先来先服务），使用时间片策略。</li>
<li>堆高优先级，使用优先级抢占式策略。</li>
<li>线程优先级等级 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ），一共10档，默认优先级为5（NORM_PRIORITY）。</li>
<li>获取和设置当前线程的优先级<ul>
<li><code>getPriority()</code>：获取当前线程的优先级。</li>
<li><code>setPriority(int p)</code>：设置当前线程的优先级。<blockquote>
<p><strong>说明：</strong> 高优先级的线程要抢占低优先级的线程CPU的执行权。但这只是从概率上来讲，高优先级的线程的执行概率高，但是并不是绝对的。并不意味着只有高优先级的线程执行完成后，低优先级的线程才可以执行。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">        t2.setPriority(<span class="number">7</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        t1.setPriority(<span class="number">6</span>);</span><br><span class="line">        t1.start(); </span><br><span class="line">        <span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">        MyThread2 run priority=7</span></span><br><span class="line"><span class="comment">        MyThread2 run priority=7</span></span><br><span class="line"><span class="comment">        MyThread1 run priority=6</span></span><br><span class="line"><span class="comment">        MyThread1 run priority=6</span></span><br><span class="line"><span class="comment">        MyThread1 run priority=6</span></span><br><span class="line"><span class="comment">        MyThread2 run priority=7</span></span><br><span class="line"><span class="comment">        高优先级的也有可能比低优先级的晚结束*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread1 run priority=&quot;</span>+<span class="built_in">this</span>.getPriority());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread2 run priority=&quot;</span>+<span class="built_in">this</span>.getPriority());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="5-多线程的实现原理和创建"><a href="#5-多线程的实现原理和创建" class="headerlink" title="5.多线程的实现原理和创建"></a>5.多线程的实现原理和创建</h2><h3 id="5-1-多线程的实现原理"><a href="#5-1-多线程的实现原理" class="headerlink" title="5.1.多线程的实现原理"></a>5.1.多线程的实现原理</h3><ul>
<li>Java语言的JVM允许运行多个线程，多线程可以通过Java中的<strong>java.lang.Thread</strong>类来实现。</li>
<li>Thread类的特性<ul>
<li>每一个线程都是通过某个特定的Tread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体。</li>
<li>通过Thread方法的start()方法来启动一个线程，而非直接调用run()方法。【start()底层会调用start0()来创建一个新的线程，调用run()方法，而直接调用 run() 方法只是在当前线程中执行 run() 方法的内容，并不会创建新的线程】</li>
</ul>
</li>
</ul>
<h3 id="5-2-多线程的创建"><a href="#5-2-多线程的创建" class="headerlink" title="5.2.多线程的创建"></a>5.2.多线程的创建</h3><h4 id="5-2-1-继承Thread类-拓展性较差"><a href="#5-2-1-继承Thread类-拓展性较差" class="headerlink" title="5.2.1.继承Thread类[拓展性较差]"></a>5.2.1.继承Thread类[拓展性较差]</h4><ol>
<li>创建一个继承Thread类的子类</li>
<li>重写Thread类的run()方法，将此线程执行的操作声明在run()中</li>
<li>创建Thread类的子类对象</li>
<li>通过此对象调用start()方法来启动一个线程。</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个Thread类的子类对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">// 通过调用此对象的start()启动一个线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="comment">// 注意：已启动过一次的线程无法再次启动【在Java中，一个线程对象只能被启用一次】</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再创建一个线程</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 另一种调用方法，此方法并没有给对象命名【链式编程】</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 线程体，启动线程时会运行run()方法中的代码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">主线程</span></span><br><span class="line"><span class="comment">Thread-1: 0</span></span><br><span class="line"><span class="comment">Thread-1: 1</span></span><br><span class="line"><span class="comment">Thread-2: 0</span></span><br><span class="line"><span class="comment">Thread-2: 1</span></span><br><span class="line"><span class="comment">Thread-0: 0</span></span><br><span class="line"><span class="comment">Thread-0: 1</span></span><br><span class="line"><span class="comment">Thread-0: 2</span></span><br><span class="line"><span class="comment">Thread-1: 2</span></span><br><span class="line"><span class="comment">Thread-2: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<p>创建Thread匿名子类的方式：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousSubClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> ** <span class="number">0</span>) System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="5-2-2-实现Runnable接口-拓展性强"><a href="#5-2-2-实现Runnable接口-拓展性强" class="headerlink" title="5.2.2.实现Runnable接口[拓展性强]"></a>5.2.2.实现Runnable接口[拓展性强]</h4><ol>
<li>创建一个实现了Runnable接口的类</li>
<li>实现类中重写Runnable接口的run()方法，将此线程执行的操作声明在run()中</li>
<li>创建实现类的对象</li>
<li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li>
<li>通过Thread类的对象调用start()方法来启动线程</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">   <span class="comment">// 创建实现类的对象</span></span><br><span class="line">   <span class="type">RunnableThread</span> <span class="variable">runnableThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableThread</span>();</span><br><span class="line">   <span class="comment">// 创建Thread类的对象，并将实现类的对象当作参数传入构造器</span></span><br><span class="line">   <span class="type">Thread</span> <span class="variable">thread01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableThread);</span><br><span class="line">   <span class="comment">// 给该线程命名</span></span><br><span class="line">   thread01.setName(<span class="string">&quot;Thread 01&quot;</span>);</span><br><span class="line">   <span class="comment">// 使用Thread类的对象去调用Thread类中的start()方法：1.启动线程 2.Thread中的run()调用了Runnable中的run()</span></span><br><span class="line">   thread01.start();</span><br><span class="line">   <span class="comment">// 再创建一个线程时，可以直接再new一个Thread类即可，不需要再new实现类</span></span><br><span class="line">   <span class="comment">/*【但这种方式会共享同一个 runnableThread 对象中的状态，包括非 static 修饰的成员变量。</span></span><br><span class="line"><span class="comment">   因为 thread01 和 thread02 实际上都是使用同一个 runnableThread 对象作为参数传递给了 Thread 类的构造器】*/</span></span><br><span class="line">   <span class="type">Thread</span> <span class="variable">thread02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableThread);</span><br><span class="line">   thread02.setName(<span class="string">&quot;Thread 02&quot;</span>);</span><br><span class="line">   thread02.start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//RunnableThread 实现Runnable接口中的run()抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> ** <span class="number">0</span>) System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>继承Thread、实现Runnable的区别</strong></p>
<ul>
<li>Java只允许单继承，但可以实现多个接口。因此<strong>实现接口的方式没有类的单继承性的局限</strong>，用实现Runnable接口的方式来完成多线程更加实用。</li>
<li>实现Runnable接口的方式天然具有共享数据的特性（不需要static修饰）。因为继承Thread的实现方式，需要创建多个子类的对象来进行多线程，如果子类中有变量A，而不使用static修饰变量的话，每一个子类的对象都会有自己独立的变量A，只有static修饰A后，子类的对象才可以共享变量A。而实现Runnable接口的方式，如果只创建一个实现类的对象，并将这个对象传入Thread类，创建多个Thread类的对象来完成多线程，那么这多个Thread类对象实际就是调用一个实现类的对象而已，会共享到这个实现类的对象中的所有变量【需要注意线程安全问题】。<strong>实现接口的方式更适合用来处理多个线程要共享数据&#x2F;该类已有父类的情况。</strong></li>
<li>联系：Thread类中也实现了Runnable接口。</li>
<li>相同点：两者都需要重写run方法。线程的执行逻辑都在run()方法中。</li>
</ul>
</blockquote>
<h4 id="5-2-4-实现Callable接口-可有返回值"><a href="#5-2-4-实现Callable接口-可有返回值" class="headerlink" title="5.2.4.实现Callable接口[可有返回值]"></a>5.2.4.实现Callable接口[可有返回值]</h4><p>与Runnable相比，Callable接口中定义了一个额外的方法call()，该方法可以有返回值。</p>
<ol>
<li>创建实现Callable接口的实现类</li>
<li>重写call()方法，该方法将作为线程执行体，并且有返回值。【支持泛型的返回值、可以抛出异常】</li>
<li>创建实现类的对象【表示多线程要执行的任务】</li>
<li>创建FutureTask类对象，将Callable接口实现类的对象作为构造器参数传递。【管理多线程运行的结果】</li>
<li>创建Thread对象，将FutureTask对象作为Thread对象的构造器参数传递。【表示线程】</li>
<li>可以通过FutureTask对象调用get方法获取多线程运行结果。【获取多线程运行结果】</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">CallableTest</span> <span class="variable">callableTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableTest</span>();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callableTest);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中Call方法的返回值</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(result); <span class="comment">// 输出：45</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallableTest</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="5-2-5-线程池"><a href="#5-2-5-线程池" class="headerlink" title="5.2.5.线程池"></a>5.2.5.线程池</h4><ul>
<li>线程池<ul>
<li>基本概念<ul>
<li>线程池是管理一堆就绪状态线程的池化技术</li>
<li>避免线程的重复创建和销毁带来的性能损耗，对线程统一管理</li>
</ul>
</li>
<li>实现原理<ul>
<li>接受到一个任务时，判断线程池中现有存活的线程，是否有空闲</li>
<li>如果已创建的核心线程都有任务，则将任务放到队列中</li>
<li>如果队列满了，就判断当前线程池的线程数量是否达到最大值，没有的话创建新的线程并执行该任务</li>
<li>如果达到了最大的线程数量，则按照设定的拒绝策略处理该任务</li>
</ul>
</li>
<li>创建方式<ul>
<li><strong>Executors.newFixedThreadPool(int n)</strong>：创建固定大小的线程池</li>
<li><strong>Executors.newCachedThreadPool()</strong>:无穷大的线程池【容量默认为 Integer.MAX_VALUE】</li>
<li><strong>Executors.newSingleThreadExecutor()</strong>：创建单线程的线程池</li>
<li><strong>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,</strong><br><strong>BlockingQueue<Runnable> workQueue，ThreadFactory threadFactory，</strong><br><strong>RejectedExecutionHandler handler)</strong>：创建自定义线程池【7个参数，最常用】</li>
<li><strong>ThreadPoolTaskExecutor (Spring Framework)</strong>：是 Spring 框架提供的用于管理线程池的工具类</li>
</ul>
</li>
<li>自定义线程池的7个参数<ul>
<li>核心线程数：理论上不能被回收的线程数量 【默认为 Integer.MAX_VALUE，不能小于0】</li>
<li>最大线程数：最大能创建的线程数量【大于等于核心线程数】</li>
<li>存活时间数值：表示的是一个线程没有任务执行时最多保持多长时间会终止。【不能小于0】</li>
<li>存活时间单位：参数keepAliveTime的时间单位。【用TimeUnit指定】</li>
<li>阻塞队列：任务量超过核心线程数时，任务会依次进入队列【默认为 LinkedBlockingQueue】<ul>
<li><strong>ArrayBlockingQueue</strong>：数组类有界队列，IFIO（先进先出）【不是一个严格的FIFO队列，多线程下不保证公平性】</li>
<li><strong>LinkedBlockingQueue</strong>：链表类有界队列【默认为interger.max队列】，FIFO（先进先出）</li>
<li><strong>SynchronousQueue</strong>：同步队列，不存储任务</li>
<li><strong>PriorityBlockingQueue</strong>：优先级队列，实现Comparable接口的指定元素排列方式</li>
<li><strong>DelayQueue</strong>：延迟队列，只有在延迟期满时才可以取出元素</li>
<li><strong>LinkdTransferQueue</strong>：链表类无界队列，相比有界链表队列，多了两个方法</li>
<li><strong>LinkedBlockingDeque</strong>：头部尾部都可以添加和移除元素，降低锁竞争</li>
</ul>
</li>
<li>线程工厂：创建线程，去执行提交的任务【默认为<strong>Executors.defaultThreadFactory()</strong>】</li>
<li>拒绝策略<ul>
<li><strong>ThreadPoolExecutor.AbortPolicy</strong>: 丢弃任务并抛出 RejectedExecutionException 异常。【默认策略】</li>
<li><strong>ThreadPoolExecutor.DiscardPolicy</strong>: 丢弃任务，但是不抛出异常。【这是不推荐的做法】</li>
<li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>: 抛弃队列中等待最久的任务[排在最前面]，然后把当前任务加入队列中。</li>
<li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>: 调用任务的 run() 方法绕过线程池直接运行该任务。</li>
</ul>
</li>
</ul>
</li>
<li>提交任务<ul>
<li><strong>execute()</strong>：用于提交不需要返回值的任务</li>
<li><strong>submit()</strong>：用于提交需要返回值的任务</li>
</ul>
</li>
<li>关闭线程<ul>
<li><strong>shutdown()</strong>：关闭线程池，线程池不再接受新任务，但会继续执行任务</li>
<li><strong>shutdownNow()</strong>：关闭线程池，线程池不再接受新任务，并且尝试中断正在执行的任务</li>
<li><strong>isShutdown()</strong>：判断线程池是否关闭</li>
<li><strong>isTerminated()</strong>：判断线程池是否终止</li>
</ul>
</li>
<li>线程池的监控<ul>
<li><strong>ThreadPoolExecutor.getActiveCount()</strong>：获取当前线程池中正在执行的任务数量</li>
<li><strong>ThreadPoolExecutor.getTaskCount()</strong>：获取线程池中任务总数量</li>
<li><strong>ThreadPoolExecutor.getCompletedTaskCount()</strong>：获取线程池中已完成的任务数量</li>
<li><strong>ThreadPoolExecutor.getLargestPoolSize()</strong>：获取线程池中曾经创建过的最大线程数量</li>
</ul>
</li>
<li>合理配置线程池的参数</li>
</ul>
</li>
</ul>
<h5 id="5-2-5-1-线程池的体系结构"><a href="#5-2-5-1-线程池的体系结构" class="headerlink" title="5.2.5.1.线程池的体系结构"></a>5.2.5.1.线程池的体系结构</h5><ul>
<li>出现的原因：经常创建和销毁、使用量特别大的资源、比如并发情况下的线程、对性能影响很大。</li>
<li>设计思路：​ 提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</li>
<li>优点：<ul>
<li>提高相应速度【减少创建和销毁时间】</li>
<li>降低资源消耗【重复利用线程池中的线程，不需要每次都重新创建】</li>
<li>便于线程管理</li>
</ul>
</li>
<li>实现原理<ul>
<li>接受到一个任务时，判断线程池中现有存活的线程，是否有空闲</li>
<li>如果已创建的核心线程都有任务，则将任务放到队列中</li>
<li>如果队列满了，就判断当前线程池的线程数量是否达到最大值，没有的话创建新的线程并执行该任务</li>
<li>如果达到了最大的线程数量，则按照设定的拒绝策略处理该任务<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240510192306.png"
                     
                ></li>
</ul>
</li>
</ul>
<h5 id="5-2-5-2-线程池的创建方式"><a href="#5-2-5-2-线程池的创建方式" class="headerlink" title="5.2.5.2.线程池的创建方式"></a>5.2.5.2.线程池的创建方式</h5><table>
<thead>
<tr>
<th>创建方式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Executors.newFixedThreadPool(int n)</code></td>
<td>创建一个固定大小的线程池，该线程池中的线程数量固定为指定的大小 <code>n</code>，当有任务提交时，如果线程池中的线程都在执行任务，新的任务会在任务队列中等待。</td>
</tr>
<tr>
<td><code>Executors.newCachedThreadPool()</code></td>
<td>创建一个缓存线程池，该线程池中的线程数量会根据任务的数量动态调整，当有任务提交时，如果线程池中有空闲线程，则立即使用；如果没有，则创建新的线程执行任务。空闲线程在一定时间内没有被使用会被回收。</td>
</tr>
<tr>
<td><code>Executors.newSingleThreadExecutor()</code></td>
<td>创建一个单线程的线程池，该线程池中只有一个核心线程，所有任务都在同一个线程中串行执行。适用于需要顺序执行任务的场景，例如事件触发器、定时任务等。</td>
</tr>
<tr>
<td><code>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue，ThreadFactory threadFactory，RejectedExecutionHandler handler)</code></td>
<td>使用 <code>ThreadPoolExecutor</code> 构造函数自定义配置线程池，可以指定核心线程数、最大线程数、线程空闲时间、任务队列等参数。可以根据实际需求灵活配置线程池。</td>
</tr>
<tr>
<td><code>ThreadPoolTaskExecutor (Spring Framework)</code></td>
<td>在 Spring Framework 中使用 <code>ThreadPoolTaskExecutor</code> 类创建线程池，该类是 Spring 框架提供的用于管理线程池的工具类，具有更多的扩展性和配置选项，可以通过 Spring 的配置文件或 Java 代码进行灵活配置。</td>
</tr>
</tbody></table>
<p><strong>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue，ThreadFactory threadFactory，RejectedExecutionHandler handler)的参数解释：</strong></p>
<ol>
<li><p>corePoolSize：核心线程数,表示线程池中始终存活的线程数。【不能小于0】</p>
</li>
<li><p>maximumPoolSize：最大线程数,线程池中允许的最大线程数。【最大数量&gt;&#x3D;核心线程数量】</p>
</li>
<li><p>keepAliveTime：存活时间数值,表示的是一个线程没有任务执行时最多保持多长时间会终止。【不能小于0】</p>
</li>
<li><p>unit：存活时间单位,参数keepAliveTime的时间单位。【用TimeUnit指定】</p>
<ul>
<li><strong>TimeUnit.DAYS</strong>: 天</li>
<li><strong>TimeUnit.HOURS</strong>：小时</li>
<li><strong>TimeUnit.MINUTES</strong>：分钟</li>
<li><strong>TimeUnit.SECONDS</strong>：秒</li>
<li><strong>TimeUnit.MILLISECONDS</strong>：毫秒</li>
<li><strong>TimeUnit.MICROSECONDS</strong>：微秒</li>
<li><strong>TimeUnit.NANOSECONDS</strong>：纳秒</li>
</ul>
</li>
<li><p>workQueue：阻塞队列，用于存放等待执行任务的队列，均为线程安全。【不能为null】</p>
<ul>
<li><strong>ArrayBlockingQueue</strong>：基于数组的有界阻塞队列，按照先进先出（FIFO）的顺序存储元素【不是一个严格的FIFO队列，多线程下不保证公平性】。当队列已满时，尝试插入元素会导致操作阻塞。</li>
<li><strong>LinkedBlockingQueue</strong>：基于链表的无界阻塞队列，按照先进先出（FIFO）的顺序存储元素。由于队列容量没有限制，因此不会导致插入操作阻塞但在队列为空时，尝试取出元素会导致操作阻塞。</li>
<li><strong>SynchronousQueue</strong>：同步队列，不存储元素，每个插入操作必须等待另一个线程的移除操作。这意味着插入操作和移除操作是同步的，如果没有消者线程等待取出元素，插入操作会一直阻塞。</li>
<li><strong>PriorityBlockingQueue</strong>：优先级的无界阻塞队列，元素按照优先级顺序存储，而非先进先出。它使用无锁的堆实现，保证了线程安全性和高效性。</li>
<li><strong>DelayQueue</strong>：基于优先级队列的无界阻塞队列，只有在延迟期满时才能从中提取元素。常用于定时任务调度场景，也是使用无锁的堆实现。</li>
<li><strong>LinkedTransferQueue</strong>：基于链表结构的无界阻塞队列，类似于 SynchronousQueue，但也包含非阻塞的 tryTransfer 方法，用于非阻塞地将元素转移给消费者线程。</li>
<li><strong>LinkedBlockingDeque</strong>：基于链表结构的双向阻塞队列，容量默认为 Integer.MAX_VALUE。它可以在队列的头部和尾部进行插入和移除操作，提供了更灵活的队列操作方式。</li>
</ul>
</li>
<li><p>threadFactory: 线程工厂，主要用来创建线程，<code>Executors.defaultThreadFactory()</code>-&gt;默认正常优先级、非守护线程。也可以自己创建线程工厂。【不能为null】</p>
</li>
<li><p>handler: 拒绝策略，当队列满时，线程池会拒绝新任务。默认使用 AbortPolicy 策略。</p>
<ul>
<li><strong>ThreadPoolExecutor.AbortPolicy</strong>: 丢弃任务并抛出 RejectedExecutionException 异常。【默认策略】</li>
<li><strong>ThreadPoolExecutor.DiscardPolicy</strong>: 丢弃任务，但是不抛出异常。【这是不推荐的做法】</li>
<li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>: 抛弃队列中等待最久的任务[排在最前面]，然后把当前任务加入队列中。</li>
<li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>: 调用任务的 run() 方法绕过线程池直接运行该任务。</li>
</ul>
</li>
</ol>
<h5 id="5-2-5-3-线程池提交任务的方式"><a href="#5-2-5-3-线程池提交任务的方式" class="headerlink" title="5.2.5.3.线程池提交任务的方式"></a>5.2.5.3.线程池提交任务的方式</h5><ul>
<li><strong>execute()</strong>: 用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。excute()方法输入的任务是一个Runnable类的实例</li>
<li><strong>submit()</strong>: 用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法获取到任务的返回值。get()方法会阻塞当前线程直到任务执行完毕。而使用get(long timeout,TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完成。<ul>
<li><code>Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>：接受一个Callable接口的实例，表示要执行的任务，并返回一个Future对象，可以通过对象的get()方法获取执行结果。</li>
<li><code>Future&lt;?&gt; submit(Runnable task)</code>：接受一个Runnable接口的实例，表示要执行的任务，并返回一个Future对象，但对象的get()方法返回值总是为null。</li>
<li><code>Future&lt;T&gt; submit(Runnable task, T result)</code>：与上一种类似，但可以提供一个结果作为参数，表示任务完成时的结果。</li>
</ul>
<blockquote><ul>
<li><strong>submit()方法的使用注意事项</strong>:<ul>
<li><code>submit()</code>方法返回一个<code>Future</code>对象，通过该对象可以获取任务执行的结果，但是要注意<code>Future</code>对象的<code>get()</code>方法会阻塞当前线程，直到任务执行完成并返回结果，这可能会导致当前线程被堵塞。</li>
<li>在多线程环境中，如果在循环中频繁调用<code>get()</code>方法，可能会降低程序的并发性能，甚至引发死锁等问题。因此，在使用<code>submit()</code>方法提交任务时，需要谨慎考虑是否需要等待任务执行完成。</li>
</ul>
</li>
</ul>
</blockquote></li>
</ul>
<h5 id="5-2-5-4-关闭线程池"><a href="#5-2-5-4-关闭线程池" class="headerlink" title="5.2.5.4.关闭线程池"></a>5.2.5.4.关闭线程池</h5><ul>
<li><p>调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池</p>
<ul>
<li><code>shutdown</code>：线程池的状态设置称SHUTDOWN，线程池会拒绝新的任务，关闭没有任务的那些空闲线程，并且等待已提交的任务执行完成。该方法用于需要等待线程都执行完成任务的场景。</li>
<li><code>shutdownNow</code>：线程池的状态设置称STOP，线程池会立即尝试停止所有正在执行的任务，并且不再等待任务执行完毕，正在执行的任务会被中断，未执行的任务会被取消。<blockquote>
<p>关闭原理：它们的原理是遍历线程池中的工作线程，然后逐个调用线程的<code>interrupt</code>方法来中断线程，所以无法响应中断的任务可能永远无法终止运行。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>判断线程池状态：<code>isShutdown()</code>、<code>isTerminated()</code></p>
<ul>
<li><code>isShutdown()</code>：如果调用了上述的两个关闭之一，isShutdown()方法返回值为true</li>
<li><code>isTerminated()</code>：判断线程池是否已经完全终止。当所有任务都已关闭，即线程池关闭完成，isTerminated()方法返回值为true</li>
</ul>
</li>
</ul>
<h5 id="5-2-5-5-线程池的监控"><a href="#5-2-5-5-线程池的监控" class="headerlink" title="5.2.5.5.线程池的监控"></a>5.2.5.5.线程池的监控</h5><ul>
<li>目的：方便在出现问题时，可以根据线程池的使用状态快速定位问题</li>
<li>监控方法：<ul>
<li><code>ThreadPoolExecutor.getActiveCount()</code>：获取当前线程池中正在执行的任务数量</li>
<li><code>ThreadPoolExecutor.getTaskCount()</code>：获取线程池中任务总数量</li>
<li><code>ThreadPoolExecutor.getCompletedTaskCount()</code>：获取线程池中已完成的任务数量</li>
<li><code>ThreadPoolExecutor.getLargestPoolSize()</code>：获取线程池中曾经创建过的最大线程数量</li>
</ul>
</li>
<li>拓展线程池的监控方法：可以通过继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute方法和terminated方法，也可以在任务执行前、执行后和线程关闭前执行一些代码来进行监控。例如：监控任务的平均执行时间、最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。</li>
</ul>
<h5 id="5-2-5-6-如何合理配置线程池的参数"><a href="#5-2-5-6-如何合理配置线程池的参数" class="headerlink" title="5.2.5.6.如何合理配置线程池的参数"></a>5.2.5.6.如何合理配置线程池的参数</h5><ul>
<li>任务的性质<ul>
<li>CPU密集型任务：任务以内存中的计算为主。避免线程上下文切换的成本。一般CPU是N核，就开N+1个线程</li>
<li>IO密集型任务：尽量多开启一些线程并发做IO操作。因为在IO过程中，CPU几乎是闲置的。一般可能是2*CPU核数,当然根据下面的标准公式计算会好一些：<br>$ \text{最大并行数} \times \text{期望CPU利用率} \times \frac{\text{总时间} (\text{CPU计算时间} + \text{等待时间})}{\text{CPU计算时间}} $</li>
</ul>
</li>
<li>任务的优先级【高中低】：优先级不同的任务可以使用优先队列<code>PriorityBlockingQueue</code>来处理。它可以让优先级高的任务先执行。</li>
<li>任务的执行时间【长中短】：根据任务的执行时间、设置核心线程数、最大线程数、队列容量等参数，来确定线程池的配置。【当然，过大的线程池可能会导致系统资源过度占用，需要根据实际情况进行合理配置】</li>
<li>最好使用有界队列：有界队列能增强系统的稳定性和预警能力，可以根据需要设置大一点，比如几千。有一次，我们系统里后台任务线程池的队列和线程池的最大线程数量全满了，不断抛出抛弃任务的异常，通过排查发现是数据库出现了问题</li>
</ul>
<h5 id="5-2-5-7-代码演示"><a href="#5-2-5-7-代码演示" class="headerlink" title="5.2.5.7.代码演示"></a>5.2.5.7.代码演示</h5><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExectorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                <span class="number">6</span>,</span><br><span class="line">                <span class="number">60</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">        );</span><br><span class="line">        <span class="type">runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">runnable</span>();</span><br><span class="line">        threadPoolExecutor.execute(runnable);</span><br><span class="line">        Future&lt;Integer&gt; submit = threadPoolExecutor.submit(<span class="keyword">new</span> <span class="title class_">callable</span>());</span><br><span class="line">        System.out.println(submit.get());</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">runnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">callable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>执行了</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></div>


<h2 id="6-线程的安全问题"><a href="#6-线程的安全问题" class="headerlink" title="6.线程的安全问题"></a>6.线程的安全问题</h2><h3 id="6-1-前置知识"><a href="#6-1-前置知识" class="headerlink" title="6.1.前置知识"></a>6.1.前置知识</h3><p><strong>在认识线程的安全问题之前，我们需要先了解一下多线程的三大特性、JMM（Java Memory Model，即Java内存模型）以及活跃性问题的相关知识</strong></p>
<ul>
<li><strong>线程的三大特性</strong>：<ul>
<li>原子性：<ul>
<li>即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li>
<li>对于复合操作而言，synchronized，Lock可以保证原子性，而volatile关键字不能</li>
</ul>
</li>
<li>可见性：<ul>
<li>当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li>
<li>synchronized、Lock和volatile关键字都能保证可见性</li>
</ul>
</li>
<li>有序性：<ul>
<li>程序代码执行的结果不受JVM指令重排序的影响。</li>
<li>synchronized、Lock和volatile关键字都能保证有序性</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>总结</strong>：<br><strong>synchronized</strong>可以保证原子性、可见性和有序性。（这里的有序性是有限的）<br><strong>volatile关键字</strong>可以保证可见性、有序性，对于单独的volatile变量的读写操作，也能保证原子性。然而，volatile 不能保证复合操作的原子性，比如 volatile int a &#x3D; 0; a++; 这种情况并不是原子的。需要使用 AtomicInteger 等原子类来保证原子性。<br><strong>Lock锁机制</strong>可以同时保证以上三个特性，但需要手动管理锁的获取和释放。因此，在不需要Lock特定功能的情况下，一般推荐使用synchronized。</p>
</blockquote>
<ul>
<li><p><strong>JMM</strong>：</p>
<ul>
<li>关键概念<ul>
<li>共享内存：即主存，所有线程共享，【堆区与方法区】</li>
<li>本地内存（线程）：也称为”工作内存”。JVM给每一个线程都分配了一块内存区域（线程栈：有程序计数器、方法栈等），该块内存是线程独有的。</li>
</ul>
</li>
<li>JMM规定：线程不能直接操作主存，而是只能操作属于自己的那部分内存。如果多个线程间需要进行变量共享，必须经过主存进行同步。<ul>
<li>由于JMM的限制，线程操作变量都需要经过以下几个基本步骤：<br>1.线程从主存中读取变量值到工作内存中<br>2.在工作内存中对变量进行修改操作<br>3.将操作后的结果同步回主存</li>
</ul>
</li>
<li>重排序：为了提高持续执行性能，编译器和CPU会对指令进行重排序。但是在多线程环境下，重排序可能导致线程安全问题，因此必须遵循 happens-before 原则来保证正确的执行顺序。</li>
<li>hapens-before原则：这个原则描述了在多线程环境下，操作执行的先后顺序。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这个原则确保了正确的内存可见性和有序性。</li>
</ul>
</li>
<li><p><strong>活跃性问题</strong>：</p>
<ul>
<li>活跃性问题：活跃性是指某件正确的事情最终会发生，但当某个操作无法继续下去的时候，就会发生活跃性问题。<ul>
<li>死锁：多个线程相互等待对方持有的资源而无法继续执行，导致所有线程都无法完成任务。</li>
<li>活锁：线程不断重复相同的操作，但无法取得进展，因此任务无法完成，尽管线程在运行。</li>
<li>饥饿问题：一个或多个线程由于无法获取所需的资源而无法继续执行，尽管资源可用，但被其他线程占用，导致线程长时间无法完成任务。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-2-基本概念"><a href="#6-2-基本概念" class="headerlink" title="6.2.基本概念"></a>6.2.基本概念</h3><ul>
<li>衡量标准：如果同一个程序在单线程环境下与在多线程下执行的结果一致，就说明线程安全，反之则是线程不安全</li>
<li>所谓的线程安全问题，其本质在于线程对共享变量操作的原子性、可见性、有序性不能同时满足或者存在活跃性问题，因此解决线程安全问题的关键就在于同时满足三大特性并避免活跃性问题出现。解决线程安全问题可能需要采取多种手段，包括使用锁机制、原子类、volatile 关键字、并发集合等，具体的方法取决于具体的场景和需求。</li>
</ul>
<h3 id="6-3-线程的不安全的原因"><a href="#6-3-线程的不安全的原因" class="headerlink" title="6.3.线程的不安全的原因"></a>6.3.线程的不安全的原因</h3><h4 id="6-3-1-原子性"><a href="#6-3-1-原子性" class="headerlink" title="6.3.1.原子性"></a>6.3.1.原子性</h4><blockquote>
<ul>
<li>原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li>
<li>原子操作：它是在单个步骤内执行完毕，不可中断的操作。这意味着原子操作的执行过程是连续的，不会被线程切换、中断或者其他因素打断。原子操作的执行要么全部完成，要么完全不执行，没有中间状态。</li>
</ul>
</blockquote>
<p>看这样一个例子，如下图<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240513204704.png"
                     
                ><br>这最终导致的结果是一张票被售卖了两次，这样就具有很大的风险性。售票的过程被分成三个可分割的步骤执行，不具有原子性。</p>
<blockquote>
<p><strong>注意</strong>：我们在写一行Java代码可能不是原子性的，因为它编译成字节码，或者由JVM把字节码翻译成机器码后就可能不是一行，也就是多条执行操作。</p>
</blockquote>
<p>在并发编程中很多操作都不是原子操作，出个小题目：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 操作1</span></span><br><span class="line">i++;<span class="comment">// 操作2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;<span class="comment">// 操作3</span></span><br><span class="line">i = i + <span class="number">1</span>;<span class="comment">// 操作4</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>操作1：这是原子操作，因为它是一个单一的、不可分割的步骤。</li>
<li>操作2：这不是原子操作，这实际上是一个 “read-modify-write” 操作，它包括了读取 i 的值、修改 i 的值和写回 i 的值。</li>
<li>操作3：这是一个原子操作，因为它是一个单一的、不可分割的步骤。</li>
<li>操作4：这不是原子操作，和 i++ 一样，这也是一个 “read-modify-write” 操作。</li>
</ul>
<p>在单线程环境下上述是个操作都不会出现问题，但在多线程环境下，如果不加锁或者使用原子类的话，可能会出现意料之外的值。我们来测试一下，看看输出结果。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YuanziDeo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">numThreads</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">numIncrementsPerThread</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">      Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[numThreads];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; numThreads; j++) &#123;</span><br><span class="line">          threads[j] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">              increase(numIncrementsPerThread);</span><br><span class="line">          &#125;);</span><br><span class="line">          threads[j].start();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">          thread.join();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Final value of i = &quot;</span> + i);</span><br><span class="line">      System.out.println(<span class="string">&quot;Expected value = &quot;</span> + (numThreads * numIncrementsPerThread));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">(<span class="type">int</span> numIncrementsPerThread)</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; numIncrementsPerThread; k++) &#123;</span><br><span class="line">          i++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>输出如下:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Final value <span class="type">of</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">118667</span></span><br><span class="line"><span class="type">Expected</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">200000</span></span><br></pre></td></tr></table></figure></div>
<p>i 期望的值为 200000，但实际跑出来的是 118667，这证明 i++ 不是一个原子操作，</p>
<blockquote>
<p>i++,i- -操作被分成三步执行：</p>
<ul>
<li>从主存把数据读取到本地内存</li>
<li>对数据进行更新操作</li>
<li>再把更新后的操作写回主存</li>
</ul>
<p>在多线程中，这三个步骤再执行时，线程可以被中断，导致数据更新出现问题，eg：线程1拿了 i &#x3D; 100 ，执行 ++ 操作后，本地内存中i &#x3D; 101，还没来得及写回主存，被线程2抢到CPU执行权，线程2从主存中拿到的 i &#x3D; 100（还是100，还没有被线程1更新），假设后面的流程是线程2执行完了3个步骤后把主存中的i更新为101后，线程1又抢到CPU执行权，完成步骤3，更新完主存中的i还是等于101，这就相当于两次++操作最终i只加了1。</p>
</blockquote>
<h4 id="6-3-2-可见性"><a href="#6-3-2-可见性" class="headerlink" title="6.3.2.可见性"></a>6.3.2.可见性</h4><blockquote>
<p>可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值。</p>
</blockquote>
<p>来看这段代码</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo17</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1：开始执行 &quot;</span> + LocalDateTime.now());</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1：结束执行 &quot;</span> + LocalDateTime.now());</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line"> </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2：修改flag = false &quot;</span> + LocalDateTime.now());</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240514111412.png"
                     
                ><br>可以看到，线程2将flag修改为false，线程1始终未结束执行【线程1中的flag并没有得到更新，始终是true】，这就是内存可见性问题。</p>
<blockquote>
<p>多个线程工作的时候都是<strong>在自己的工作内存</strong>来执行操作的，<strong>线程之间是不可见</strong>的:</p>
<ol>
<li>线程之间的<code>共享变量存在主存中</code></li>
<li>每一个<code>线程</code>都有自己的<code>工作内存</code></li>
<li>线程读取共享变量时，先把变量从主内存拷贝到自己的工作内存（CPU寄存器），再从工作内存读取数据</li>
<li>线程修改共享变量时，先修改工作内存中的变量值，再同步到主内存【并不能及时将新值刷新到主内存中】</li>
</ol>
</blockquote>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240513215241.png"
                      alt="" width="40%" height="auto"
                >

<h4 id="6-3-3-有序性"><a href="#6-3-3-有序性" class="headerlink" title="6.3.3.有序性"></a>6.3.3.有序性</h4><blockquote>
<p><strong>了解重排序</strong>：在计算机系统内部，程序中的指令并非严格按照源代码的顺序执行。当一个CPU核心通过流水线技术处理指令时，若前条指令未完成但不影响后续指令的执行，处理器可能会提前执行下一条或多条指令。同样地，编译器在生成机器代码的过程中也可能出于化目的重新安排源代码的执行顺序。这种现象就被称为指令重排序。（在java内存模型中，允许编译器和处理器对指令进行重排序，重排过程不会影响单线程程序的执行，但是会影响多线程并发执行的正确性）<br>比如有这样三步操作：（1）去前台取U盘 （2）去教室写作业 （3）去前台取快递<br>JVM会对指令优化，也就是重排序，新的顺序为（1）（3）（2），这样来提高效率</p>
<p>虽然重排序提高了CPU利用率和程序执行效率，但它也可能引入了潜在的多线程问题，尤其是在没有正确同步的情况下，可能导致不可预测的行为和数据竞争。为此，Java内存模型（JMM）通过happens-before规则来限制重排序，并确保在正确同步的多线程环境中，各线程能观察到一致且符合预期的内存状态。</p>
</blockquote>
<p>当程序没有进行正确的同步控制时，就可能出现数据竞争问题。数据竞争指的是在一个线程内写入变量的同时，另一个线程读取了同一个变量，且这两个操作之间没有通过任何同步机制来确保执行顺序。这种情况下，程序的行为可能变得不可预测，例如读取到未更新的数据或者状态混乱。<br>来看这段代码</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：数据竞争</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataRaceExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sharedValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">writerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        sharedValue = <span class="number">1</span>; <span class="comment">// 写操作</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">readerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">localCopy</span> <span class="operator">=</span> sharedValue; <span class="comment">// 读操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Reader sees: &quot;</span> + localCopy);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startThreads</span><span class="params">()</span> &#123;</span><br><span class="line">        writerThread.start();</span><br><span class="line">        readerThread.start(); <span class="comment">// 数据竞争，因为没有同步措施</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这个示例中，读者线程可能会在写者线程完成赋值之前就读取sharedValue，从而导致结果不确定。</p>
<blockquote>
<p>有序性：即程序的执行顺序按照代码的先后顺序执行。（在java内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响单线程程序的执行，但是会影响多线程并发执行的正确性）</p>
</blockquote>
<h4 id="6-3-4-活跃性问题"><a href="#6-3-4-活跃性问题" class="headerlink" title="6.3.4.活跃性问题"></a>6.3.4.活跃性问题</h4><p>上面讲到的问题都可以采取加锁的方式来解决，但是如果加锁不当也容易引入其他问题，比如『死锁』。<br>在讲『死锁』之前，我们需要先引入另外一个概念：<code>活跃性问题</code>。</p>
<blockquote>
<p>活跃性是指某件正确的事情最终会发生，但当某个操作无法继续下去的时候，就会发生活跃性问题。</p>
</blockquote>
<p>活跃性问题一般有这样几类：<code>死锁</code>，<code>活锁</code>，<code>饥饿问题</code>。</p>
<ul>
<li><strong>死锁</strong>：<br>死锁是指多个线程因为环形等待锁的关系而永远地阻塞下去。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240513225747.png"
                     
                ></li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockExample</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1 acquired lock1&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1 waiting for lock2&quot;</span>);</span><br><span class="line">              <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;Thread 1 acquired lock2&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 2 acquired lock2&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 2 waiting for lock1&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 2 acquired lock1&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>输出结果：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Thread <span class="number">1</span> acquired lock1</span><br><span class="line">Thread <span class="number">2</span> acquired lock2</span><br><span class="line">Thread <span class="number">2</span> waiting <span class="keyword">for</span> lock1</span><br><span class="line">Thread <span class="number">1</span> waiting <span class="keyword">for</span> lock2</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>活锁</strong>：<br>死锁是两个线程都在等待对方释放锁而导致阻塞。而<code>活锁</code>的意思是线程没有阻塞，还活着呢。当多个线程都在运行并且修改各自的状态，而其他线程又依赖这个状态，就导致任何一个线程都无法继续执行，只能重复着自身的动作，于是就发生了活锁。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240513230139.png"
                     
                ><br>举一个生活中的例子，大家平时在走路的时候，迎面走来一个人，两个人互相让路，但是又同时走到了一个方向，如果一直这样重复着避让，这俩人就发生了活锁，学到了吧，嘿嘿。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LivelockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">shouldTakeStep1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">shouldTakeStep2</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shouldTakeStep1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 1 takes step 1&quot;</span>);</span><br><span class="line">                    shouldTakeStep1 = <span class="literal">false</span>;</span><br><span class="line">                    shouldTakeStep2 = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 1 waits for Thread 2 to take step 2&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shouldTakeStep2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 2 takes step 2&quot;</span>);</span><br><span class="line">                    shouldTakeStep2 = <span class="literal">false</span>;</span><br><span class="line">                    shouldTakeStep1 = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 2 waits for Thread 1 to take step 1&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>输出结果：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Thread <span class="number">1</span> takes step <span class="number">1</span></span><br><span class="line">Thread <span class="number">1</span> waits <span class="keyword">for</span> Thread <span class="number">2</span> to take step <span class="number">2</span></span><br><span class="line">Thread <span class="number">2</span> takes step <span class="number">2</span></span><br><span class="line">Thread <span class="number">2</span> waits <span class="keyword">for</span> Thread <span class="number">1</span> to take step <span class="number">1</span></span><br><span class="line">Thread <span class="number">1</span> takes step <span class="number">1</span></span><br><span class="line">Thread <span class="number">1</span> waits <span class="keyword">for</span> Thread <span class="number">2</span> to take step <span class="number">2</span></span><br><span class="line">Thread <span class="number">2</span> waits <span class="keyword">for</span> Thread <span class="number">1</span> to take step <span class="number">1</span></span><br><span class="line">Thread <span class="number">2</span> takes step <span class="number">2</span></span><br><span class="line">Thread <span class="number">2</span> waits <span class="keyword">for</span> Thread <span class="number">1</span> to take step <span class="number">1</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>饥饿</strong>：<br>如果一个线程无其他异常却迟迟不能继续运行，那基本上是处于饥饿状态了<br>常见的有几种场景<ul>
<li>高优先级的线程一直在运行消耗CPU，所有低优先级线程一直处于等待</li>
<li>一些线程被永久堵塞在一个等待进入同步块的状态，而其他线程总是能在它之前持续地对该同步块进行访问</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StarvationExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (StarvationExample.class) &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟线程持续运行</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">highPriorityThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        highPriorityThread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">lowPriorityThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        lowPriorityThread.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line"></span><br><span class="line">        highPriorityThread.start();</span><br><span class="line">        lowPriorityThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="7-线程的同步"><a href="#7-线程的同步" class="headerlink" title="7.线程的同步"></a>7.线程的同步</h2><blockquote>
<p>上面我们提到了多线程造成的不安全问题，那么我们应该怎么解决呢？<br> 解决多线程安全问题的关键就在于实现多线程的同步，即制某个资源在同一时刻只能被一个线程访问。</p>
</blockquote>
<h3 id="7-1-volatile关键字"><a href="#7-1-volatile关键字" class="headerlink" title="7.1.volatile关键字"></a>7.1.volatile关键字</h3><blockquote>
<p><code>volatile</code>是用来<code>修饰变量</code>的，它的作用是<code>保证可见性、有序性</code><br><strong>注意</strong>：<strong>不能保证原子性</strong>，对于n++,n--来说，用volatile修饰n也是线程不安全的</p>
</blockquote>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul>
<li>代码在写入volatile修饰的变量的时候，改变线程工作内存中volatile变量副本的值，改变后的值会立即写回到主存，并且会立即使其他线程的工作内存中对应的缓存无效。这确保了其他线程在下次读取该变量时能够看到最新的值。</li>
<li>代码在读取volatile修饰的变量的时候，会从主存中读取volatile变量的最新值到线程工作内存中，再从工作内存中读取volatile变量的副本</li>
</ul>
<h4 id="volatile解决可见性问题"><a href="#volatile解决可见性问题" class="headerlink" title="volatile解决可见性问题"></a>volatile解决可见性问题</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo17</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1：开始执行 &quot;</span> + LocalDateTime.now());</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1：结束执行 &quot;</span> + LocalDateTime.now());</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line"> </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2：修改flag = false &quot;</span> + LocalDateTime.now());</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240514113308.png"
                     
                ><br>给变量flag加上volatile修饰后，线程1能够接收到flag的改变，从而结束了执行，解决了内存的可见性问题。</p>
<h4 id="volatile关键字的缺点"><a href="#volatile关键字的缺点" class="headerlink" title="volatile关键字的缺点"></a>volatile关键字的缺点</h4><p>volatile关键字虽然可以解决内存的可见性和指令重排序的问题，但解决不了原子性问题，对于 ++ 和 -- 操作的线程非安全问题依然解决不了，比如以下代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemoVolatile</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">        <span class="comment">// 变量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 循环次数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> MAX_COUNT;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Counter</span><span class="params">(<span class="type">int</span> MAX_COUNT)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.MAX_COUNT = MAX_COUNT;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// ++ 方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_COUNT; i++) &#123;</span><br><span class="line">                number++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// -- 方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">desc</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_COUNT; i++) &#123;</span><br><span class="line">                number--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">100000</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(counter::increase);</span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(counter::desc);</span><br><span class="line">        thread2.start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 等待线程执行完成</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;最终结果：&quot;</span> + counter.getNumber()); <span class="comment">// 不一定等于0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="7-2-synchronized锁"><a href="#7-2-synchronized锁" class="headerlink" title="7.2.synchronized锁"></a>7.2.synchronized锁</h3><p>我们知道，在Java中，<code>每一个对象都有一把唯一的锁</code>，这也是synchronized实现线程同步的基础。【唯一的锁也就是对象的监视器锁，也称为内部锁或互斥锁】</p>
<blockquote>
<p><code>synchronized</code>是<code>基于对象头加锁</code>的，它的作用是<code>保证了原子性、可见性、有序性</code>（这里的有序性是有限的）<br>特别注意：<strong>不是对代码加锁，所说的加锁操作就是给这个对象的对象头里设置了一个标志位</strong>，一个对象在同一时间只能有一个线程获取到该对象的锁。如果锁已经被其他线程获取，那么当前线程就会进入到阻塞状态，直到它获取到了锁。</p>
</blockquote>
<h4 id="同步原理"><a href="#同步原理" class="headerlink" title="同步原理"></a>同步原理</h4><ul>
<li>当线程进入一个使用synchronized关键词修饰的方法或代码块时，它会尝试获取对象的锁。</li>
<li>如果对象的锁被其他线程持有，那么当前线程就会被阻塞，直到它获取到了锁。</li>
<li>当线程执行完了synchronized方法或代码块后，会释放对象锁，这样其他等待获取该锁的线程就有机会执行了。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><p><strong>互斥性</strong></p>
<blockquote>
<p>synchronized  会起到互斥效果, 某个线程执行到某个对象的 synchronized 方法或代码块时, 其他线程如果也执行到同一个对象的  synchronized 方法或代码块，就会<strong>阻塞等待</strong><br>进入synchronized方法或代码块，相当于 加锁<br>退出synchronized方法或代码块，相当于 解锁</p>
</blockquote>
<p>看下图理解加锁过程：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240514141516.jpeg"
                     
                ></p>
<blockquote>
<p><strong>阻塞等待：</strong><br>针对每一把锁（监视器锁），JVM内部都维护了一个等待队列，当这个锁被某个线程占有的时候，其他线程尝试获取这把锁，但由于锁已经被占用，这些线程就会进入阻塞状态，加入到该锁的等待队列中。直到持有锁的线程释放锁，JVM将从等待队列中唤醒一个或多个线 程，使其尝试再次获取锁。如果这些线程成功获取锁，它们将继续执行；否则，将继续阻塞等待。</p>
</blockquote>
</li>
<li><p><strong>刷新主存</strong></p>
<blockquote>
<p><strong>synchronized的工作过程：</strong><br>获得互斥锁<br>从主存拷贝最新的变量到工作内存<br>对变量执行操作<br>将修改后的共享变量的值刷新到主存<br>释放互斥锁</p>
</blockquote>
</li>
<li><p><strong>可重入性</strong></p>
<blockquote>
<p>synchronized是可重入锁<br>同一个线程可以多次获取同一个对象的锁，即允许线程对同一个锁进行嵌套调用【避免了死锁的发生】</p>
</blockquote>
<p>可重入锁内部会记录当前的锁被哪个线程占用，同时也会记录一个”加锁次数”，对于第一次加锁，记录当前获取锁的线程并且次数加一。但是后续该线程继续申请加锁的时候，并不会直接加锁，而是将记录的”加锁次数加1”，后续释放锁的时候，次数减1，直到次数为0才是真正的释放锁。</p>
<p>可重入锁的意义就是降低程序员负担（使用成本来提高开发效率），代价就是程序的开销增大（维护锁属于哪个线程，并且加减计数，降低了运行效率）</p>
</li>
<li><p><strong>内置了锁定和释放机制</strong></p>
<blockquote>
<p>synchronized关键字内置了锁定和释放机制，使用起来比较方便，不需要手动进行锁的管理</p>
</blockquote>
</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>性能问题</strong><br>虽然 synchronized 关键字能够保证线程安全，但是它的性能相对较差，因为在获取锁和释放锁的过程中会涉及到一定的系统开销。<br>如果是多个线程需要同时进行读操作，一个线程读操作时其他线程只有等待</li>
<li><strong>方法较少</strong><br>无法知道是否成功获取到锁，无法知道锁是否被其他线程持有。</li>
</ol>
<h4 id="synchronized实现线程同步的形式"><a href="#synchronized实现线程同步的形式" class="headerlink" title="synchronized实现线程同步的形式"></a>synchronized实现线程同步的形式</h4><table>
<thead>
<tr>
<th align="center">形式</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>实例同步方法</code></td>
<td align="center">锁的是<code>当前实例对象</code>，执行同步代码前必须获得<code>当前实例的锁</code>。这意味着，<strong>同一个类的不同实例对象之间不会互斥</strong>。</td>
</tr>
<tr>
<td align="center"><code>静态同步方法</code></td>
<td align="center">锁的是<code>当前类的Class对象</code>，执行同步代码前必须获得<code>当前类的Class对象的锁</code>。这意味着，<strong>无论有多少实例对象，它们共享同一把锁</strong>。</td>
</tr>
<tr>
<td align="center"><code>同步代码块</code></td>
<td align="center">锁的是<code>括号里的对象</code>，对给定对象加锁，执行同步代码块必须<code>获得给定对象的锁</code>。这提供了<strong>更灵活的锁定范围，允许更细粒度的控制</strong>。</td>
</tr>
</tbody></table>
<ul>
<li><strong>实例同步方法：</strong><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">  ...                                              <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">  ...                                     &lt;**&gt;              ... </span><br><span class="line">  &#125;                                                   &#125;</span><br><span class="line">&#125;                                                &#125;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>静态同步方法：</strong><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;         <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">  ...                                                     <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">  ...                                            &lt;**&gt;                  ... </span><br><span class="line">  &#125;                                                         &#125;</span><br><span class="line">&#125;                                                        &#125;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>同步代码块：</strong><br>需要显示指定对哪个对象加锁（Java中任意对象都可以作为锁对象） <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>为什么要使用同步代码块？</strong></p>
<ul>
<li>在某些情况下，我们编写的方法体可能比较<strong>庞大</strong>，同时又有一些<strong>耗时的操作</strong>，如果对整个方法体进行同步，效率会大大降低。所以我们希望能够<strong>只同步必要的代码块</strong>，对于一些<strong>不需要同步的或者耗时较长的操作</strong>，放到同步代码块之外，比如：</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Synchronized</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">running</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是耗时操作。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//需要同步的代码块写下面</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            running();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Synchronized</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Synchronized</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(sync).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(sync).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">这是耗时操作。</span><br><span class="line">这是耗时操作。</span><br><span class="line">这是耗时操作。</span><br><span class="line"><span class="number">1</span></span><br><span class="line">这是耗时操作。</span><br><span class="line">这是耗时操作。</span><br><span class="line">这是耗时操作。</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></div>
<p>结果表明，需要同步的代码块确实实现了<strong>同步</strong>。</p>
<h4 id="synchronized解决原子性问题"><a href="#synchronized解决原子性问题" class="headerlink" title="synchronized解决原子性问题"></a>synchronized解决原子性问题</h4><p>回到线程安全的原子性问题，为避免以上的问题发生，我们给 increase() 方法加上synchronized 关键字，使得<strong>两个线程无法同时调用increase() 方法</strong>，以保证++操作的三个步骤中的任何一步都不会被另外一个线程打断，这样，”i++”操作就永远不会因为线程切换而出错。<br>代码如下</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YuanziDeo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numThreads</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numIncrementsPerThread</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[numThreads];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; numThreads; j++) &#123;</span><br><span class="line">            threads[j] = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                increase(numIncrementsPerThread);</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[j].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final value of i = &quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;Expected value = &quot;</span> + (numThreads * numIncrementsPerThread));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">(<span class="type">int</span> numIncrementsPerThread)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; numIncrementsPerThread; k++) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Final value <span class="type">of</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">200000</span></span><br><span class="line"><span class="type">Expected</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">200000</span></span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>这里用到的是<strong>静态同步方法</strong>，线程1和线程2进入synchronized方法时，使用的是同一把锁。</p>
</blockquote>
<h4 id="synchronized需要注意的问题"><a href="#synchronized需要注意的问题" class="headerlink" title="synchronized需要注意的问题"></a>synchronized需要注意的问题</h4><p>请看以下代码</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Synchronized</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            running();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//用同一个类创建两个对象</span></span><br><span class="line">        <span class="type">Synchronized</span> <span class="variable">sync1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Synchronized</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(sync1).start();</span><br><span class="line">        <span class="type">Synchronized</span> <span class="variable">sync2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Synchronized</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(sync2).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">running</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入了synchronized修饰的实例同步方法 &quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 准备离开synchronized修饰的实例同步方法 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">0</span> 进入了<span class="keyword">synchronized</span>修饰的实例同步方法 </span><br><span class="line">Thread-<span class="number">1</span> 进入了<span class="keyword">synchronized</span>修饰的实例同步方法 </span><br><span class="line">Thread-<span class="number">1</span> 准备离开<span class="keyword">synchronized</span>修饰的实例同步方法 </span><br><span class="line">Thread-<span class="number">0</span> 准备离开<span class="keyword">synchronized</span>修饰的实例同步方法 </span><br></pre></td></tr></table></figure></div>
<p><strong>为什么在Thread-0还没有离开synchronized修饰的实例同步方法时，Thread-1就进入synchronized修饰的实例同步方法呢？</strong></p>
<blockquote>
<p>这是因为synchronized修饰的<strong>实例同步方法</strong>锁的对象是<strong>this对象</strong>，而使用两个对象去访问，<strong>不是同一把锁</strong>。导致没有起到线程同步的效果。<br>如果我们用同一个对象访问：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只创建一个对象</span></span><br><span class="line"><span class="type">Synchronized</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Synchronized</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(sync).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(sync).start();</span><br></pre></td></tr></table></figure></div>
<p>结果就是<strong>同步</strong>的<br><strong>注：为了确保所有线程都能看到共享数据的最新值，因此所有执行读写操作的线程都必须在同一个锁上同步。</strong></p>
</blockquote>
<h3 id="7-3-Lock锁"><a href="#7-3-Lock锁" class="headerlink" title="7.3.Lock锁"></a>7.3.Lock锁</h3><p>前面使用的synchronized关键字可以实现多线程间的同步问题，其实，在JDK1.5后新增的<code>ReentrantLock</code>类同样可以实现这个功能，而且<strong>在用法上比synchronized关键字更灵活</strong>。</p>
<blockquote>
<p>ReentrantLock (重入锁)，是实现Lock接口的一个类。<br>ReentrantLock 支持两种锁：<strong>公平锁</strong>和<strong>非公平锁</strong>。【默认情况下（不传参），ReentrantLock 创建的是非公平锁】</p>
</blockquote>
<h4 id="ReentrantLock的源码分析"><a href="#ReentrantLock的源码分析" class="headerlink" title="ReentrantLock的源码分析"></a>ReentrantLock的源码分析</h4><h5 id="支持重入性"><a href="#支持重入性" class="headerlink" title="支持重入性"></a>支持重入性</h5><blockquote>
<p>要想支持重入性，就要解决两个问题：</p>
<ol>
<li>当一个线程尝试获取已经被它自己持有的锁时，应当允许它成功获取锁。这意味着锁的获取操作必须能够识别当前持有锁的线程，并允许该线程再次获取锁。</li>
<li>由于锁可能会被一个线程多次获取，因此锁的释放操作必须进行计数。只有当一个线程释放锁的次数与它获取锁的次数相等时，锁才算是真正被释放，从而允许其他线程获取该锁。</li>
</ol>
</blockquote>
<p>针对第一个问题，我们来看看 ReentrantLock 是怎样实现的，以非公平锁为例，判断当前线程能否获得锁为例，核心方法为内部类 Sync 的 nonfairTryAcquire 方法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">//1. 如果该锁未被任何线程占有，该锁能被当前线程获取</span></span><br><span class="line">	<span class="keyword">if</span> (c ** <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//2.若被占有，检查占有线程是否是当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current ** getExclusiveOwnerThread()) &#123;</span><br><span class="line">		<span class="comment">// 3. 再次获取，计数加一</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这段代码的逻辑很简单，具体请看注释。为了支持重入性，在第二步增加了处理逻辑，如果该锁已经被线程占有了，会继续检查占有线程是否为当前线程，如果是的话，同步状态加 1 返回 true，表示可以再次获取成功。每次重新获取都会对同步状态进行加一的操作，那么释放的时候处理思路是怎样的呢？（依然还是以非公平锁为例）核心方法为 tryRelease：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">	<span class="comment">//1. 同步状态减1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c ** <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//2. 只有当同步状态为0时，锁成功被释放，返回true</span></span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 3. 锁未被完全释放，返回false</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>代码的逻辑请看注释，需要注意的是，重入锁的释放必须得等到同步状态为 0 时锁才算成功释放，否则锁仍未释放。如果锁被获取了 n 次，释放了 n-1 次，该锁未完全释放返回 false，只有被释放 n 次才算成功释放，返回 true。到现在我们可以理清 ReentrantLock 重入性的实现了，也就是理解了同步语义的第一条。</p>
<h5 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h5><blockquote>
<p>ReentrantLock 支持两种锁：<strong>公平锁</strong>和<strong>非公平锁</strong>。</p>
<ul>
<li><strong>公平锁</strong>：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</li>
<li><strong>非公平锁</strong>：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</li>
</ul>
</blockquote>
<ul>
<li>ReentrantLock 的构造方法<strong>无参</strong>时是构造非公平锁，源码为：<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>ReentrantLock 的构造方法<strong>有参</strong>(boolean fair)时，true为公平锁，false为非公平锁，源码为：<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">  sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>在非公平锁获取时（nonfairTryAcquire 方法），只是简单的获取了一下当前状态然后做了一些逻辑处理，并没有考虑到当前同步队列中线程等待的情况。</p>
<p>我们来看看公平锁的处理逻辑是怎样的，核心方法为：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c ** <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current ** getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这段代码的逻辑与 nonfairTryAcquire 基本上一致，唯一的不同在于增加了 hasQueuedPredecessors 的逻辑判断，从方法名就可以知道该方法用来判断当前节点在同步队列中是否有前驱节点的，如果有前驱节点，说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败。如果当前节点没有前驱节点，才有做后面逻辑判断的必要性。</p>
<p><strong>公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁</strong></p>
<h4 id="ReentrantLock-的使用"><a href="#ReentrantLock-的使用" class="headerlink" title="ReentrantLock 的使用"></a>ReentrantLock 的使用</h4><p><strong>ReentrantLock基本用法：</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建锁对象</span></span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="comment">// 2.加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务代码</span></span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 3.释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p><strong>注意事项：</strong><br>在使用ReentrantLock时，必须手动加锁，手动释放锁。</p>
<ul>
<li>锁必须在try代码块开始之前获取，或者在try代码块的首行【加锁之前不能有异常抛出】。否则会导致以下两个问题：<ul>
<li>如果锁在try代码块里面，因为try代码中的异常导致加锁失败，还会执行finally释放锁的操作，进而引发 IllegalMonitorStateException 异常。</li>
<li>unlock 异常会覆盖 try 里面的业务异常，增加排查错误的难度。</li>
</ul>
</li>
<li>ReentrantLock 的锁必须在finally 中手动释放。【这确保了无论 try 块内的代码是否抛出异常，锁都会被释放，防止死锁】</li>
</ul>
</blockquote>
<p>错误❎示例：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxxLock</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 如果在此抛出异常，会直接执行 finally 块的代码，导致 lock.lock() 没有被执行</span></span><br><span class="line">    doSomething();</span><br><span class="line">    <span class="comment">// 不管锁是否成功，finally 块都会执行</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    doOthers();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<p>正确✅示例：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxxLock</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">    doOthers();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="ReentrantLock解决原子性问题"><a href="#ReentrantLock解决原子性问题" class="headerlink" title="ReentrantLock解决原子性问题"></a>ReentrantLock解决原子性问题</h4><p>ReentrantLock 的使用方式与 synchronized 关键字类似，都是通过加锁和释放锁来实现同步的。我们来看看 ReentrantLock 的使用方式，以非公平锁为例：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">20000</span></span><br></pre></td></tr></table></figure></div>
<p>可以看到，两个线程对 count 变量进行了 20000 次累加操作，说明 ReentrantLock 是支持原子性的。我们再来看看公平锁的使用方式，只需要将 ReentrantLock 的构造方法改为公平锁即可：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">20000</span></span><br></pre></td></tr></table></figure></div>
<p>可以看到，公平锁的运行结果与非公平锁的运行结果一致，这是因为公平锁的实现方式与非公平锁的实现方式基本一致，只是在获取锁时增加了判断当前节点是否有前驱节点的逻辑判断。</p>
<h3 id="7-4-ReentrantLock-与-synchronized-的区别"><a href="#7-4-ReentrantLock-与-synchronized-的区别" class="headerlink" title="7.4.ReentrantLock 与 synchronized 的区别"></a>7.4.ReentrantLock 与 synchronized 的区别</h3><ol>
<li><p><strong>类 vs 关键字</strong>：</p>
<ul>
<li>ReentrantLock 是一个类，它提供了更多的灵活性和功能，如支持公平锁和非公平锁、可中断的获取锁、超时获取锁等。而 synchronized 是 Java 中的关键字，用于实现同步，其使用简单，但功能相对受限。</li>
</ul>
</li>
<li><p><strong>多路选择通知 vs 单路通知</strong>：</p>
<ul>
<li>ReentrantLock 可以与多个 Condition 对象一起使用，实现了多路选择通知，使得在某些情况下更灵活。而 synchronized 关键字只能通过 wait 和 notify&#x2F;notifyAll 方法唤醒一个线程或者全部线程，这是一种单路通知。</li>
</ul>
</li>
<li><p><strong>手动释放锁 vs 自动释放锁</strong>：</p>
<ul>
<li>在使用 ReentrantLock 时，需要手动调用 <code>unlock()</code> 方法来释放锁，通常在 <code>finally</code> 块中进行，以确保在发生异常时锁能够被正确释放。而 synchronized 关键字在同步块执行完毕后会自动释放锁，无需手动操作。</li>
</ul>
</li>
<li><p><strong>性能</strong>：</p>
<ul>
<li>在高并发的情况下，ReentrantLock 通常提供了更好的性能，特别是在竞争激烈的场景下。因为 ReentrantLock 具有更细粒度的控制能力，可以避免某些情况下的锁竞争和线程饥饿现象。但是，随着 JDK 版本的升级，synchronized 的性能已经得到了很大的改进，在某些情况下，性能差距已经不太明显。</li>
</ul>
</li>
</ol>
<p>总的来说，ReentrantLock 提供了更多的功能和灵活性，但也需要更多的注意和管理。而 synchronized 关键字虽然使用简单，但功能相对受限。在选择使用时，需要根据具体的需求和场景进行权衡和选择。</p>
<h3 id="7-5-原子类"><a href="#7-5-原子类" class="headerlink" title="7.5.原子类"></a>7.5.原子类</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>在Java的<code>java.util.concurrent</code>包中，除了提供底层锁，并发同步等工具类之外，还提供了一组原子操作类，大多以<code>Atomic</code>开头，它们位于<code>java.until.concurrent.atomic</code>包中。</p>
<blockquote>
<p>所谓原子操作类，就是这个操作要么全部执行成功，要么全部执行失败【<code>保证原子性</code>】，是保证并发编程安全的重要一环。<br>相比通过<code>synchronized</code>和<code>Lock</code>等方式实现的线程安全同步操作，原子类的实现机制则安全不同。它采用的是<strong>通过无锁（lock-free）的方式来实现线程安全访问，底层原理主要是基于<code>CAS</code>操作来实现</strong>。</p>
</blockquote>
<p>某些业务场景下，通过原子类来操作，即可实现线程安全的要求，又可以实现高效的并发性能，同时让编程方面更加简单。</p>
<h4 id="常用原子操作类"><a href="#常用原子操作类" class="headerlink" title="常用原子操作类"></a>常用原子操作类</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/lusy37/Pictures@master/20240515192026.jpeg"
                      alt="" width="100%" height="auto"
                >
虽然原子操作类很多，但是大体的用法基本类似，只是针对不同的数据类型进行了单独适配，这些原子类都可以保证多线程下数据的安全性，使用起来也比较简单。

<h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><p>基本类型的原子类，也是最常用的原子操作类，分为以下三种基础类型：</p>
<ul>
<li><code>AtomicBoolean</code>：布尔类型的原子操作类</li>
<li><code>AtomicInteger</code>：整数类型的原子操作类</li>
<li><code>AtomicLong</code>：长整数类型的原子操作类</li>
</ul>
<p>以<code>AtomicInteger</code>为例，其基本用法如下：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>int get()</code></td>
<td align="center">获取当前值</td>
</tr>
<tr>
<td align="center"><code>void set(int newValue)</code></td>
<td align="center">设置当前值为newValue</td>
</tr>
<tr>
<td align="center"><code>int getAndIncrement()</code></td>
<td align="center">获取当前值，并自增1（先获取再自增）</td>
</tr>
<tr>
<td align="center"><code>int getAndDecrement()</code></td>
<td align="center">获取当前值，并自减1（先获取再自减）</td>
</tr>
<tr>
<td align="center"><code>int incrementAndGet()</code></td>
<td align="center">自增1，并获取当前值（先自增再获取）</td>
</tr>
<tr>
<td align="center"><code>int decrementAndGet()</code></td>
<td align="center">自减1，并获取当前值（先自减再获取）</td>
</tr>
<tr>
<td align="center"><code>int getAndAdd(int delta)</code></td>
<td align="center">获取当前值，并增加delta（先获取再增加）</td>
</tr>
<tr>
<td align="center"><code>int addAndGet(int delta)</code></td>
<td align="center">增加delta，并获取当前值（先增加再获取）</td>
</tr>
<tr>
<td align="center"><code>int getAndSet(int newValue)</code></td>
<td align="center">获取当前值，并设置当前值为newValue</td>
</tr>
<tr>
<td align="center"><code>boolean compareAndSet(int expect, int update)</code></td>
<td align="center">如果当前值等于expect，则设置当前值为update，并返回true，否则返回false。 直接使用CAS方法【核心方法】</td>
</tr>
</tbody></table>
<p>代码示例：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">      <span class="comment">// 先获取值，再自增，默认初始值为0</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> atomicInteger.getAndIncrement();</span><br><span class="line">      System.out.println(<span class="string">&quot;v1：&quot;</span>+v1);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取自增后的ID值</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">v2</span> <span class="operator">=</span> atomicInteger.incrementAndGet();</span><br><span class="line">      System.out.println(<span class="string">&quot;v2：&quot;</span>+v2);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取自减后的ID值</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">v3</span> <span class="operator">=</span> atomicInteger.decrementAndGet();</span><br><span class="line">      System.out.println(<span class="string">&quot;v3：&quot;</span>+v3);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使用CAS方式，将就旧值更新成 10</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">v4</span> <span class="operator">=</span> atomicInteger.compareAndSet(v3, <span class="number">10</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;v4：&quot;</span>+v4);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使用CAS方式，更新失败的情况</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">v5</span> <span class="operator">=</span> atomicInteger.compareAndSet(v3, <span class="number">30</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;v5: &quot;</span>+v5);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 先增加再获取</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">v6</span> <span class="operator">=</span> atomicInteger.addAndGet(-<span class="number">5</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;v6: &quot;</span>+v6);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取最新值</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">v7</span> <span class="operator">=</span> atomicInteger.get();</span><br><span class="line">      System.out.println(<span class="string">&quot;v6：&quot;</span>+v7);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">v1：<span class="number">0</span></span><br><span class="line">v2：<span class="number">2</span></span><br><span class="line">v3：<span class="number">1</span></span><br><span class="line">v4：<span class="literal">true</span></span><br><span class="line">v5: <span class="literal">false</span></span><br><span class="line">v6: <span class="number">5</span></span><br><span class="line">v6：<span class="number">5</span></span><br></pre></td></tr></table></figure></div>
<h6 id="原子操作解决原子性问题"><a href="#原子操作解决原子性问题" class="headerlink" title="原子操作解决原子性问题"></a>原子操作解决原子性问题</h6><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个原子操作类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threads</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threads);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    <span class="comment">// 采用原子性操作累加</span></span><br><span class="line">                    a.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞等待10个线程执行完毕</span></span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    <span class="comment">// 输出结果值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;结果值：&quot;</span> + a.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">结果值：<span class="number">10000</span></span><br></pre></td></tr></table></figure></div>

<p>从结果可见，原子操作类也可以实现线程安全。关于底层实现原理是CAS操作，这里不再赘述。</p>
<p>与<code>synchronized</code>和<code>Lock</code>等实现方式相比，原子操作类因为采用无锁的方式实现，因此在某些场景下可以带来更高的执行效率。</p>
<h5 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h5><p>数组类型的原子操作类，<strong>并不是指对数组本身的原子操作，而是对数组中的元素进行原子性操作</strong>，这一点需要特别注意，如果要针对整个数组进行更新，可以采用对象引入数据类型的原子操作类进行处理。JDK提供了以下三个数组类型的原子类：</p>
<ul>
<li><code>AtomicIntegerArray</code>：整型数组类型的原子操作类</li>
<li><code>AtomicLongArray</code>：长整型数组类型的原子操作类</li>
<li><code>AtomicReferenceArray &lt;T&gt;</code>：引用类型数组类型的原子操作类</li>
</ul>
<p>相比与基本类型中的<code>AtomicInteger</code>，方法大致相同，每个方法都增加了一个参数 <code>int i</code>【第一个参数】，表示操作的数组下标。<br>以<code>AmoticIntegerArray</code>为例，其基本用法如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span>[] value = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">AtomicIntegerArray</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(value);</span><br><span class="line">    <span class="comment">// 将下标为[0]的元素，原子性操作加1</span></span><br><span class="line">    array.getAndIncrement(<span class="number">0</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;下标为[0]的元素，更新后的值：&quot;</span> + array.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">下标为[<span class="number">0</span>]的元素，更新后的值：<span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>上文提到的基本类型只能更新一个变量，如果需要原子性更新多个变量，这个时候可以采用对象引用类型的原子操作类，将多个变量封装到一个对象中。JDK同样提供了以下三种引用类型原子类：</p>
<ul>
<li><code>AtomicReference &lt;T&gt;</code>：引用类型原子操作类</li>
<li><code>AtomicStampedReference &lt;T&gt;</code>：带有版本号的引用类型原子操作类,可以解决ABA问题（即变量从A变成B再变成A的问题，导致无法检测到中间的变化）</li>
<li><code>AtomicMarkableReference &lt;T&gt;</code>：带有标记位的引用类型原子操作类，可以用于标记对象的某种状态（如是否已处理）</li>
</ul>
<p>具体方法</p>
<ul>
<li>引用类型<ul>
<li>AtomicReference <T><ul>
<li>T get()：获取当前引用的值。</li>
<li>void set(T newValue)：设置当前引用的值为newValue。</li>
<li>T getAndSet(T newValue)：获取当前引用的值，并设置当前引用的值为newValue。</li>
<li>boolean compareAndSet(T expect, T update)：如果当前引用的值等于expect，则设置当前引用的值为update，并返回true，否则返回false。</li>
</ul>
</li>
<li>AtomicStampedReference <T><ul>
<li>T getReference()：获取当前引用的值。</li>
<li>int getStamp()：获取当前引用的版本号。</li>
<li>boolean compareAndSet(T expectReference, T updateReference, int expectStamp, int updateStamp)：如果当前引用的值等于expectReference，并且当前引用的版本号等于expectStamp，则设置当前引用的值为updateReference，版本号为updateStamp，并返回true，否则返回false。</li>
<li>void set(T newReference, int newStamp)：设置当前引用的值为newReference，版本号为newStamp。</li>
</ul>
</li>
<li>AtomicMarkableReference <T><ul>
<li>T getReference()：获取当前引用的值。</li>
<li>boolean isMarked()：获取当前引用的标记位的值。</li>
<li>boolean compareAndSet(T expectReference, T updateReference, boolean expectMark, boolean updateMark)：如果当前引用的值等于expectReference，并且当前引用的标记位的值等于expectMark，则设置当前引用的值为updateReference，标记位的值为updateMark，并返回true，否则返回false。</li>
<li>void set(T newReference, boolean newMark)：设置当前引用的值为newReference，标记位的值为newMark。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以<code>AtomicReference</code>为例，其基本用法如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置初始值</span></span><br><span class="line">      AtomicReference&lt;User&gt; atomicUser = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">      <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>);</span><br><span class="line">      atomicUser.set(user1);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 采用CAS方式，将user1更新成user2</span></span><br><span class="line">      <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">24</span>);</span><br><span class="line">      atomicUser.compareAndSet(user1,user2);</span><br><span class="line">      System.out.println(<span class="string">&quot;更新后的对象：&quot;</span> + atomicUser.get().toString());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span>  <span class="title class_">User</span>&#123;</span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.name = name;</span><br><span class="line">         <span class="built_in">this</span>.age = age;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;User&#123;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">更新后的对象：User&#123;name = 李四, age = <span class="number">24</span>&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h5><p>某种场景下，可能你只想要原子性更新对象中的某个属性值，此时可以采用字段类型的原子操作类。JKD为我们提供了以下三种字段类型的原子类：</p>
<ul>
<li><code>AtomicIntegerFieldUpdater &lt;T&gt;</code>：原子更新整型字段</li>
<li><code>AtomicLongFieldUpdater &lt;T&gt;</code>：原子更新长整型字段</li>
<li><code>AtomicReferenceFieldUpdater &lt;T&gt;</code>：原子更新引用类型字段</li>
</ul>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>字段类型</p>

    </div>
    <div class="notel-content">
      <ul>
<li>AtomicIntegerFieldUpdater <T><ul>
<li>AtomicIntegerFieldUpdater<V> newUpdater(Class<T> tclass, String fieldName)：创建并返回一个能够原子性更新指定类中指定 int 字段的更新器【静态方法】</li>
<li>int get(T obj)：获取指定对象中字段的当前值。</li>
<li>void set(T obj, int newValue)：将指定对象中字段的值设置为 newValue。</li>
<li>boolean compareAndSet(T obj, int expect, int update)：如果 obj 中字段的当前值等于 expect，则将其更新为 update，并返回 true，否则返回 false。</li>
</ul>
</li>
<li>AtomicLongFileUpdate <T><ul>
<li>AtomicLongFiledUpdate<T> newUpdate(Class<T> clazz, String fieldName):创建并返回一个能够原子性更新指定类中指定 long 字段的更新器【静态方法】</li>
<li>long get(T obj)：获取指定对象中的当前值</li>
<li>void set(T obj, long newValue)：将指定对象中字段的值设置为 newValue。</li>
<li>boolean compareAndSet(T obj, long expect, long update)：如果 obj 中字段的当前值等于 expect，则将其更新为 update，并返回 true，否则返回 false。</li>
</ul>
</li>
<li>AtomicReferenceFiledUpdater&lt;T, V&gt;<ul>
<li>AtomicReferenceFieldUpdater&lt;T, V&gt; newUpdater(Class<T> tclass, Class<V> vclass, String fieldName)：创建并返回一个能够原子性更新指定类中指定引用类型字段的更新器【静态方法】</li>
<li>V get(T obj)：获取指定对象中字段的当前值</li>
<li>void set(T obj, V newValue)：将指定对象中字段的值设置为 newValue</li>
<li>boolean compareAndSet(T obj, V expect, V update)：如果 obj 中字段的当前值等于 expect，则将其更新为 update，并返回 true，否则返回 false。</li>
</ul>
</li>
</ul>

    </div>
  </div>

<blockquote>
<p>需要注意的是：<strong>这些字段类型的原子类需要满足以下条件才可以使用</strong></p>
<ul>
<li>被操作的字段不能是 static 类型</li>
<li>被操作的字段不能是 final 类型</li>
<li>被操作的字段必须被声明为 volatile 类型</li>
<li>属性必须对于当前的 Updater 对象可见，简单的说就是尽量使用 public 修饰字段</li>
</ul>
</blockquote>
<p>以<code>AtomicIntegerFieldUpdater</code>为例，构造一个整数类型的属性引用，具体用法如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置初始值</span></span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>);</span><br><span class="line">      AtomicIntegerFieldUpdater&lt;User&gt; updater = AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">      <span class="comment">// 将 age 的年龄原子性操作加1</span></span><br><span class="line">      updater.getAndIncrement(user);</span><br><span class="line">      System.out.println(<span class="string">&quot;更新后的属性值：&quot;</span> + updater.get(user));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span>  <span class="title class_">User</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line">      <span class="comment">// age 要用 public、volatile 修饰</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.name = name;</span><br><span class="line">         <span class="built_in">this</span>.age = age;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">更新后的属性值：<span class="number">24</span></span><br></pre></td></tr></table></figure></div>

<h5 id="累加器类型"><a href="#累加器类型" class="headerlink" title="累加器类型"></a>累加器类型</h5><p>累加器类型的原子操作类，是从JDK1.8开始加入的，专门用来执行数值类型的数据累加操作，性能更好。</p>
<blockquote>
<p>它的实现原理与基本数据类型的原子类略有不同，当多线程竞争时采用分段累加的思路来实现目标值，在多线程环境中，它比基本数据类型的原子类性能要高出不少，特别是写多的场景。</p>
</blockquote>
<p>JDK为我们提供了以下四种累加器类型的原子类：</p>
<ul>
<li><code>LongAdder</code>：用于累加long类型数据</li>
<li><code>DoubleAdder</code>：用于累加double类型数据</li>
<li><code>LongAccumulator</code>：用于累加long类型数据，并且可以自定义函数操作</li>
<li><code>DoubleAccumulator</code>：用于累加double类型数据，并且可以自定义函数操作</li>
</ul>
<p>以<code>LongAdder</code>为例，具体用法如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">LongAdder</span> <span class="variable">adder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">  <span class="comment">// 自增加 1，默认初始值为0</span></span><br><span class="line">  adder.increment();</span><br><span class="line">  adder.increment();</span><br><span class="line">  adder.increment();</span><br><span class="line">  System.out.println(<span class="string">&quot;最新值：&quot;</span> +  adder.longValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">最新值：<span class="number">3</span></span><br></pre></td></tr></table></figure></div>

<h4 id="原子操作的底层原理"><a href="#原子操作的底层原理" class="headerlink" title="原子操作的底层原理"></a>原子操作的底层原理</h4><p>这里不详细介绍其原理，如果你对ThreadLocal类的原理感兴趣，可以先参考：<a class="link"   href="https://zhuanlan.zhihu.com/p/101430930" >CAS机制详解<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="8-线程的通信"><a href="#8-线程的通信" class="headerlink" title="8.线程的通信"></a>8.线程的通信</h2><blockquote>
<p>线程通信是指多个线程之间共享信息或数据，以协调它们的执行。这在并发编程中非常重要，因为需要确保线程之间的正确协作，以避免竞态条件、死锁等问题。</p>
</blockquote>
<h3 id="8-1-volatile可见性"><a href="#8-1-volatile可见性" class="headerlink" title="8.1.volatile可见性"></a>8.1.volatile可见性</h3><p>同上，可以解决线程的可见性和有序性问题，但不能保证操作的原子性。</p>
<h3 id="8-2-锁与同步"><a href="#8-2-锁与同步" class="headerlink" title="8.2.锁与同步"></a>8.2.锁与同步</h3><p>同上，通过<code>synchronized</code>关键字和<code>Lock</code>锁保证多个线程正确访问共享数据。</p>
<h3 id="8-3-等待-通知机制"><a href="#8-3-等待-通知机制" class="headerlink" title="8.3.等待&#x2F;通知机制"></a>8.3.等待&#x2F;通知机制</h3><p>上面一种是基于”锁”的方式，线程需要不断地去尝试获得锁，如果失败了，再继续尝试。这可能会消耗服务器资源。<br>而基于对象的等待&#x2F;通知机制是一种更加轻量化的方式，它允许一个或多个线程在满足特定条件下进入等待状态，而在其他线程完成某个操作后通过发送通知的方式唤醒这些等待中的线程。这一机制主要依赖<code>java.lang.Object</code>类提供的<code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>方法来实现。</p>
<ul>
<li><code>wait()</code>：当前线程调用该方法时，会释放当前线程所持有的锁，并进入等待状态，直到其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法唤醒当前线程。</li>
<li><code>notify()</code>：随机唤醒一个正在等待该对象监视器的线程。</li>
<li><code>notifyAll()</code>：唤醒所有正在等待该对象监视器的线程。<blockquote>
<p><strong>注意</strong>：<br>在使用等待&#x2F;通知机制时，必须确保在<code>synchronized</code>修饰的方法或代码块内调用这些方法，因为只有持有对象锁的线程才可以执行它们，否则会抛出<code>IllegalMonitorStateException</code>异常。<br>此外，在调用<code>wait()</code>方法后，线程在被唤醒后需要重新获得锁才能继续执行。<br><strong>此外</strong>：<br>Lock接口的实现类<code>ReentrantLock</code>也提供了类似的机制。通过实现<code>Condition</code>接口，也可以实现等待&#x2F;唤醒机制，相比于synchronized使用Object类的三个方法来实现线程的阻塞和运行两个状态的切换，ReentrantLock使用Condition阻塞队列的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>三个方法来实现线程阻塞和运行两个状态的切换，进而实现线程间的通信。这些方法的使用和synchronized的使用类型，不再赘述。<br><strong>经典范式(生产者-消费者)</strong>：</p>
</blockquote>
</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">available</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="type">int</span> value)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (available) &#123;</span><br><span class="line">            wait();  <span class="comment">// 如果数据可用，等待消费者消费</span></span><br><span class="line">        &#125;</span><br><span class="line">        data = value;</span><br><span class="line">        System.out.println(<span class="string">&quot;Produced: &quot;</span> + data);</span><br><span class="line">        available = <span class="literal">true</span>;</span><br><span class="line">        notify();  <span class="comment">// 通知消费者可以消费数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (!available) &#123;</span><br><span class="line">            wait();  <span class="comment">// 如果数据不可用，等待生产者生产</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumed: &quot;</span> + data);</span><br><span class="line">        available = <span class="literal">false</span>;</span><br><span class="line">        notify();  <span class="comment">// 通知生产者可以生产数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SharedResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedResource</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    resource.produce(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    resource.consume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Produced: <span class="number">1</span></span><br><span class="line">Consumed: <span class="number">1</span></span><br><span class="line">Produced: <span class="number">2</span></span><br><span class="line">Consumed: <span class="number">2</span></span><br><span class="line">Produced: <span class="number">3</span></span><br><span class="line">Consumed: <span class="number">3</span></span><br></pre></td></tr></table></figure></div>
<p>在这个示例中：</p>
<ul>
<li>生产者线程生成数据并调用produce()方法。produce()方法在数据可用时等待，并在生成新数据后通知消费者。</li>
<li>消费者线程消费数据并调用consume()方法。consume()方法在数据不可用时等待，并在消费数据后通知生产者。</li>
</ul>
<h3 id="8-4-join方法"><a href="#8-4-join方法" class="headerlink" title="8.4.join方法"></a>8.4.join方法</h3><p><code>join( )</code>方法是Java中<code>Thread</code>类的一个关键实例方法，用于同步线程执行。当一个线程调用另一个线程的<code>join( )</code>方法时，当前线程将进入等待状态，直到被调用<code>join( )</code>的线程完成其任务并结束。这在需要确保主线程等待子线程执行完毕之后再继续执行的场景中非常有用。【若在join方法中传入了参数，则是等待调用join()方法的线程执行完毕，或者直到指定的毫秒数之后】</p>
<p>例如，假设主线程创建了一个耗时计算的任务交给子线程执行，并且主线程希望在子线程完成计算后获取结果：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinExample</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LongRunningTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是子线程，开始执行耗时计算...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> performComputation(); <span class="comment">// 执行计算</span></span><br><span class="line">                System.out.println(<span class="string">&quot;我是子线程，计算完成，结果为: &quot;</span> + result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">performComputation</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span>; <span class="comment">// 示例计算结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">longRunning</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">LongRunningTask</span>());</span><br><span class="line">        longRunning.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程等待子线程完成</span></span><br><span class="line">        longRunning.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子线程结束后，主线程可以安全地访问子线程的结果（此处假设已通过共享变量或其他机制传递）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：子线程已完成，我可以继续执行后续操作了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="8-5-ThreadLocal类"><a href="#8-5-ThreadLocal类" class="headerlink" title="8.5.ThreadLocal类"></a>8.5.ThreadLocal类</h3><p><code>ThreadLocal</code>是一个用于创建线程本地变量的工具类。它通过维护一个内部弱引用的Map来管理每个线程的本地变量。这里不详细介绍其原理，如果你对<code>ThreadLocal</code>类的原理感兴趣，可以先参考：<a class="link"   href="https://yasinshaw.com/articles?keyword=threadlocal" >ThreadLocal类原理<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<p>一些朋友称<code>ThreadLocal</code>为线程本地变量或线程本地存储。严格来说，<code>ThreadLocal</code>类并不用于多线程间的通信，而是<strong>确保每个线程都有自己”独立”的变量，线程之间互不干扰</strong>。<code>ThreadLocal</code>为每个线程创建一个变量副本，每个线程可以访问自己内部的副本变量。</p>
<p><code>ThreadLocal</code>类最常用的方法是<code>set</code>方法和<code>get</code>方法。以下是一个示例代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个ThreadLocal变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocalValue = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并启动两个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    threadLocalValue.set(threadLocalValue.get() + <span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + threadLocalValue.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                threadLocalValue.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    threadLocalValue.set(threadLocalValue.get() + <span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + threadLocalValue.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                threadLocalValue.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Thread-<span class="number">1</span>: <span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span>: <span class="number">4</span></span><br><span class="line">Thread-<span class="number">0</span>: <span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>: <span class="number">6</span></span><br><span class="line">Thread-<span class="number">1</span>: <span class="number">8</span></span><br><span class="line">Thread-<span class="number">1</span>: <span class="number">10</span></span><br><span class="line">Thread-<span class="number">0</span>: <span class="number">2</span></span><br><span class="line">Thread-<span class="number">0</span>: <span class="number">3</span></span><br><span class="line">Thread-<span class="number">0</span>: <span class="number">4</span></span><br><span class="line">Thread-<span class="number">0</span>: <span class="number">5</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>注意事项</strong>:</p>
<ul>
<li><strong>独立副本</strong>：每个线程都有自己独立的副本变量，线程之间互不干扰。</li>
<li><strong>内存泄漏</strong>：由于<code>ThreadLocal</code>使用的是弱引用，未及时清理的线程副本变量可能会导致内存泄漏，因此在使用完<code>ThreadLocal</code>变量后，建议调用其<code>remove()</code>方法清理数据。</li>
</ul>
</blockquote>
<h3 id="8-6-管道通信"><a href="#8-6-管道通信" class="headerlink" title="8.6.管道通信"></a>8.6.管道通信</h3><p>Java中的管道通信是通过管道输入流和管道输出流来实现的。<strong>这种通信方式主要用于两个线程之间传递数据，管道的一端连接输入流，另一端连接输出流</strong>。JDK提供了<code>PipedInputStream</code>、<code>PipedOutputStream</code>、<code>PipedReader</code>、<code>PipedWriter</code>，前两者实现字节流的管道通信，后两者实现字符流的管道通信。</p>
<p>管道通信的输入流和输出流通过<code>connect()</code>进行连接，如果没有将输入流和输出流绑定起来，对于该流的访问将会抛出异常【输入流调用方法连接输出流 或者 输出流调用方法连接输入流 任选其一即可】<br><strong>一个输出流可以绑定到多个输入流，但是一个输入流不能绑定到多个输出流。</strong></p>
<p><strong>应用场景</strong>：<br>管道通信的使用多半和I&#x2F;O流有关，当我们一个线程需要先获取另一个线程发送的数据（字符串或文件等），就需要使用管道通信了。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的示例代码使用的是基于字符的：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pipe</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReaderThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> PipedReader reader;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ReaderThread</span><span class="params">(PipedReader reader)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.reader = reader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;this is reader&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">receive</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((receive = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.print((<span class="type">char</span>)receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriterThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> PipedWriter writer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">WriterThread</span><span class="params">(PipedWriter writer)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.writer = writer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;this is writer&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">receive</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.write(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">PipedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedWriter</span>();</span><br><span class="line">        <span class="type">PipedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedReader</span>();</span><br><span class="line">        writer.connect(reader); <span class="comment">// 这里注意一定要连接，才能通信</span></span><br><span class="line">        <span class="comment">//reader.connect(writer);</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ReaderThread</span>(reader)).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">WriterThread</span>(writer)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span> is reader</span><br><span class="line"><span class="built_in">this</span> is writer</span><br><span class="line">test</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
